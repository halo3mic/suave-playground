{
  "language": "Solidity",
  "sources": {
    "contracts/blockad/BlockAdV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Author: Miha Lotric (halo3mic)\n\npragma solidity ^0.8.8;\n\nimport { AnyBidContract, Suave } from \"../standard_peekers/bids.sol\";\nimport { ConfidentialControl } from \"./lib/ConfidentialControl.sol\";\nimport { DynamicUintArray } from \"./lib/Utils.sol\";\nimport { Builder } from \"./lib/Builder.sol\";\n\n\ncontract BlockAdAuctionV2 is AnyBidContract, ConfidentialControl {\n\tusing DynamicUintArray for bytes;\n\n\tstruct AdRequest {\n\t\tuint id;\n\t\tstring extra;\n\t\tuint blockLimit;\n\t\tSuave.BidId paymentBidId;\n\t}\n\tstruct Offer {\n\t\tuint id;\n\t\tstring extra;\n\t\tuint64 egp;\n\t\tbytes paymentBundle;\n\t}\n\n\tevent RequestAdded(uint id, string extra, uint blockLimit);\n\tevent RequestRemoved(uint id);\n\tevent RequestIncluded(uint id, uint64 egp, string blockHash);\n\n\tstring internal constant PB_NAMESPACE = \"blockad:v0:paymentBundle\";\n\tstring internal constant EB_NAMESPACE = \"default:v0:ethBundles\";\n\tstring internal constant EB_SIM_NAMESPACE = \"default:v0:ethBundleSimResults\";\n\tBuilder public builder;\n\tAdRequest[] public requests;\n\tuint public nextId;\n\n\t/**********************************************************************\n\t *                           ‚õìÔ∏è ON-CHAIN METHODS                       *\n\t ***********************************************************************/\n\n\tconstructor(string memory boostRelayUrl_) {\n\t\tbuilder = new Builder(boostRelayUrl_);\n\t}\n\n\tfunction buyAdCallback(AdRequest calldata request, UnlockArgs calldata uArgs) external unlock(uArgs) {\n\t\trequests.push(request);\n\t\tnextId++;\n\t\temit RequestAdded(request.id, request.extra, request.blockLimit);\n\t}\n\n\tfunction buildCallback(\n\t\tbytes memory builderCall,\n\t\tbytes memory includedRequestB,\n\t\tbytes memory pendingRemovalsB,\n\t\tUnlockArgs calldata uArgs\n\t) external unlock(uArgs) {\n\t\tif (pendingRemovalsB.length > 0) {\n\t\t\tremoveRequests(pendingRemovalsB.export());\n\t\t}\n\t\tstring memory blockHash = handleBuilderCallback(address(builder), builderCall);\n\t\thandleIncludedRequest(includedRequestB, blockHash);\n\t}\n\n\tfunction requestsLength() public view returns (uint) {\n\t\treturn requests.length;\n\t}\n\n\t/**********************************************************************\n\t *                         üîí CONFIDENTIAL METHODS                      *\n\t ***********************************************************************/\n\n\tfunction confidentialConstructor() public view override onlyConfidential returns (bytes memory) {\n\t\treturn ConfidentialControl.confidentialConstructor();\n\t}\n\n\tfunction buyAd(uint64 blockLimit, string memory extra) external onlyConfidential returns (bytes memory) {\n\t\tbytes memory paymentBundle = this.fetchBidConfidentialBundleData();\n\t\t(,uint64 egp) = simulateBundleSafe(paymentBundle, true);\n\t\tcrequire(egp > 0, \"egp too low\");\n\t\tSuave.BidId paymentBidId = storePaymentBundle(paymentBundle);\n\t\tAdRequest memory request = AdRequest(nextId, extra, blockLimit, paymentBidId);\n\t\treturn abi.encodeWithSelector(this.buyAdCallback.selector, request, getUnlockPair());\n\t}\n\n\tfunction buildBlock(\n\t\tSuave.BuildBlockArgs memory blockArgs,\n\t\tuint64 blockHeight\n\t) public onlyConfidential returns (bytes memory) {\n\t\tcrequire(requests.length > 0, \"No requests\");\n\t\t(Offer memory bestOffer, bytes memory removals) = filterOffers(blockHeight);\n\t\tcrequire(bestOffer.egp > 0, \"No valid offers\");\n\n\t\tstoreBundleInPool(blockHeight, bestOffer);\n\t\tblockArgs.extra = bytes(bestOffer.extra);\n\t\t// Expect flow is ordered by egp; if one wants to fail payment they need higher egp\n\t\tbytes memory externalCallback = builder.buildFromPool(blockArgs, blockHeight);\n\n\t\treturn\n\t\t\tabi.encodeWithSelector(\n\t\t\t\tthis.buildCallback.selector,\n\t\t\t\texternalCallback,\n\t\t\t\tabi.encode(bestOffer.id, bestOffer.egp),\n\t\t\t\tremovals,\n\t\t\t\tgetUnlockPair()\n\t\t\t);\n\t}\n\n\t/**********************************************************************\n\t *                         üõ†Ô∏è INTERNAL METHODS                          *\n\t ***********************************************************************/\n\n\tfunction removeRequests(uint[] memory pendingRemovals) internal {\n\t\t// Assume that the pendingRemovals were added in ascending order\n\t\t// Assume that pendingRemovals.length <= requests.length\n\t\tfor (uint i = pendingRemovals.length; i > 0; --i) {\n\t\t\tuint indexToRemove = pendingRemovals[i - 1];\n\t\t\tuint requestId = requests[indexToRemove].id;\n\t\t\tif (indexToRemove < requests.length - 1) {\n\t\t\t\trequests[indexToRemove] = requests[requests.length - 1];\n\t\t\t}\n\t\t\trequests.pop();\n\t\t\temit RequestRemoved(requestId);\n\t\t}\n\t}\n\n\tfunction handleIncludedRequest(bytes memory includedRequestB, string memory blockHash) internal {\n\t\t(uint id, uint64 egp) = abi.decode(includedRequestB, (uint, uint64));\n\t\temit RequestIncluded(id, egp, blockHash);\n\t}\n\n\tfunction handleBuilderCallback(address target, bytes memory data) internal returns (string memory) {\n\t\t(bool success, bytes memory res) = target.call(data);\n\t\tcrequire(success, \"External call failed\");\n\t\treturn abi.decode(res, (string));\n\t}\n\n\tfunction storePaymentBundle(bytes memory paymentBundle) internal view returns (Suave.BidId) {\n\t\taddress[] memory peekers = new address[](1);\n\t\tpeekers[0] = address(this);\n\t\tSuave.Bid memory paymentBid = Suave.newBid(0, peekers, peekers, PB_NAMESPACE);\n\t\tSuave.confidentialStore(paymentBid.id, PB_NAMESPACE, paymentBundle);\n\t\treturn paymentBid.id;\n\t}\n\n\tfunction filterOffers(uint blockHeight) internal view returns (Offer memory bestOffer, bytes memory removals) {\n\t\tfor (uint i; i < requests.length; ++i) {\n\t\t\tAdRequest memory request = requests[i];\n\t\t\tif (request.blockLimit < blockHeight) {\n\t\t\t\tremovals = removals.append(i);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbytes memory paymentBundle = Suave.confidentialRetrieve(request.paymentBidId, PB_NAMESPACE);\n\t\t\t(bool success, uint64 egp) = simulateBundleSafe(paymentBundle, false);\n\t\t\tif (!success || egp == 0) {\n\t\t\t\tremovals = removals.append(i);\n\t\t\t} else if (egp > bestOffer.egp) {\n\t\t\t\tbestOffer = Offer(request.id, request.extra, egp, paymentBundle);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction storeBundleInPool(uint64 blockHeight, Offer memory bestOffer) internal view {\n\t\taddress[] memory allowedPeekers = new address[](3);\n\t\tallowedPeekers[0] = address(builder);\n\t\tallowedPeekers[1] = Suave.BUILD_ETH_BLOCK;\n\t\tallowedPeekers[2] = address(this);\n\t\tSuave.Bid memory paymentBundleBid = Suave.newBid(blockHeight, allowedPeekers, allowedPeekers, EB_NAMESPACE);\n\t\tSuave.confidentialStore(paymentBundleBid.id, EB_NAMESPACE, bestOffer.paymentBundle);\n\t\tSuave.confidentialStore(paymentBundleBid.id, EB_SIM_NAMESPACE, abi.encode(bestOffer.egp));\n\t}\n}\n"
    },
    "contracts/blockad/lib/Builder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Author: Miha Lotric (halo3mic)\n\npragma solidity ^0.8.8;\n\nimport { EthBlockBidContract, Suave } from \"../../standard_peekers/bids.sol\";\nimport { SuaveContract } from \"./SuaveContract.sol\";\n\n\ncontract Builder is EthBlockBidContract, SuaveContract {\n\tstring constant BB_NAMESPACE = \"blockad:v0:builderBid\";\n\tstring boostRelayUrl;\n\n\tevent RelaySubmission(bytes32 bidId);\n\n\tconstructor(string memory boostRelayUrl_) {\n\t\tboostRelayUrl = boostRelayUrl_;\n\t}\n\n\tfunction buildAndEmitCallback(string memory blockHash, bytes32 id) external returns (string memory) {\n\t\temit RelaySubmission(id);\n\t\treturn blockHash;\n\t}\n\n\tfunction buildAndEmit(\n\t\tSuave.BuildBlockArgs memory blockArgs,\n\t\tuint64 blockHeight,\n\t\tSuave.BidId[] memory bids,\n\t\tstring memory namespace\n\t) public virtual override onlyConfidential returns (bytes memory) {\n\t\t(Suave.Bid memory blockBid, bytes memory builderBid) = this.doBuild(blockArgs, blockHeight, bids, namespace);\n\t\tstoreBuilderBid(blockBid.id, builderBid);\n\t\tsubmitToRelay(builderBid);\n\t\tstring memory blockHash = extractBlockHash(builderBid, blockArgs.slot);\n\t\treturn abi.encodeWithSelector(this.buildAndEmitCallback.selector, blockHash, keccak256(builderBid));\n\t}\n\n\tfunction submitBlock(uint slot) external view onlyConfidential returns (bytes memory) {\n\t\tbytes memory builderBid = Suave.confidentialInputs();\n\t\tsubmitToRelay(builderBid);\n\t\tstring memory blockHash = extractBlockHash(builderBid, slot);\n\t\treturn abi.encodeWithSelector(this.buildAndEmitCallback.selector, blockHash, keccak256(builderBid));\n\t}\n\n\tfunction submitToRelay(bytes memory builderBid) internal view {\n\t\t(bool success, bytes memory data) = Suave.SUBMIT_ETH_BLOCK_BID_TO_RELAY\n\t\t\t.staticcall(abi.encode(boostRelayUrl, builderBid));\n\t\tif (!success) {\n\t\t\trevert SuaveErrorWithData(string(data), builderBid);\n\t\t}\n\t}\n\n\tfunction storeBuilderBid(Suave.BidId blockBidId, bytes memory builderBid) internal view {\n\t\taddress[] memory peekers = new address[](1);\n\t\tpeekers[0] = address(this);\n\t\tSuave.confidentialStore(blockBidId, BB_NAMESPACE, builderBid);\n\t}\n\n\t// Extract block-hash from stringified SubmitBlockRequest JSON object - method will fail if the struct changes!\n\tfunction extractBlockHash(bytes memory builderBid, uint slot) public pure returns (string memory) {\n\t\tuint resultBytesLen = 64;\n\t\tuint offset = 121 + decLen(slot);\n\t\tbytes memory result = new bytes(resultBytesLen);\n\t\tassembly {\n\t\t\tfor { let i:=32 } lt(i, add(resultBytesLen, 32)) { i:=add(i, 32) } {\n\t\t\t\tmstore(add(result, i), mload(add(builderBid, add(offset, i))))\n\t\t\t}\n\t\t}\n\t\treturn string(result);\n\t}\n\n\tfunction decLen(uint num) internal pure returns (uint count) {\n\t\tassembly {\n\t\t\tfor { let dec := 10 } true { dec := mul(dec, 10) } {\n\t\t\t\tcount := add(count, 1)\n\t\t\t\tswitch lt(num, dec)\n\t\t\t\t\tcase 1 { break }\n\t\t\t}\n\t\t}\n\t}\n}"
    },
    "contracts/blockad/lib/ConfidentialControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Author: Miha Lotric (halo3mic)\n\npragma solidity ^0.8.8;\n\nimport { SuaveContract, Suave } from \"./SuaveContract.sol\";\n\n\nabstract contract ConfidentialControl is SuaveContract {\n\tstruct UnlockArgs {\n\t\tbytes32 key;\n\t\tbytes32 nextHash;\n\t}\n\n\tmodifier unlock(UnlockArgs calldata unlockPair) {\n\t\tcrequire(isValidKey(unlockPair.key), \"Invalid key\");\n\t\t_;\n\t\tpresentHash = unlockPair.nextHash;\n\t\tnonce++;\n\t}\n\n\tstring internal constant S_NAMESPACE = \"blockad:v0:secret\";\n\tSuave.BidId internal secretBidId;\n\tbytes32 internal presentHash;\n\tuint internal nonce;\n\n\t/**********************************************************************\n\t *                           ‚õìÔ∏è ON-CHAIN METHODS                       *\n\t ***********************************************************************/\n\n\tfunction ccCallback(bytes32 nextHash, Suave.BidId sBidId) external {\n\t\tcrequire(!isInitialized(), \"Already initialized\");\n\t\tpresentHash = nextHash;\n\t\tsecretBidId = sBidId;\n\t}\n\n\tfunction isInitialized() public view returns (bool) {\n\t\treturn presentHash != 0;\n\t}\n\n\t/**********************************************************************\n\t *                         üîí CONFIDENTIAL METHODS                      *\n\t ***********************************************************************/\n\n\tfunction confidentialConstructor() public view virtual onlyConfidential returns (bytes memory) {\n\t\tcrequire(!isInitialized(), \"Already initialized\");\n\t\tbytes memory secret = Suave.confidentialInputs();\n\t\tSuave.BidId sBidId = storeSecret(secret);\n\t\tbytes32 nextHash = makeHash(abi.decode(secret, (bytes32)), nonce);\n\t\treturn abi.encodeWithSelector(this.ccCallback.selector, nextHash, sBidId);\n\t}\n\n\t/**********************************************************************\n\t *                         üõ†Ô∏è INTERNAL METHODS                          *\n\t ***********************************************************************/\n\n\tfunction storeSecret(bytes memory secret) internal view returns (Suave.BidId) {\n\t\taddress[] memory peekers = new address[](3);\n\t\tpeekers[0] = address(this);\n\t\tpeekers[1] = Suave.FETCH_BIDS;\n\t\tpeekers[2] = Suave.CONFIDENTIAL_RETRIEVE;\n\t\tSuave.Bid memory secretBid = Suave.newBid(0, peekers, peekers, S_NAMESPACE);\n\t\tSuave.confidentialStore(secretBid.id, S_NAMESPACE, secret);\n\t\treturn secretBid.id;\n\t}\n\n\tfunction isValidKey(bytes32 key) internal view returns (bool) {\n\t\treturn keccak256(abi.encode(key)) == presentHash;\n\t}\n\n\tfunction getUnlockPair() internal view returns (UnlockArgs memory) {\n\t\treturn UnlockArgs(getKey(nonce), getHash(nonce + 1));\n\t}\n\n\tfunction getHash(uint _nonce) internal view returns (bytes32) {\n\t\treturn keccak256(abi.encode(getKey(_nonce)));\n\t}\n\n\tfunction getKey(uint _nonce) internal view returns (bytes32) {\n\t\treturn makeKey(getSecret(), _nonce);\n\t}\n\n\tfunction makeHash(bytes32 secret, uint _nonce) internal pure returns (bytes32) {\n\t\treturn keccak256(abi.encode(makeKey(secret, _nonce)));\n\t}\n\n\tfunction makeKey(bytes32 secret, uint _nonce) internal pure returns (bytes32) {\n\t\treturn keccak256(abi.encode(secret, _nonce));\n\t}\n\n\tfunction getSecret() internal view returns (bytes32) {\n\t\tbytes memory secretB = Suave.confidentialRetrieve(secretBidId, S_NAMESPACE);\n\t\treturn abi.decode(secretB, (bytes32));\n\t}\n}\n"
    },
    "contracts/blockad/lib/SuaveContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Author: Miha Lotric (halo3mic)\n\npragma solidity ^0.8.8;\n\nimport { Suave } from \"../../standard_peekers/bids.sol\";\n\n\nabstract contract SuaveContract {\n\terror SuaveError(string message);\n\terror SuaveErrorWithData(string message, bytes data);\n\n\tmodifier onlyConfidential() {\n\t\tcrequire(Suave.isConfidential(), \"Not confidential\");\n\t\t_;\n\t}\n\n\tfunction simulateBundleSafe(bytes memory bundle, bool doRevert) internal view returns (bool valid, uint64 egp) {\n\t\t(bool success, bytes memory d) = Suave.SIMULATE_BUNDLE.staticcall{ gas: 20_000 }(abi.encode(bundle));\n\t\tcrequire(!doRevert || success, string(d));\n\t\tif (success) {\n\t\t\treturn (true, abi.decode(d, (uint64)));\n\t\t}\n\t}\n\n\tfunction crequire(bool condition, string memory message) internal pure {\n\t\tif (!condition) {\n\t\t\trevert SuaveError(message);\n\t\t}\n\t}\n}\n"
    },
    "contracts/blockad/lib/Utils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.8;\n\n\nlibrary DynamicUintArray {\n\tfunction append(bytes memory a, uint e) internal pure returns (bytes memory) {\n\t\treturn bytes.concat(a, TypeConversion.toBytes(e));\n\t}\n\n\tfunction export(bytes memory a) internal pure returns (uint[] memory) {\n\t\treturn TypeConversion.toUints(a);\n\t}\n}\n\nlibrary TypeConversion {\n\tfunction toBytes(uint x) internal pure returns (bytes memory y) {\n\t\ty = new bytes(32);\n\t\tassembly {\n\t\t\tmstore(add(y, 32), x)\n\t\t}\n\t}\n\n\tfunction toUint(bytes memory x, uint offset) internal pure returns (uint y) {\n\t\tassembly {\n\t\t\ty := mload(add(x, offset))\n\t\t}\n\t}\n\n\tfunction toUints(bytes memory xs) internal pure returns (uint[] memory ys) {\n\t\tys = new uint[](xs.length / 32);\n\t\tfor (uint i = 0; i < xs.length / 32; i++) {\n\t\t\tys[i] = toUint(xs, i * 32 + 32);\n\t\t}\n\t}\n}\n"
    },
    "contracts/libraries/Suave.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.8;\n\nlibrary Suave {\n    error PeekerReverted(address, bytes);\n\n    type BidId is bytes16;\n\n    struct Bid {\n        BidId id;\n        BidId salt;\n        uint64 decryptionCondition;\n        address[] allowedPeekers;\n        address[] allowedStores;\n        string version;\n    }\n\n    struct BuildBlockArgs {\n        uint64 slot;\n        bytes proposerPubkey;\n        bytes32 parent;\n        uint64 timestamp;\n        address feeRecipient;\n        uint64 gasLimit;\n        bytes32 random;\n        Withdrawal[] withdrawals;\n        bytes extra;\n    }\n\n    struct SubmitBlockRequest {\n        BidTrace message;\n        ExecutionPayload executionPayload;\n        bytes signature; // BLSSignature as bytes of fixed length 96\n    }\n\n    struct BidTrace {\n        uint256 slot;\n        bytes32 parentHash;\n        bytes32 blockHash;\n        bytes builderPubkey; // Representing BLSPubKey with dynamic bytes\n        bytes proposerPubkey;\n        address proposerFeeRecipient; // ExecutionAddress as Ethereum address\n        uint256 gasLimit;\n        uint256 gasUsed;\n        uint256 value; // uint256.Int as uint256\n    }\n\n    struct ExecutionPayload {\n        bytes32 parentHash;\n        address feeRecipient; // ExecutionAddress as Ethereum address\n        bytes32 stateRoot;\n        bytes32 receiptsRoot;\n        bytes32 logsBloom; // Assuming fixed size 256 bytes, may need adjustment\n        bytes32 prevRandao;\n        uint256 blockNumber;\n        uint256 gasLimit;\n        uint256 gasUsed;\n        uint256 timestamp;\n        bytes32 extraData; // Assuming fixed size, may need adjustment\n        bytes32 baseFeePerGas;\n        bytes32 blockHash;\n        bytes transactions; // Assuming Transaction is another struct\n        Withdrawal[] withdrawals; // Assuming Withdrawal is another struct\n    }\n\n    struct ExecutionPayloadEnvelope {\n        ExecutableData executionPayload;\n        uint256 blockValue;\n    }\n\n    struct ExecutableData {\n        bytes32 parentHash;\n        address feeRecipient;\n        bytes32 stateRoot;\n        bytes32 receiptsRoot;\n        bytes32 logsBloom; // Fixed size, change accordingly\n        bytes32 random;\n        uint256 number;\n        uint256 gasLimit;\n        uint256 gasUsed;\n        uint256 timestamp;\n        bytes32 extraData; // Fixed size, change accordingly\n        uint256 baseFeePerGas;\n        bytes32 blockHash;\n        bytes32[] transactions; // Fixed size arrays or handle dynamically\n        Withdrawal[] withdrawals; // Assuming Withdrawal is another struct\n    }\n\n    struct Withdrawal {\n        uint64 index;\n        uint64 validator;\n        address Address;\n        uint64 amount;\n    }\n\n    address public constant ANYALLOWED = 0xC8df3686b4Afb2BB53e60EAe97EF043FE03Fb829;\n\n    address public constant IS_CONFIDENTIAL_ADDR = 0x0000000000000000000000000000000042010000;\n\n    address public constant BUILD_ETH_BLOCK = 0x0000000000000000000000000000000042100001;\n\n    address public constant CONFIDENTIAL_INPUTS = 0x0000000000000000000000000000000042010001;\n\n    address public constant CONFIDENTIAL_RETRIEVE = 0x0000000000000000000000000000000042020001;\n\n    address public constant CONFIDENTIAL_STORE = 0x0000000000000000000000000000000042020000;\n\n    address public constant ETHCALL = 0x0000000000000000000000000000000042100003;\n\n    address public constant EXTRACT_HINT = 0x0000000000000000000000000000000042100037;\n\n    address public constant FETCH_BIDS = 0x0000000000000000000000000000000042030001;\n\n    address public constant FILL_MEV_SHARE_BUNDLE = 0x0000000000000000000000000000000043200001;\n\n    address public constant NEW_BID = 0x0000000000000000000000000000000042030000;\n\n    address public constant SIGN_ETH_TRANSACTION = 0x0000000000000000000000000000000040100001;\n\n    address public constant SIMULATE_BUNDLE = 0x0000000000000000000000000000000042100000;\n\n    address public constant SUBMIT_BUNDLE_JSON_RPC = 0x0000000000000000000000000000000043000001;\n\n    address public constant SUBMIT_ETH_BLOCK_BID_TO_RELAY = 0x0000000000000000000000000000000042100002;\n\n    // Returns whether execution is off- or on-chain\n    function isConfidential() internal view returns (bool b) {\n        (bool success, bytes memory isConfidentialBytes) = IS_CONFIDENTIAL_ADDR.staticcall(\"\");\n        if (!success) {\n            revert PeekerReverted(IS_CONFIDENTIAL_ADDR, isConfidentialBytes);\n        }\n        assembly {\n            // Load the length of data (first 32 bytes)\n            let len := mload(isConfidentialBytes)\n            // Load the data after 32 bytes, so add 0x20\n            b := mload(add(isConfidentialBytes, 0x20))\n        }\n    }\n\n    function buildEthBlock(BuildBlockArgs memory blockArgs, BidId bidId, string memory namespace)\n        internal\n        view\n        returns (bytes memory, bytes memory)\n    {\n        (bool success, bytes memory data) = BUILD_ETH_BLOCK.staticcall(abi.encode(blockArgs, bidId, namespace));\n        if (!success) {\n            revert PeekerReverted(BUILD_ETH_BLOCK, data);\n        }\n\n        return abi.decode(data, (bytes, bytes));\n    }\n\n    function confidentialInputs() internal view returns (bytes memory) {\n        (bool success, bytes memory data) = CONFIDENTIAL_INPUTS.staticcall(abi.encode());\n        if (!success) {\n            revert PeekerReverted(CONFIDENTIAL_INPUTS, data);\n        }\n\n        return data;\n    }\n\n    function confidentialRetrieve(BidId bidId, string memory key) internal view returns (bytes memory) {\n        (bool success, bytes memory data) = CONFIDENTIAL_RETRIEVE.staticcall(abi.encode(bidId, key));\n        if (!success) {\n            revert PeekerReverted(CONFIDENTIAL_RETRIEVE, data);\n        }\n\n        return data;\n    }\n\n    function confidentialStore(BidId bidId, string memory key, bytes memory data1) internal view {\n        (bool success, bytes memory data) = CONFIDENTIAL_STORE.staticcall(abi.encode(bidId, key, data1));\n        if (!success) {\n            revert PeekerReverted(CONFIDENTIAL_STORE, data);\n        }\n    }\n\n    function ethcall(address contractAddr, bytes memory input1) internal view returns (bytes memory) {\n        (bool success, bytes memory data) = ETHCALL.staticcall(abi.encode(contractAddr, input1));\n        if (!success) {\n            revert PeekerReverted(ETHCALL, data);\n        }\n\n        return abi.decode(data, (bytes));\n    }\n\n    function extractHint(bytes memory bundleData) internal view returns (bytes memory) {\n        require(isConfidential());\n        (bool success, bytes memory data) = EXTRACT_HINT.staticcall(abi.encode(bundleData));\n        if (!success) {\n            revert PeekerReverted(EXTRACT_HINT, data);\n        }\n\n        return data;\n    }\n\n    function fetchBids(uint64 cond, string memory namespace) internal view returns (Bid[] memory) {\n        (bool success, bytes memory data) = FETCH_BIDS.staticcall(abi.encode(cond, namespace));\n        if (!success) {\n            revert PeekerReverted(FETCH_BIDS, data);\n        }\n\n        return abi.decode(data, (Bid[]));\n    }\n\n    function fillMevShareBundle(BidId bidId) internal view returns (bytes memory) {\n        require(isConfidential());\n        (bool success, bytes memory data) = FILL_MEV_SHARE_BUNDLE.staticcall(abi.encode(bidId));\n        if (!success) {\n            revert PeekerReverted(FILL_MEV_SHARE_BUNDLE, data);\n        }\n\n        return data;\n    }\n\n    function newBid(\n        uint64 decryptionCondition,\n        address[] memory allowedPeekers,\n        address[] memory allowedStores,\n        string memory bidType\n    ) internal view returns (Bid memory) {\n        (bool success, bytes memory data) =\n            NEW_BID.staticcall(abi.encode(decryptionCondition, allowedPeekers, allowedStores, bidType));\n        if (!success) {\n            revert PeekerReverted(NEW_BID, data);\n        }\n\n        return abi.decode(data, (Bid));\n    }\n\n    function signEthTransaction(bytes memory txn, string memory chainId, string memory signingKey)\n        internal\n        view\n        returns (bytes memory)\n    {\n        (bool success, bytes memory data) = SIGN_ETH_TRANSACTION.staticcall(abi.encode(txn, chainId, signingKey));\n        if (!success) {\n            revert PeekerReverted(SIGN_ETH_TRANSACTION, data);\n        }\n\n        return abi.decode(data, (bytes));\n    }\n\n    function simulateBundle(bytes memory bundleData) internal view returns (uint64) {\n        (bool success, bytes memory data) = SIMULATE_BUNDLE.staticcall(abi.encode(bundleData));\n        if (!success) {\n            revert PeekerReverted(SIMULATE_BUNDLE, data);\n        }\n\n        return abi.decode(data, (uint64));\n    }\n\n    function submitBundleJsonRPC(string memory url, string memory method, bytes memory params)\n        internal\n        view\n        returns (bytes memory)\n    {\n        require(isConfidential());\n        (bool success, bytes memory data) = SUBMIT_BUNDLE_JSON_RPC.staticcall(abi.encode(url, method, params));\n        if (!success) {\n            revert PeekerReverted(SUBMIT_BUNDLE_JSON_RPC, data);\n        }\n\n        return data;\n    }\n\n    function submitEthBlockBidToRelay(string memory relayUrl, bytes memory builderBid)\n        internal\n        view\n        returns (bytes memory)\n    {\n        require(isConfidential());\n        (bool success, bytes memory data) = SUBMIT_ETH_BLOCK_BID_TO_RELAY.staticcall(abi.encode(relayUrl, builderBid));\n        if (!success) {\n            revert PeekerReverted(SUBMIT_ETH_BLOCK_BID_TO_RELAY, data);\n        }\n\n        return data;\n    }\n}\n"
    },
    "contracts/standard_peekers/bids.sol": {
      "content": "pragma solidity ^0.8.8;\n\nimport \"../libraries/Suave.sol\";\n\ncontract AnyBidContract {\n\n\tevent BidEvent(\n\t\tSuave.BidId bidId,\n\t\tuint64 decryptionCondition,\n\t\taddress[] allowedPeekers\n\t);\n\n\tfunction fetchBidConfidentialBundleData() public returns (bytes memory) {\n\t\trequire(Suave.isConfidential());\n\t\t\n\t\tbytes memory confidentialInputs = Suave.confidentialInputs();\n\t\treturn abi.decode(confidentialInputs, (bytes));\n\t}\n\n\t// Bids to this contract should not be trusted!\n\tfunction emitBid(Suave.Bid calldata bid) public {\n\t\temit BidEvent(bid.id, bid.decryptionCondition, bid.allowedPeekers);\n\t}\n}\n\ncontract BundleBidContract is AnyBidContract {\n\n\tfunction newBid(uint64 decryptionCondition, address[] memory bidAllowedPeekers, address[] memory bidAllowedStores) external payable returns (bytes memory) {\n\t\trequire(Suave.isConfidential());\n\n\t\tbytes memory bundleData = this.fetchBidConfidentialBundleData();\n\n\t\tuint64 egp = Suave.simulateBundle(bundleData);\n\n\t\tSuave.Bid memory bid = Suave.newBid(decryptionCondition, bidAllowedPeekers, bidAllowedStores, \"default:v0:ethBundles\");\n\n\t\tSuave.confidentialStore(bid.id, \"default:v0:ethBundles\", bundleData);\n\t\tSuave.confidentialStore(bid.id, \"default:v0:ethBundleSimResults\", abi.encode(egp));\n\n\t\treturn emitAndReturn(bid, bundleData);\n\t}\n\n\tfunction emitAndReturn(Suave.Bid memory bid, bytes memory) internal virtual returns (bytes memory) {\n\t\temit BidEvent(bid.id, bid.decryptionCondition, bid.allowedPeekers);\n\t\treturn bytes.concat(this.emitBid.selector, abi.encode(bid));\n\t}\n}\n\ncontract EthBundleSenderContract is BundleBidContract {\n\tstring[] public builderUrls;\n\n\tconstructor(string[] memory builderUrls_) {\n\t\tbuilderUrls = builderUrls_;\n\t}\n\n\tfunction emitAndReturn(Suave.Bid memory bid, bytes memory bundleData) internal virtual override returns (bytes memory) {\n\t\tfor (uint i = 0; i < builderUrls.length; i++) {\n\t\t\tSuave.submitBundleJsonRPC(builderUrls[i], \"eth_sendBundle\", bundleData);\n\t\t}\n\n\t\treturn BundleBidContract.emitAndReturn(bid, bundleData);\n\t}\n}\n\ncontract MevShareBidContract is AnyBidContract {\n\n\tevent HintEvent(\n\t\tSuave.BidId bidId,\n\t\tbytes hint\n\t);\n\n\tevent MatchEvent(\n\t\tSuave.BidId matchBidId,\n\t\tbytes matchHint\n\t);\n\n\tfunction newBid(uint64 decryptionCondition, address[] memory bidAllowedPeekers, address[] memory bidAllowedStores) external payable returns (bytes memory) {\n\t\t// 0. check confidential execution\n\t\trequire(Suave.isConfidential());\n\n\t\t// 1. fetch bundle data\n\t\tbytes memory bundleData = this.fetchBidConfidentialBundleData();\n\n\t\t// 2. sim bundle\n\t\tuint64 egp = Suave.simulateBundle(bundleData);\n\t\t\n\t\t// 3. extract hint\n\t\tbytes memory hint = Suave.extractHint(bundleData);\n\t\t\n\t\t// // 4. store bundle and sim results\n\t\tSuave.Bid memory bid = Suave.newBid(decryptionCondition, bidAllowedPeekers, bidAllowedStores, \"mevshare:v0:unmatchedBundles\");\n\t\tSuave.confidentialStore(bid.id, \"mevshare:v0:ethBundles\", bundleData);\n\t\tSuave.confidentialStore(bid.id, \"mevshare:v0:ethBundleSimResults\", abi.encode(egp));\n\t\temit BidEvent(bid.id, bid.decryptionCondition, bid.allowedPeekers);\n\t\temit HintEvent(bid.id, hint);\n\n\t\t// // 5. return \"callback\" to emit hint onchain\n\t\treturn bytes.concat(this.emitBidAndHint.selector, abi.encode(bid, hint));\n\t}\n\n\tfunction emitBidAndHint(Suave.Bid calldata bid, bytes memory hint) public {\n\t\temit BidEvent(bid.id, bid.decryptionCondition, bid.allowedPeekers);\n\t\temit HintEvent(bid.id, hint);\n\t}\n\n\tfunction newMatch(uint64 decryptionCondition, address[] memory bidAllowedPeekers, address[] memory bidAllowedStores, Suave.BidId shareBidId) external payable returns (bytes memory) {\n\t\t// WARNING : this function will copy the original mev share bid\n\t\t// into a new key with potentially different permsissions\n\t\t\n\t\trequire(Suave.isConfidential());\n\t\t// 1. fetch confidential data\n\t\tbytes memory matchBundleData = this.fetchBidConfidentialBundleData();\n\n\t\t// 2. sim match alone for validity\n\t\tuint64 egp = Suave.simulateBundle(matchBundleData);\n\n\t\t// 3. extract hint\n\t\tbytes memory matchHint = Suave.extractHint(matchBundleData);\n\t\t\n\t\tSuave.Bid memory bid = Suave.newBid(decryptionCondition, bidAllowedPeekers, bidAllowedStores, \"mevshare:v0:matchBids\");\n\t\tSuave.confidentialStore(bid.id, \"mevshare:v0:ethBundles\", matchBundleData);\n\t\tSuave.confidentialStore(bid.id, \"mevshare:v0:ethBundleSimResults\", abi.encode(0));\n\n\t\t//4. merge bids\n\t\tSuave.BidId[] memory bids = new Suave.BidId[](2);\n\t\tbids[0] = shareBidId;\n\t\tbids[1] = bid.id;\n\t\tSuave.confidentialStore(bid.id, \"mevshare:v0:mergedBids\", abi.encode(bids));\n\n\t\treturn emitMatchBidAndHint(bid, matchHint);\n\t}\n\n\tfunction emitMatchBidAndHint(Suave.Bid memory bid, bytes memory matchHint) internal virtual returns (bytes memory) {\n\t\temit BidEvent(bid.id, bid.decryptionCondition, bid.allowedPeekers);\n\t\temit MatchEvent(bid.id, matchHint);\n\n\t\treturn bytes.concat(this.emitBid.selector, abi.encode(bid));\n\t}\n}\n\ncontract MevShareBundleSenderContract is MevShareBidContract {\n\tstring[] public builderUrls;\n\n\tconstructor(string[] memory builderUrls_) {\n\t\tbuilderUrls = builderUrls_;\n\t}\n\n\tfunction emitMatchBidAndHint(Suave.Bid memory bid, bytes memory matchHint) internal virtual override returns (bytes memory) {\n\t\tbytes memory bundleData = Suave.fillMevShareBundle(bid.id);\n\t\tfor (uint i = 0; i < builderUrls.length; i++) {\n\t\t\tSuave.submitBundleJsonRPC(builderUrls[i], \"mev_sendBundle\", bundleData);\n\t\t}\n\n\t\treturn MevShareBidContract.emitMatchBidAndHint(bid, matchHint);\n\t}\n}\n\n/* Not tested or implemented on the precompile side */\nstruct EgpBidPair {\n\tuint64 egp; // in wei, beware overflow\n\tSuave.BidId bidId;\n}\n\n// todo: instead of inherit interact with deployed builder contract\ncontract EthBlockBidContract is AnyBidContract {\n\n\tevent BuilderBoostBidEvent(\n\t\tSuave.BidId bidId,\n\t\tbytes builderBid\n\t);\n\t\n\tfunction idsEqual(Suave.BidId _l, Suave.BidId _r) public pure returns (bool) {\n\t\tbytes memory l = abi.encodePacked(_l);\n\t\tbytes memory r = abi.encodePacked(_r);\n\t\tfor (uint i = 0; i < l.length; i++) {\n\t\t\tif (bytes(l)[i] != r[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tfunction buildMevShare(Suave.BuildBlockArgs memory blockArgs, uint64 blockHeight) public virtual returns (bytes memory) {\n\t\trequire(Suave.isConfidential());\n\t\tSuave.Bid[] memory allShareMatchBids = Suave.fetchBids(blockHeight, \"mevshare:v0:matchBids\");\n\t\tSuave.Bid[] memory allShareUserBids = Suave.fetchBids(blockHeight, \"mevshare:v0:unmatchedBundles\");\n\n\t\tif (allShareUserBids.length == 0) {\n\t\t\trevert Suave.PeekerReverted(address(this), \"no bids\");\n\t\t}\n\n\t\tSuave.Bid[] memory allBids = new Suave.Bid[](allShareUserBids.length);\n\t\tfor (uint i = 0; i < allShareUserBids.length; i++) {\n\t\t\t// TODO: sort matches by egp first!\n\t\t\tSuave.Bid memory bidToInsert = allShareUserBids[i]; // will be updated with the best match if any\n\t\t\tfor (uint j = 0; j < allShareMatchBids.length; j++) {\n\t\t\t\t// TODO: should be done once at the start and sorted\n\t\t\t\tSuave.BidId[] memory mergedBidIds = abi.decode(Suave.confidentialRetrieve(allShareMatchBids[j].id, \"mevshare:v0:mergedBids\"), (Suave.BidId[]));\n\t\t\t\tif (idsEqual(mergedBidIds[0], allShareUserBids[i].id)) {\n\t\t\t\t\tbidToInsert = allShareMatchBids[j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tallBids[i] = bidToInsert;\n\t\t}\n\n\t\tEgpBidPair[] memory bidsByEGP = new EgpBidPair[](allBids.length);\n\t\tfor (uint i = 0; i < allBids.length; i++) {\n\t\t\tbytes memory simResults = Suave.confidentialRetrieve(allBids[i].id, \"mevshare:v0:ethBundleSimResults\");\n\t\t\tuint64 egp = abi.decode(simResults, (uint64));\n\t\t\tbidsByEGP[i] = EgpBidPair(egp, allBids[i].id);\n\t\t}\n\n\t\t// Bubble sort, cause why not\n\t\tuint n = bidsByEGP.length;\n\t\tfor (uint i = 0; i < n - 1; i++) {\n\t\t\tfor (uint j = i + 1; j < n; j++) {\n\t\t\t\tif (bidsByEGP[i].egp < bidsByEGP[j].egp) {\n\t\t\t\t\tEgpBidPair memory temp = bidsByEGP[i];\n\t\t\t\t\tbidsByEGP[i] = bidsByEGP[j];\n\t\t\t\t\tbidsByEGP[j] = temp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSuave.BidId[] memory allBidIds = new Suave.BidId[](allBids.length);\n\t\tfor (uint i = 0; i < bidsByEGP.length; i++) {\n\t\t\tallBidIds[i] = bidsByEGP[i].bidId;\n\t\t}\n\n\t\treturn buildAndEmit(blockArgs, blockHeight, allBidIds, \"mevshare:v0\");\n\t}\n\n\tfunction buildFromPool(Suave.BuildBlockArgs memory blockArgs, uint64 blockHeight) public returns (bytes memory) {\n\t\trequire(Suave.isConfidential());\n\n\t\tSuave.Bid[] memory allBids = Suave.fetchBids(blockHeight, \"default:v0:ethBundles\");\n\t\tif (allBids.length == 0) {\n\t\t\trevert Suave.PeekerReverted(address(this), \"no bids\");\n\t\t}\n\n\t\tEgpBidPair[] memory bidsByEGP = new EgpBidPair[](allBids.length);\n\t\tfor (uint i = 0; i < allBids.length; i++) {\n\t\t\tbytes memory simResults = Suave.confidentialRetrieve(allBids[i].id, \"default:v0:ethBundleSimResults\");\n\t\t\tuint64 egp = abi.decode(simResults, (uint64));\n\t\t\tbidsByEGP[i] = EgpBidPair(egp, allBids[i].id);\n\t\t}\n\n\t\t// Bubble sort, cause why not\n\t\tuint n = bidsByEGP.length;\n\t\tfor (uint i = 0; i < n - 1; i++) {\n\t\t\tfor (uint j = i + 1; j < n; j++) {\n\t\t\t\tif (bidsByEGP[i].egp < bidsByEGP[j].egp) {\n\t\t\t\t\tEgpBidPair memory temp = bidsByEGP[i];\n\t\t\t\t\tbidsByEGP[i] = bidsByEGP[j];\n\t\t\t\t\tbidsByEGP[j] = temp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSuave.BidId[] memory allBidIds = new Suave.BidId[](allBids.length);\n\t\tfor (uint i = 0; i < bidsByEGP.length; i++) {\n\t\t\tallBidIds[i] = bidsByEGP[i].bidId;\n\t\t}\n\n\t\treturn buildAndEmit(blockArgs, blockHeight, allBidIds, \"\");\n\t}\n\n\tfunction buildAndEmit(Suave.BuildBlockArgs memory blockArgs, uint64 blockHeight, Suave.BidId[] memory bids, string memory namespace) public virtual returns (bytes memory) {\n\t\trequire(Suave.isConfidential());\n\n\t\t(Suave.Bid memory blockBid, bytes memory builderBid) = this.doBuild(blockArgs, blockHeight, bids, namespace);\n\n\t\temit BuilderBoostBidEvent(blockBid.id, builderBid);\n\t\temit BidEvent(blockBid.id, blockBid.decryptionCondition, blockBid.allowedPeekers);\n\t\treturn bytes.concat(this.emitBuilderBidAndBid.selector, abi.encode(blockBid, builderBid));\n\t}\n\n\tfunction doBuild(Suave.BuildBlockArgs memory blockArgs, uint64 blockHeight, Suave.BidId[] memory bids, string memory namespace) public view returns (Suave.Bid memory, bytes memory) {\n\t\taddress[] memory allowedPeekers = new address[](2);\n\t\tallowedPeekers[0] = address(this);\n\t\tallowedPeekers[1] = Suave.BUILD_ETH_BLOCK;\n\n\t\tSuave.Bid memory blockBid = Suave.newBid(blockHeight, allowedPeekers, allowedPeekers, \"default:v0:mergedBids\");\n\t\tSuave.confidentialStore(blockBid.id, \"default:v0:mergedBids\", abi.encode(bids));\n\t\t \n\t\t(bytes memory builderBid, bytes memory payload) = Suave.buildEthBlock(blockArgs, blockBid.id, namespace);\n\t\tSuave.confidentialStore(blockBid.id, \"default:v0:builderPayload\", payload); // only through this.unlock\n\n\t\treturn (blockBid, builderBid);\n\t}\n\n\tfunction emitBuilderBidAndBid(Suave.Bid memory bid, bytes memory builderBid) public returns (Suave.Bid memory, bytes memory) {\n\t\temit BuilderBoostBidEvent(bid.id, builderBid);\n\t\temit BidEvent(bid.id, bid.decryptionCondition, bid.allowedPeekers);\n\t\treturn (bid, builderBid);\n\t}\n\n\tfunction unlock(Suave.BidId bidId, bytes memory signedBlindedHeader) public view returns (bytes memory) {\n\t\trequire(Suave.isConfidential());\n\n\t\t// TODO: verify the header is correct\n\t\t// TODO: incorporate protocol name\n\t\tbytes memory payload = Suave.confidentialRetrieve(bidId, \"default:v0:builderPayload\");\n\t\treturn payload;\n\t}\n}\n\ncontract EthBlockBidSenderContract is EthBlockBidContract {\n\tstring boostRelayUrl;\n\n\tevent RelaySubmissionEvent(\n\t\tbytes blockHash\n\t);\n\n\tconstructor(string memory boostRelayUrl_) {\n\t\tboostRelayUrl = boostRelayUrl_;\n\t}\n\n\tfunction buildAndEmitCallback(bytes memory blockHash) external {\n\t\temit RelaySubmissionEvent(blockHash);\n\t}\n\n\tfunction buildAndEmit(Suave.BuildBlockArgs memory blockArgs, uint64 blockHeight, Suave.BidId[] memory bids, string memory namespace) public virtual override returns (bytes memory) {\n\t\trequire(Suave.isConfidential());\n\n\t\t(, bytes memory builderBid) = this.doBuild(blockArgs, blockHeight, bids, namespace);\n\t\tSuave.submitEthBlockBidToRelay(boostRelayUrl, builderBid);\n\n\t\tbytes memory blockHash = extractBlockHash(builderBid, blockArgs.slot);\n\t\treturn abi.encodeWithSelector(this.buildAndEmitCallback.selector, blockHash);\n\t}\n\n\tfunction extractBlockHash(bytes memory builderBid, uint slot) public pure returns (bytes memory) {\n\t\tuint resultBytesLen = 64;\n\t\tuint offset = 121 + decLen(slot);\n        bytes memory result = new bytes(resultBytesLen);\n\t\tassembly { \n\t\t\tfor { let i:=32 } lt(i, add(resultBytesLen, 32)) { i:=add(i, 32) } {\n\t\t\t\tmstore(add(result, i), mload(add(builderBid, add(offset, i))))\n            }\n\t\t}\n\t\treturn result;\n\t}\n\n\tfunction decLen(uint num) internal pure returns (uint count) {\n        assembly {\n            for { let dec := 10 } true { dec := mul(dec, 10) } {\n                count := add(count, 1)\n                switch lt(num, dec)\n                    case 1 { break }\n            }\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}