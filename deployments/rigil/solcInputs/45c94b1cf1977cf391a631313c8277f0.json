{
  "language": "Solidity",
  "sources": {
    "contracts/blockad/BlockAdV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { AnyBundleContract, EthBlockBidSenderContract, Suave } from \"../standard_peekers/bids.sol\";\n\n\ncontract BlockAdAuctionV1 is AnyBundleContract {\n\n\tstruct AdBid {\n\t\tstring extra; \n\t\tSuave.DataId paymentBidId;\n\t\tuint blockHeight;\n\t}\n\n\tstruct EffectiveAdBid {\n\t\tstring extra;\n\t\tuint64 egp;\n\t\tbytes paymentBundle;\n\t}\n\n\tevent AdBidEvent(\n\t\tstring extra,\n\t\tuint blockNum\n\t);\n\n\tmapping(uint => AdBid[]) public blockToBid;\n\tEthBlockBidSenderContract public builder;\n\n\tconstructor(string memory boostRelayUrl_) {\n\t\t// Make sure the builder contract cannot abuse the confidential payment bundle\n\t\tbuilder = new EthBlockBidSenderContract(boostRelayUrl_);\n\t}\n\n\t// ON-CHAIN METHODS\n\n\tfunction buyAdCallback(AdBid[] memory bids) external {\n\t\tfor (uint i = 0; i < bids.length; ++i) {\n\t\t\tuint blockNum = bids[i].blockHeight;\n\t\t\tblockToBid[blockNum].push(bids[i]);\n\t\t\t// todo: add some form of an id to the bid\n\t\t\temit AdBidEvent(bids[i].extra, blockNum);\n\t\t}\n\t}\n\n\t// CONFIDENTIAL METHODS\n\n\tfunction buyAd(\n\t\tuint64 blockStart, \n\t\tuint64 range, \n\t\tstring memory extra\n\t) external returns (bytes memory) {\n\t\trequire(Suave.isConfidential(), \"Not confidential\");\n\t\t// Check payment is valid for the latest state\n\t\tbytes memory paymentBundle = this.fetchConfidentialBundleData();\n\t\trequire(Suave.simulateBundle(paymentBundle) != 0, \"Initial sim check failed\");\n\t\t\n\t\taddress[] memory allowedPeekers = new address[](1);\n\t\tallowedPeekers[0] = address(this);\n\n\t\tAdBid[] memory bids = new AdBid[](range);\n\t\tfor (uint64 b = blockStart; b < blockStart+range; b++) {\n\t\t\t// Store payment bundle\n\t\t\tSuave.DataRecord memory paymentBid = Suave.newDataRecord(0, allowedPeekers, allowedPeekers, \"blockad:v0:paymentBundle\");\n\t\t\tSuave.confidentialStore(paymentBid.id, \"blockad:v0:paymentBundle\", paymentBundle);\n\t\t\t// Prepare bid data to be commited on-chain\n\t\t\tbids[b-blockStart] = AdBid(extra, paymentBid.id, b);\n\t\t}\n\t\treturn abi.encodeWithSelector(this.buyAdCallback.selector, bids);\n\t}\n\n\tfunction buildBlock(Suave.BuildBlockArgs memory blockArgs, uint64 blockHeight) public returns (bytes memory) {\n\t\trequire(Suave.isConfidential());\n\n\t\tAdBid[] storage blockBids = blockToBid[blockHeight];\n\t\trequire(blockBids.length > 0, \"No bids\");\n\n\t\tEffectiveAdBid memory bestOffer;\n\t\tfor (uint i = 0; i < blockBids.length; ++i) {\n\t\t\tbytes memory paymentBundle = Suave.confidentialRetrieve(\n\t\t\t\tblockBids[i].paymentBidId, \n\t\t\t\t\"blockad:v0:paymentBundle\"\n\t\t\t);\n\t\t\tuint64 egp = Suave.simulateBundle(paymentBundle);\n\t\t\tif (egp > bestOffer.egp)\n\t\t\t\tbestOffer = EffectiveAdBid(blockBids[i].extra, egp, paymentBundle);\n\t\t\t// todo: if egp == 0, delete all of their bids for the next blocks (when someone wins an ad, discard their subsequent(pending) bids)\n\t\t}\n\t\tdelete blockToBid[blockHeight];\n\n\t\t// Prep for block building - include extra & payment bundle\n\t\tif (bestOffer.egp > 0)\n\t\t\tblockArgs.extra = bytes(bestOffer.extra);\n\t\t// Expect the payment on top; if someone wants to fail the payment with other txs they have to have higher egp than the payment tx\n\t\taddress[] memory allowedPeekers = new address[](3);\n\t\tallowedPeekers[0] = address(builder);\n\t\tallowedPeekers[1] = Suave.BUILD_ETH_BLOCK;\n\t\tallowedPeekers[2] = address(this);\n\t\tSuave.DataRecord memory paymentBundleBid = Suave.newDataRecord(blockHeight, allowedPeekers, allowedPeekers, \"default:v0:ethBundles\");\n\t\tSuave.confidentialStore(paymentBundleBid.id, \"default:v0:ethBundles\", bestOffer.paymentBundle);\n\t\tSuave.confidentialStore(paymentBundleBid.id, \"default:v0:ethBundleSimResults\", abi.encode(bestOffer.egp));\n\t\t\n\t\treturn builder.buildFromPool(blockArgs, blockHeight);\n\t}\n\n}\n"
    },
    "contracts/blockad/BlockAdV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Author: Miha Lotric (halo3mic)\n\npragma solidity ^0.8.8;\n\nimport { AnyBundleContract, Suave } from \"../standard_peekers/bids.sol\";\nimport { ConfidentialControl } from \"./lib/ConfidentialControl.sol\";\nimport { DynamicUintArray } from \"./lib/Utils.sol\";\nimport { Builder } from \"./lib/Builder.sol\";\n\n\ncontract BlockAdAuctionV2 is AnyBundleContract, ConfidentialControl {\n\tusing DynamicUintArray for bytes;\n\n\tstruct AdRequest {\n\t\tuint id;\n\t\tstring extra;\n\t\tuint blockLimit;\n\t\tSuave.DataId paymentBidId;\n\t}\n\tstruct Offer {\n\t\tuint id;\n\t\tstring extra;\n\t\tuint64 egp;\n\t\tbytes paymentBundle;\n\t}\n\n\tevent RequestAdded(uint indexed id, string extra, uint blockLimit);\n\tevent RequestRemoved(uint indexed id);\n\tevent RequestIncluded(uint indexed id, uint64 egp, string blockHash);\n\n\tstring internal constant PB_NAMESPACE = \"blockad:v0:paymentBundle\";\n\tstring internal constant EB_NAMESPACE = \"default:v0:ethBundles\";\n\tstring internal constant EB_SIM_NAMESPACE = \"default:v0:ethBundleSimResults\";\n\tBuilder public builder;\n\tAdRequest[] public requests;\n\tuint public nextId;\n\n\t/**********************************************************************\n\t *                           ‚õìÔ∏è ON-CHAIN METHODS                       *\n\t ***********************************************************************/\n\n\tconstructor(string memory boostRelayUrl_) {\n\t\tbuilder = new Builder(boostRelayUrl_);\n\t}\n\n\tfunction buyAdCallback(AdRequest calldata request, UnlockArgs calldata uArgs) external unlock(uArgs) {\n\t\trequests.push(request);\n\t\tnextId++;\n\t\temit RequestAdded(request.id, request.extra, request.blockLimit);\n\t}\n\n\tfunction buildCallback(\n\t\tbytes memory builderCall,\n\t\tbytes memory includedRequestB,\n\t\tbytes memory pendingRemovalsB,\n\t\tUnlockArgs calldata uArgs\n\t) external unlock(uArgs) {\n\t\tif (pendingRemovalsB.length > 0) {\n\t\t\tremoveRequests(pendingRemovalsB.export());\n\t\t}\n\t\tstring memory blockHash = handleBuilderCallback(address(builder), builderCall);\n\t\thandleIncludedRequest(includedRequestB, blockHash);\n\t}\n\n\tfunction requestsLength() public view returns (uint) {\n\t\treturn requests.length;\n\t}\n\n\t/**********************************************************************\n\t *                         üîí CONFIDENTIAL METHODS                      *\n\t ***********************************************************************/\n\n\tfunction confidentialConstructor() public view override onlyConfidential returns (bytes memory) {\n\t\treturn ConfidentialControl.confidentialConstructor();\n\t}\n\n\tfunction buyAd(uint64 blockLimit, string memory extra) external onlyConfidential returns (bytes memory) {\n\t\tbytes memory paymentBundle = this.fetchConfidentialBundleData();\n\t\t(,uint64 egp) = simulateBundleSafe(paymentBundle, true);\n\t\tcrequire(egp > 0, \"egp too low\");\n\t\tSuave.DataId paymentBidId = storePaymentBundle(paymentBundle);\n\t\tAdRequest memory request = AdRequest(nextId, extra, blockLimit, paymentBidId);\n\t\treturn abi.encodeWithSelector(this.buyAdCallback.selector, request, getUnlockPair());\n\t}\n\n\tfunction buildBlock(\n\t\tSuave.BuildBlockArgs memory blockArgs,\n\t\tuint64 blockHeight\n\t) public onlyConfidential returns (bytes memory) {\n\t\tcrequire(requests.length > 0, \"No requests\");\n\t\t(Offer memory bestOffer, bytes memory removals) = filterOffers(blockHeight);\n\t\tcrequire(bestOffer.egp > 0, \"No valid offers\");\n\n\t\tstoreBundleInPool(blockHeight, bestOffer);\n\t\tblockArgs.extra = bytes(bestOffer.extra);\n\t\t// Expect flow is ordered by egp; if one wants to fail payment they need higher egp\n\t\tbytes memory externalCallback = builder.buildFromPool(blockArgs, blockHeight);\n\n\t\treturn\n\t\t\tabi.encodeWithSelector(\n\t\t\t\tthis.buildCallback.selector,\n\t\t\t\texternalCallback,\n\t\t\t\tabi.encode(bestOffer.id, bestOffer.egp),\n\t\t\t\tremovals,\n\t\t\t\tgetUnlockPair()\n\t\t\t);\n\t}\n\n\t/**********************************************************************\n\t *                         üõ†Ô∏è INTERNAL METHODS                          *\n\t ***********************************************************************/\n\n\tfunction removeRequests(uint[] memory pendingRemovals) internal {\n\t\t// Assume that the pendingRemovals were added in ascending order\n\t\t// Assume that pendingRemovals.length <= requests.length\n\t\tfor (uint i = pendingRemovals.length; i > 0; --i) {\n\t\t\tuint indexToRemove = pendingRemovals[i - 1];\n\t\t\tuint requestId = requests[indexToRemove].id;\n\t\t\tif (indexToRemove < requests.length - 1) {\n\t\t\t\trequests[indexToRemove] = requests[requests.length - 1];\n\t\t\t}\n\t\t\trequests.pop();\n\t\t\temit RequestRemoved(requestId);\n\t\t}\n\t}\n\n\tfunction handleIncludedRequest(bytes memory includedRequestB, string memory blockHash) internal {\n\t\t(uint id, uint64 egp) = abi.decode(includedRequestB, (uint, uint64));\n\t\temit RequestIncluded(id, egp, blockHash);\n\t}\n\n\tfunction handleBuilderCallback(address target, bytes memory data) internal returns (string memory) {\n\t\t(bool success, bytes memory res) = target.call(data);\n\t\tcrequire(success, \"External call failed\");\n\t\treturn abi.decode(res, (string));\n\t}\n\n\tfunction storePaymentBundle(bytes memory paymentBundle) internal view returns (Suave.DataId) {\n\t\taddress[] memory peekers = new address[](1);\n\t\tpeekers[0] = address(this);\n\t\tSuave.DataRecord memory paymentBid = Suave.newDataRecord(0, peekers, peekers, PB_NAMESPACE);\n\t\tSuave.confidentialStore(paymentBid.id, PB_NAMESPACE, paymentBundle);\n\t\treturn paymentBid.id;\n\t}\n\n\tfunction filterOffers(uint blockHeight) internal view returns (Offer memory bestOffer, bytes memory removals) {\n\t\tfor (uint i; i < requests.length; ++i) {\n\t\t\tAdRequest memory request = requests[i];\n\t\t\tif (request.blockLimit < blockHeight) {\n\t\t\t\tremovals = removals.append(i);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbytes memory paymentBundle = Suave.confidentialRetrieve(request.paymentBidId, PB_NAMESPACE);\n\t\t\t(bool success, uint64 egp) = simulateBundleSafe(paymentBundle, false);\n\t\t\tif (!success || egp == 0) {\n\t\t\t\tremovals = removals.append(i);\n\t\t\t} else if (egp > bestOffer.egp) {\n\t\t\t\tbestOffer = Offer(request.id, request.extra, egp, paymentBundle);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction storeBundleInPool(uint64 blockHeight, Offer memory bestOffer) internal view {\n\t\taddress[] memory allowedPeekers = new address[](3);\n\t\tallowedPeekers[0] = address(builder);\n\t\tallowedPeekers[1] = Suave.BUILD_ETH_BLOCK;\n\t\tallowedPeekers[2] = address(this);\n\t\tSuave.DataRecord memory paymentBundleBid = Suave.newDataRecord(\n\t\t\tblockHeight, \n\t\t\tallowedPeekers, \n\t\t\tallowedPeekers, \n\t\t\tEB_NAMESPACE\n\t\t);\n\t\tSuave.confidentialStore(paymentBundleBid.id, EB_NAMESPACE, bestOffer.paymentBundle);\n\t\tSuave.confidentialStore(paymentBundleBid.id, EB_SIM_NAMESPACE, abi.encode(bestOffer.egp));\n\t}\n}\n"
    },
    "contracts/blockad/lib/Builder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Author: Miha Lotric (halo3mic)\n\npragma solidity ^0.8.8;\n\nimport { EthBlockContract, Suave } from \"../../standard_peekers/bids.sol\";\nimport { SuaveContract } from \"./SuaveContract.sol\";\n\n\ncontract Builder is EthBlockContract, SuaveContract {\n\tstring constant BB_NAMESPACE = \"blockad:v0:builderBid\";\n\tstring boostRelayUrl;\n\n\tevent RelaySubmission(bytes32 bidId);\n\n\tconstructor(string memory boostRelayUrl_) {\n\t\tboostRelayUrl = boostRelayUrl_;\n\t}\n\n\tfunction buildAndEmitCallback(string memory blockHash, bytes32 id) external returns (string memory) {\n\t\temit RelaySubmission(id);\n\t\treturn blockHash;\n\t}\n\n\tfunction buildAndEmit(\n\t\tSuave.BuildBlockArgs memory blockArgs,\n\t\tuint64 blockHeight,\n\t\tSuave.DataId[] memory bids,\n\t\tstring memory namespace\n\t) public virtual override onlyConfidential returns (bytes memory) {\n\t\t(Suave.DataRecord memory blockBid, bytes memory builderBid) = this.doBuild(blockArgs, blockHeight, bids, namespace);\n\t\tstoreBuilderBid(blockBid.id, builderBid);\n\t\tsubmitToRelay(builderBid);\n\t\tstring memory blockHash = extractBlockHash(builderBid, blockArgs.slot);\n\t\treturn abi.encodeWithSelector(this.buildAndEmitCallback.selector, blockHash, keccak256(builderBid));\n\t}\n\n\tfunction submitBlock(uint slot) external view onlyConfidential returns (bytes memory) {\n\t\tbytes memory builderBid = Suave.confidentialInputs();\n\t\tsubmitToRelay(builderBid);\n\t\tstring memory blockHash = extractBlockHash(builderBid, slot);\n\t\treturn abi.encodeWithSelector(this.buildAndEmitCallback.selector, blockHash, keccak256(builderBid));\n\t}\n\n\tfunction submitToRelay(bytes memory builderBid) internal view {\n\t\t(bool success, bytes memory data) = Suave.SUBMIT_ETH_BLOCK_TO_RELAY\n\t\t\t.staticcall(abi.encode(boostRelayUrl, builderBid));\n\t\tif (!success) {\n\t\t\trevert SuaveErrorWithData(string(data), builderBid);\n\t\t}\n\t}\n\n\tfunction storeBuilderBid(Suave.DataId blockBidId, bytes memory builderBid) internal view {\n\t\taddress[] memory peekers = new address[](1);\n\t\tpeekers[0] = address(this);\n\t\tSuave.confidentialStore(blockBidId, BB_NAMESPACE, builderBid);\n\t}\n\n\t// Extract block-hash from stringified SubmitBlockRequest JSON object - method will fail if the struct changes!\n\tfunction extractBlockHash(bytes memory builderBid, uint slot) public pure returns (string memory) {\n\t\tuint resultBytesLen = 64;\n\t\tuint offset = 121 + decLen(slot);\n\t\tbytes memory result = new bytes(resultBytesLen);\n\t\tassembly {\n\t\t\tfor { let i:=32 } lt(i, add(resultBytesLen, 32)) { i:=add(i, 32) } {\n\t\t\t\tmstore(add(result, i), mload(add(builderBid, add(offset, i))))\n\t\t\t}\n\t\t}\n\t\treturn string(result);\n\t}\n\n\tfunction decLen(uint num) internal pure returns (uint count) {\n\t\tassembly {\n\t\t\tfor { let dec := 10 } true { dec := mul(dec, 10) } {\n\t\t\t\tcount := add(count, 1)\n\t\t\t\tswitch lt(num, dec)\n\t\t\t\t\tcase 1 { break }\n\t\t\t}\n\t\t}\n\t}\n}"
    },
    "contracts/blockad/lib/ConfidentialControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Author: Miha Lotric (halo3mic)\n\npragma solidity ^0.8.8;\n\nimport { SuaveContract, Suave } from \"./SuaveContract.sol\";\n\n\nabstract contract ConfidentialControl is SuaveContract {\n\tstruct UnlockArgs {\n\t\tbytes32 key;\n\t\tbytes32 nextHash;\n\t}\n\n\tmodifier unlock(UnlockArgs calldata unlockPair) {\n\t\tcrequire(isValidKey(unlockPair.key), \"Invalid key\");\n\t\t_;\n\t\tpresentHash = unlockPair.nextHash;\n\t\tnonce++;\n\t}\n\n\tstring internal constant S_NAMESPACE = \"blockad:v0:secret\";\n\tSuave.DataId internal secretBidId;\n\tbytes32 internal presentHash;\n\tuint internal nonce;\n\n\t/**********************************************************************\n\t *                           ‚õìÔ∏è ON-CHAIN METHODS                       *\n\t ***********************************************************************/\n\n\tfunction ccCallback(bytes32 nextHash, Suave.DataId sBidId) external {\n\t\tcrequire(!isInitialized(), \"Already initialized\");\n\t\tpresentHash = nextHash;\n\t\tsecretBidId = sBidId;\n\t}\n\n\tfunction isInitialized() public view returns (bool) {\n\t\treturn presentHash != 0;\n\t}\n\n\t/**********************************************************************\n\t *                         üîí CONFIDENTIAL METHODS                      *\n\t ***********************************************************************/\n\n\tfunction confidentialConstructor() public view virtual onlyConfidential returns (bytes memory) {\n\t\tcrequire(!isInitialized(), \"Already initialized\");\n\t\tbytes memory secret = Suave.confidentialInputs();\n\t\tSuave.DataId sBidId = storeSecret(secret);\n\t\tbytes32 nextHash = makeHash(abi.decode(secret, (bytes32)), nonce);\n\t\treturn abi.encodeWithSelector(this.ccCallback.selector, nextHash, sBidId);\n\t}\n\n\t/**********************************************************************\n\t *                         üõ†Ô∏è INTERNAL METHODS                          *\n\t ***********************************************************************/\n\n\tfunction storeSecret(bytes memory secret) internal view returns (Suave.DataId) {\n\t\taddress[] memory peekers = new address[](3);\n\t\tpeekers[0] = address(this);\n\t\tpeekers[1] = Suave.FETCH_DATA_RECORDS;\n\t\tpeekers[2] = Suave.CONFIDENTIAL_RETRIEVE;\n\t\tSuave.DataRecord memory secretBid = Suave.newDataRecord(0, peekers, peekers, S_NAMESPACE);\n\t\tSuave.confidentialStore(secretBid.id, S_NAMESPACE, secret);\n\t\treturn secretBid.id;\n\t}\n\n\tfunction isValidKey(bytes32 key) internal view returns (bool) {\n\t\treturn keccak256(abi.encode(key)) == presentHash;\n\t}\n\n\tfunction getUnlockPair() internal view returns (UnlockArgs memory) {\n\t\treturn UnlockArgs(getKey(nonce), getHash(nonce + 1));\n\t}\n\n\tfunction getHash(uint _nonce) internal view returns (bytes32) {\n\t\treturn keccak256(abi.encode(getKey(_nonce)));\n\t}\n\n\tfunction getKey(uint _nonce) internal view returns (bytes32) {\n\t\treturn makeKey(getSecret(), _nonce);\n\t}\n\n\tfunction makeHash(bytes32 secret, uint _nonce) internal pure returns (bytes32) {\n\t\treturn keccak256(abi.encode(makeKey(secret, _nonce)));\n\t}\n\n\tfunction makeKey(bytes32 secret, uint _nonce) internal pure returns (bytes32) {\n\t\treturn keccak256(abi.encode(secret, _nonce));\n\t}\n\n\tfunction getSecret() internal view returns (bytes32) {\n\t\tbytes memory secretB = Suave.confidentialRetrieve(secretBidId, S_NAMESPACE);\n\t\treturn abi.decode(secretB, (bytes32));\n\t}\n}\n"
    },
    "contracts/blockad/lib/SuaveContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Author: Miha Lotric (halo3mic)\n\npragma solidity ^0.8.8;\n\nimport { Suave } from \"../../standard_peekers/bids.sol\";\n\n\nabstract contract SuaveContract {\n\terror SuaveError(string message);\n\terror SuaveErrorWithData(string message, bytes data);\n\n\tmodifier onlyConfidential() {\n\t\tcrequire(Suave.isConfidential(), \"Not confidential\");\n\t\t_;\n\t}\n\n\tfunction simulateBundleSafe(bytes memory bundle, bool doRevert) internal view returns (bool valid, uint64 egp) {\n\t\t(bool success, bytes memory d) = Suave.SIMULATE_BUNDLE.staticcall{ gas: 20_000 }(abi.encode(bundle));\n\t\tcrequire(!doRevert || success, string(d));\n\t\tif (success) {\n\t\t\treturn (true, abi.decode(d, (uint64)));\n\t\t}\n\t}\n\n\tfunction crequire(bool condition, string memory message) internal pure {\n\t\tif (!condition) {\n\t\t\trevert SuaveError(message);\n\t\t}\n\t}\n}\n"
    },
    "contracts/blockad/lib/Utils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.8;\n\n\nlibrary DynamicUintArray {\n\tfunction append(bytes memory a, uint e) internal pure returns (bytes memory) {\n\t\treturn bytes.concat(a, TypeConversion.toBytes(e));\n\t}\n\n\tfunction export(bytes memory a) internal pure returns (uint[] memory) {\n\t\treturn TypeConversion.toUints(a);\n\t}\n}\n\nlibrary TypeConversion {\n\tfunction toBytes(uint x) internal pure returns (bytes memory y) {\n\t\ty = new bytes(32);\n\t\tassembly {\n\t\t\tmstore(add(y, 32), x)\n\t\t}\n\t}\n\n\tfunction toUint(bytes memory x, uint offset) internal pure returns (uint y) {\n\t\tassembly {\n\t\t\ty := mload(add(x, offset))\n\t\t}\n\t}\n\n\tfunction toUints(bytes memory xs) internal pure returns (uint[] memory ys) {\n\t\tys = new uint[](xs.length / 32);\n\t\tfor (uint i = 0; i < xs.length / 32; i++) {\n\t\t\tys[i] = toUint(xs, i * 32 + 32);\n\t\t}\n\t}\n}\n"
    },
    "contracts/libraries/RLPWriter.sol": {
      "content": "// Source: https://github.com/flashbots/suave-std/blob/main/src/utils/RLPWriter.sol\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @custom:attribution https://github.com/bakaoh/solidity-rlp-encode\n * @title RLPWriter\n * @author RLPWriter is a library for encoding Solidity types to RLP bytes. Adapted from Bakaoh's\n *         RLPEncode library (https://github.com/bakaoh/solidity-rlp-encode) with minor\n *         modifications to improve legibility.\n */\nlibrary RLPWriter {\n    /**\n     * @notice RLP encodes a byte string.\n     *\n     * @param _in The byte string to encode.\n     *\n     * @return The RLP encoded string in bytes.\n     */\n    function writeBytes(bytes memory _in) internal pure returns (bytes memory) {\n        bytes memory encoded;\n\n        if (_in.length == 1 && uint8(_in[0]) < 128) {\n            encoded = _in;\n        } else {\n            encoded = abi.encodePacked(_writeLength(_in.length, 128), _in);\n        }\n\n        return encoded;\n    }\n\n    /**\n     * @notice RLP encodes a list of RLP encoded byte byte strings.\n     *\n     * @param _in The list of RLP encoded byte strings.\n     *\n     * @return The RLP encoded list of items in bytes.\n     */\n    function writeList(bytes[] memory _in) internal pure returns (bytes memory) {\n        bytes memory list = _flatten(_in);\n        return abi.encodePacked(_writeLength(list.length, 192), list);\n    }\n\n    /**\n     * @notice RLP encodes a string.\n     *\n     * @param _in The string to encode.\n     *\n     * @return The RLP encoded string in bytes.\n     */\n    function writeString(string memory _in) internal pure returns (bytes memory) {\n        return writeBytes(bytes(_in));\n    }\n\n    /**\n     * @notice RLP encodes an address.\n     *\n     * @param _in The address to encode.\n     *\n     * @return The RLP encoded address in bytes.\n     */\n    function writeAddress(address _in) internal pure returns (bytes memory) {\n        return writeBytes(abi.encodePacked(_in));\n    }\n\n    /**\n     * @notice RLP encodes a uint.\n     *\n     * @param _in The uint256 to encode.\n     *\n     * @return The RLP encoded uint256 in bytes.\n     */\n    function writeUint(uint256 _in) internal pure returns (bytes memory) {\n        return writeBytes(_toBinary(_in));\n    }\n\n    /**\n     * @notice RLP encodes a bool.\n     *\n     * @param _in The bool to encode.\n     *\n     * @return The RLP encoded bool in bytes.\n     */\n    function writeBool(bool _in) internal pure returns (bytes memory) {\n        bytes memory encoded = new bytes(1);\n        encoded[0] = (_in ? bytes1(0x01) : bytes1(0x80));\n        return encoded;\n    }\n\n    /**\n     * @notice Encode the first byte and then the `len` in binary form if `length` is more than 55.\n     *\n     * @param _len    The length of the string or the payload.\n     * @param _offset 128 if item is string, 192 if item is list.\n     *\n     * @return RLP encoded bytes.\n     */\n    function _writeLength(uint256 _len, uint256 _offset) private pure returns (bytes memory) {\n        bytes memory encoded;\n\n        if (_len < 56) {\n            encoded = new bytes(1);\n            encoded[0] = bytes1(uint8(_len) + uint8(_offset));\n        } else {\n            uint256 lenLen;\n            uint256 i = 1;\n            while (_len / i != 0) {\n                lenLen++;\n                i *= 256;\n            }\n\n            encoded = new bytes(lenLen + 1);\n            encoded[0] = bytes1(uint8(lenLen) + uint8(_offset) + 55);\n            for (i = 1; i <= lenLen; i++) {\n                encoded[i] = bytes1(uint8((_len / (256 ** (lenLen - i))) % 256));\n            }\n        }\n\n        return encoded;\n    }\n\n    /**\n     * @notice Encode integer in big endian binary form with no leading zeroes.\n     *\n     * @param _x The integer to encode.\n     *\n     * @return RLP encoded bytes.\n     */\n    function _toBinary(uint256 _x) private pure returns (bytes memory) {\n        bytes memory b = abi.encodePacked(_x);\n\n        uint256 i = 0;\n        for (; i < 32; i++) {\n            if (b[i] != 0) {\n                break;\n            }\n        }\n\n        bytes memory res = new bytes(32 - i);\n        for (uint256 j = 0; j < res.length; j++) {\n            res[j] = b[i++];\n        }\n\n        return res;\n    }\n\n    /**\n     * @custom:attribution https://github.com/Arachnid/solidity-stringutils\n     * @notice Copies a piece of memory to another location.\n     *\n     * @param _dest Destination location.\n     * @param _src  Source location.\n     * @param _len  Length of memory to copy.\n     */\n    function _memcpy(uint256 _dest, uint256 _src, uint256 _len) private pure {\n        uint256 dest = _dest;\n        uint256 src = _src;\n        uint256 len = _len;\n\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        uint256 mask;\n        unchecked {\n            mask = 256 ** (32 - len) - 1;\n        }\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n\n    /**\n     * @custom:attribution https://github.com/sammayo/solidity-rlp-encoder\n     * @notice Flattens a list of byte strings into one byte string.\n     *\n     * @param _list List of byte strings to flatten.\n     *\n     * @return The flattened byte string.\n     */\n    function _flatten(bytes[] memory _list) private pure returns (bytes memory) {\n        if (_list.length == 0) {\n            return new bytes(0);\n        }\n\n        uint256 len;\n        uint256 i = 0;\n        for (; i < _list.length; i++) {\n            len += _list[i].length;\n        }\n\n        bytes memory flattened = new bytes(len);\n        uint256 flattenedPtr;\n        assembly {\n            flattenedPtr := add(flattened, 0x20)\n        }\n\n        for (i = 0; i < _list.length; i++) {\n            bytes memory item = _list[i];\n\n            uint256 listPtr;\n            assembly {\n                listPtr := add(item, 0x20)\n            }\n\n            _memcpy(flattenedPtr, listPtr, item.length);\n            flattenedPtr += _list[i].length;\n        }\n\n        return flattened;\n    }\n}"
    },
    "contracts/libraries/Suave.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.8;\n\nlibrary Suave {\n    error PeekerReverted(address, bytes);\n\n    type DataId is bytes16;\n\n    struct BuildBlockArgs {\n        uint64 slot;\n        bytes proposerPubkey;\n        bytes32 parent;\n        uint64 timestamp;\n        address feeRecipient;\n        uint64 gasLimit;\n        bytes32 random;\n        Withdrawal[] withdrawals;\n        bytes extra;\n        bool fillPending;\n    }\n\n    struct DataRecord {\n        DataId id;\n        DataId salt;\n        uint64 decryptionCondition;\n        address[] allowedPeekers;\n        address[] allowedStores;\n        string version;\n    }\n\n    struct HttpRequest {\n        string url;\n        string method;\n        string[] headers;\n        bytes body;\n        bool withFlashbotsSignature;\n    }\n\n    struct SimulateTransactionResult {\n        uint64 egp;\n        SimulatedLog[] logs;\n        bool success;\n        string error;\n    }\n\n    struct SimulatedLog {\n        bytes data;\n        address addr;\n        bytes32[] topics;\n    }\n\n    struct Withdrawal {\n        uint64 index;\n        uint64 validator;\n        address Address;\n        uint64 amount;\n    }\n\n    address public constant ANYALLOWED = 0xC8df3686b4Afb2BB53e60EAe97EF043FE03Fb829;\n\n    address public constant IS_CONFIDENTIAL_ADDR = 0x0000000000000000000000000000000042010000;\n\n    address public constant BUILD_ETH_BLOCK = 0x0000000000000000000000000000000042100001;\n\n    address public constant CONFIDENTIAL_INPUTS = 0x0000000000000000000000000000000042010001;\n\n    address public constant CONFIDENTIAL_RETRIEVE = 0x0000000000000000000000000000000042020001;\n\n    address public constant CONFIDENTIAL_STORE = 0x0000000000000000000000000000000042020000;\n\n    address public constant DO_HTTPREQUEST = 0x0000000000000000000000000000000043200002;\n\n    address public constant ETHCALL = 0x0000000000000000000000000000000042100003;\n\n    address public constant EXTRACT_HINT = 0x0000000000000000000000000000000042100037;\n\n    address public constant FETCH_DATA_RECORDS = 0x0000000000000000000000000000000042030001;\n\n    address public constant FILL_MEV_SHARE_BUNDLE = 0x0000000000000000000000000000000043200001;\n\n    address public constant NEW_BUILDER = 0x0000000000000000000000000000000053200001;\n\n    address public constant NEW_DATA_RECORD = 0x0000000000000000000000000000000042030000;\n\n    address public constant SIGN_ETH_TRANSACTION = 0x0000000000000000000000000000000040100001;\n\n    address public constant SIGN_MESSAGE = 0x0000000000000000000000000000000040100003;\n\n    address public constant SIMULATE_BUNDLE = 0x0000000000000000000000000000000042100000;\n\n    address public constant SIMULATE_TRANSACTION = 0x0000000000000000000000000000000053200002;\n\n    address public constant SUBMIT_BUNDLE_JSON_RPC = 0x0000000000000000000000000000000043000001;\n\n    address public constant SUBMIT_ETH_BLOCK_TO_RELAY = 0x0000000000000000000000000000000042100002;\n\n    // Returns whether execution is off- or on-chain\n    function isConfidential() internal view returns (bool b) {\n        (bool success, bytes memory isConfidentialBytes) = IS_CONFIDENTIAL_ADDR.staticcall(\"\");\n        if (!success) {\n            revert PeekerReverted(IS_CONFIDENTIAL_ADDR, isConfidentialBytes);\n        }\n        assembly {\n            // Load the length of data (first 32 bytes)\n            let len := mload(isConfidentialBytes)\n            // Load the data after 32 bytes, so add 0x20\n            b := mload(add(isConfidentialBytes, 0x20))\n        }\n    }\n\n    function buildEthBlock(BuildBlockArgs memory blockArgs, DataId dataId, string memory namespace)\n        internal\n        view\n        returns (bytes memory, bytes memory)\n    {\n        (bool success, bytes memory data) = BUILD_ETH_BLOCK.staticcall(abi.encode(blockArgs, dataId, namespace));\n        if (!success) {\n            revert PeekerReverted(BUILD_ETH_BLOCK, data);\n        }\n\n        return abi.decode(data, (bytes, bytes));\n    }\n\n    function confidentialInputs() internal view returns (bytes memory) {\n        (bool success, bytes memory data) = CONFIDENTIAL_INPUTS.staticcall(abi.encode());\n        if (!success) {\n            revert PeekerReverted(CONFIDENTIAL_INPUTS, data);\n        }\n\n        return data;\n    }\n\n    function confidentialRetrieve(DataId dataId, string memory key) internal view returns (bytes memory) {\n        (bool success, bytes memory data) = CONFIDENTIAL_RETRIEVE.staticcall(abi.encode(dataId, key));\n        if (!success) {\n            revert PeekerReverted(CONFIDENTIAL_RETRIEVE, data);\n        }\n\n        return data;\n    }\n\n    function confidentialStore(DataId dataId, string memory key, bytes memory value) internal view {\n        (bool success, bytes memory data) = CONFIDENTIAL_STORE.staticcall(abi.encode(dataId, key, value));\n        if (!success) {\n            revert PeekerReverted(CONFIDENTIAL_STORE, data);\n        }\n    }\n\n    function doHTTPRequest(HttpRequest memory request) internal view returns (bytes memory) {\n        (bool success, bytes memory data) = DO_HTTPREQUEST.staticcall(abi.encode(request));\n        if (!success) {\n            revert PeekerReverted(DO_HTTPREQUEST, data);\n        }\n\n        return abi.decode(data, (bytes));\n    }\n\n    function ethcall(address contractAddr, bytes memory input1) internal view returns (bytes memory) {\n        (bool success, bytes memory data) = ETHCALL.staticcall(abi.encode(contractAddr, input1));\n        if (!success) {\n            revert PeekerReverted(ETHCALL, data);\n        }\n\n        return abi.decode(data, (bytes));\n    }\n\n    function extractHint(bytes memory bundleData) internal view returns (bytes memory) {\n        require(isConfidential());\n        (bool success, bytes memory data) = EXTRACT_HINT.staticcall(abi.encode(bundleData));\n        if (!success) {\n            revert PeekerReverted(EXTRACT_HINT, data);\n        }\n\n        return data;\n    }\n\n    function fetchDataRecords(uint64 cond, string memory namespace) internal view returns (DataRecord[] memory) {\n        (bool success, bytes memory data) = FETCH_DATA_RECORDS.staticcall(abi.encode(cond, namespace));\n        if (!success) {\n            revert PeekerReverted(FETCH_DATA_RECORDS, data);\n        }\n\n        return abi.decode(data, (DataRecord[]));\n    }\n\n    function fillMevShareBundle(DataId dataId) internal view returns (bytes memory) {\n        require(isConfidential());\n        (bool success, bytes memory data) = FILL_MEV_SHARE_BUNDLE.staticcall(abi.encode(dataId));\n        if (!success) {\n            revert PeekerReverted(FILL_MEV_SHARE_BUNDLE, data);\n        }\n\n        return data;\n    }\n\n    function newBuilder() internal view returns (string memory) {\n        (bool success, bytes memory data) = NEW_BUILDER.staticcall(abi.encode());\n        if (!success) {\n            revert PeekerReverted(NEW_BUILDER, data);\n        }\n\n        return abi.decode(data, (string));\n    }\n\n    function newDataRecord(\n        uint64 decryptionCondition,\n        address[] memory allowedPeekers,\n        address[] memory allowedStores,\n        string memory dataType\n    ) internal view returns (DataRecord memory) {\n        (bool success, bytes memory data) =\n            NEW_DATA_RECORD.staticcall(abi.encode(decryptionCondition, allowedPeekers, allowedStores, dataType));\n        if (!success) {\n            revert PeekerReverted(NEW_DATA_RECORD, data);\n        }\n\n        return abi.decode(data, (DataRecord));\n    }\n\n    function signEthTransaction(bytes memory txn, string memory chainId, string memory signingKey)\n        internal\n        view\n        returns (bytes memory)\n    {\n        (bool success, bytes memory data) = SIGN_ETH_TRANSACTION.staticcall(abi.encode(txn, chainId, signingKey));\n        if (!success) {\n            revert PeekerReverted(SIGN_ETH_TRANSACTION, data);\n        }\n\n        return abi.decode(data, (bytes));\n    }\n\n    function signMessage(bytes memory digest, string memory signingKey) internal view returns (bytes memory) {\n        require(isConfidential());\n        (bool success, bytes memory data) = SIGN_MESSAGE.staticcall(abi.encode(digest, signingKey));\n        if (!success) {\n            revert PeekerReverted(SIGN_MESSAGE, data);\n        }\n\n        return abi.decode(data, (bytes));\n    }\n\n    function simulateBundle(bytes memory bundleData) internal view returns (uint64) {\n        (bool success, bytes memory data) = SIMULATE_BUNDLE.staticcall(abi.encode(bundleData));\n        if (!success) {\n            revert PeekerReverted(SIMULATE_BUNDLE, data);\n        }\n\n        return abi.decode(data, (uint64));\n    }\n\n    function simulateTransaction(string memory sessionid, bytes memory txn)\n        internal\n        view\n        returns (SimulateTransactionResult memory)\n    {\n        (bool success, bytes memory data) = SIMULATE_TRANSACTION.staticcall(abi.encode(sessionid, txn));\n        if (!success) {\n            revert PeekerReverted(SIMULATE_TRANSACTION, data);\n        }\n\n        return abi.decode(data, (SimulateTransactionResult));\n    }\n\n    function submitBundleJsonRPC(string memory url, string memory method, bytes memory params)\n        internal\n        view\n        returns (bytes memory)\n    {\n        require(isConfidential());\n        (bool success, bytes memory data) = SUBMIT_BUNDLE_JSON_RPC.staticcall(abi.encode(url, method, params));\n        if (!success) {\n            revert PeekerReverted(SUBMIT_BUNDLE_JSON_RPC, data);\n        }\n\n        return data;\n    }\n\n    function submitEthBlockToRelay(string memory relayUrl, bytes memory builderBid)\n        internal\n        view\n        returns (bytes memory)\n    {\n        require(isConfidential());\n        (bool success, bytes memory data) = SUBMIT_ETH_BLOCK_TO_RELAY.staticcall(abi.encode(relayUrl, builderBid));\n        if (!success) {\n            revert PeekerReverted(SUBMIT_ETH_BLOCK_TO_RELAY, data);\n        }\n\n        return data;\n    }\n}\n"
    },
    "contracts/libraries/Transactions.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.13;\n\nimport \"./RLPWriter.sol\";\nimport \"./Suave.sol\";\nimport \"solidity-rlp/contracts/RLPReader.sol\";\n\nlibrary Transactions {\n    using RLPReader for RLPReader.RLPItem;\n    using RLPReader for RLPReader.Iterator;\n    using RLPReader for bytes;\n\n    struct EIP155 {\n        address to;\n        uint256 gas;\n        uint256 gasPrice;\n        uint256 value;\n        uint256 nonce;\n        bytes data;\n        uint256 chainId;\n        bytes32 r;\n        bytes32 s;\n        uint64 v;\n    }\n\n    struct EIP155Request {\n        address to;\n        uint256 gas;\n        uint256 gasPrice;\n        uint256 value;\n        uint256 nonce;\n        bytes data;\n        uint256 chainId;\n    }\n\n    struct EIP1559 {\n        address to;\n        uint64 gas;\n        uint64 maxFeePerGas;\n        uint64 maxPriorityFeePerGas;\n        uint64 value;\n        uint64 nonce;\n        bytes data;\n        uint64 chainId;\n        bytes accessList;\n        bytes32 r;\n        bytes32 s;\n        uint64 v;\n    }\n\n    struct EIP1559Request {\n        address to;\n        uint64 gas;\n        uint64 maxFeePerGas;\n        uint64 maxPriorityFeePerGas;\n        uint64 value;\n        uint64 nonce;\n        bytes data;\n        uint64 chainId;\n        bytes accessList;\n    }\n\n    function encodeRLP(EIP155 memory txStruct) internal pure returns (bytes memory) {\n        bytes[] memory items = new bytes[](9);\n\n        items[0] = RLPWriter.writeUint(txStruct.nonce);\n        items[1] = RLPWriter.writeUint(txStruct.gasPrice);\n        items[2] = RLPWriter.writeUint(txStruct.gas);\n\n        if (txStruct.to == address(0)) {\n            items[3] = RLPWriter.writeBytes(bytes(\"\"));\n        } else {\n            items[3] = RLPWriter.writeAddress(txStruct.to);\n        }\n        items[4] = RLPWriter.writeUint(txStruct.value);\n        items[5] = RLPWriter.writeBytes(txStruct.data);\n        items[6] = RLPWriter.writeUint(uint256(txStruct.v));\n        items[7] = RLPWriter.writeBytes(abi.encodePacked(txStruct.r));\n        items[8] = RLPWriter.writeBytes(abi.encodePacked(txStruct.s));\n\n        return RLPWriter.writeList(items);\n    }\n\n    function encodeRLP(EIP155Request memory txStruct) internal pure returns (bytes memory) {\n        bytes[] memory items = new bytes[](9);\n\n        items[0] = RLPWriter.writeUint(txStruct.nonce);\n        items[1] = RLPWriter.writeUint(txStruct.gasPrice);\n        items[2] = RLPWriter.writeUint(txStruct.gas);\n\n        if (txStruct.to == address(0)) {\n            items[3] = RLPWriter.writeBytes(bytes(\"\"));\n        } else {\n            items[3] = RLPWriter.writeAddress(txStruct.to);\n        }\n        items[4] = RLPWriter.writeUint(txStruct.value);\n        items[5] = RLPWriter.writeBytes(txStruct.data);\n        items[6] = RLPWriter.writeUint(txStruct.chainId);\n        items[7] = RLPWriter.writeBytes(\"\");\n        items[8] = RLPWriter.writeBytes(\"\");\n\n        return RLPWriter.writeList(items);\n    }\n\n    function encodeRLP(EIP1559 memory txStruct) internal pure returns (bytes memory) {\n        bytes[] memory items = new bytes[](12);\n\n        items[0] = RLPWriter.writeUint(txStruct.chainId);\n        items[1] = RLPWriter.writeUint(txStruct.nonce);\n        items[2] = RLPWriter.writeUint(txStruct.maxPriorityFeePerGas);\n        items[3] = RLPWriter.writeUint(txStruct.maxFeePerGas);\n        items[4] = RLPWriter.writeUint(txStruct.gas);\n\n        if (txStruct.to == address(0)) {\n            items[5] = RLPWriter.writeBytes(bytes(\"\"));\n        } else {\n            items[5] = RLPWriter.writeAddress(txStruct.to);\n        }\n\n        items[6] = RLPWriter.writeUint(txStruct.value);\n        items[7] = RLPWriter.writeBytes(txStruct.data);\n\n        if (txStruct.accessList.length == 0) {\n            items[8] = hex\"c0\"; // Empty list encoding\n        } else {\n            items[8] = RLPWriter.writeBytes(txStruct.accessList);\n        }\n\n        items[9] = RLPWriter.writeUint(uint256(txStruct.v));\n        items[10] = RLPWriter.writeBytes(abi.encodePacked(txStruct.r));\n        items[11] = RLPWriter.writeBytes(abi.encodePacked(txStruct.s));\n\n        bytes memory rlpTxn = RLPWriter.writeList(items);\n\n        bytes memory txn = new bytes(1 + rlpTxn.length);\n        txn[0] = 0x02;\n\n        for (uint256 i = 0; i < rlpTxn.length; ++i) {\n            txn[i + 1] = rlpTxn[i];\n        }\n\n        return txn;\n    }\n\n    function encodeRLP(EIP1559Request memory txStruct) internal pure returns (bytes memory) {\n        bytes[] memory items = new bytes[](9);\n\n        items[0] = RLPWriter.writeUint(txStruct.chainId);\n        items[1] = RLPWriter.writeUint(txStruct.nonce);\n        items[2] = RLPWriter.writeUint(txStruct.maxPriorityFeePerGas);\n        items[3] = RLPWriter.writeUint(txStruct.maxFeePerGas);\n        items[4] = RLPWriter.writeUint(txStruct.gas);\n\n        if (txStruct.to == address(0)) {\n            items[5] = RLPWriter.writeBytes(bytes(\"\"));\n        } else {\n            items[5] = RLPWriter.writeAddress(txStruct.to);\n        }\n\n        items[6] = RLPWriter.writeUint(txStruct.value);\n        items[7] = RLPWriter.writeBytes(txStruct.data);\n\n        if (txStruct.accessList.length == 0) {\n            items[8] = hex\"c0\"; // Empty list encoding\n        } else {\n            items[8] = RLPWriter.writeBytes(txStruct.accessList);\n        }\n\n        bytes memory rlpTxn = RLPWriter.writeList(items);\n\n        bytes memory txn = new bytes(1 + rlpTxn.length);\n        txn[0] = 0x02;\n\n        for (uint256 i = 0; i < rlpTxn.length; ++i) {\n            txn[i + 1] = rlpTxn[i];\n        }\n\n        return txn;\n    }\n\n    function decodeRLP_EIP155(bytes memory rlp) internal pure returns (EIP155 memory) {\n        EIP155 memory txStruct;\n\n        RLPReader.RLPItem[] memory ls = rlp.toRlpItem().toList();\n        require(ls.length == 9, \"invalid transaction\");\n\n        txStruct.nonce = uint64(ls[0].toUint());\n        txStruct.gasPrice = uint64(ls[1].toUint());\n        txStruct.gas = uint64(ls[2].toUint());\n\n        if (ls[3].toRlpBytes().length == 1) {\n            txStruct.to = address(0);\n        } else {\n            txStruct.to = ls[3].toAddress();\n        }\n\n        txStruct.value = uint64(ls[4].toUint());\n        txStruct.data = ls[5].toBytes();\n        txStruct.v = uint64(ls[6].toUint());\n        txStruct.r = bytesToBytes32(ls[7].toBytes());\n        txStruct.s = bytesToBytes32(ls[8].toBytes());\n\n        return txStruct;\n    }\n\n    function decodeRLP_EIP155Request(bytes memory rlp) internal pure returns (EIP155Request memory) {\n        EIP155Request memory txStruct;\n\n        RLPReader.RLPItem[] memory ls = rlp.toRlpItem().toList();\n        require(ls.length == 9, \"invalid transaction\");\n\n        txStruct.nonce = ls[0].toUint();\n        txStruct.gasPrice = ls[1].toUint();\n        txStruct.gas = ls[2].toUint();\n\n        if (ls[3].toRlpBytes().length == 1) {\n            txStruct.to = address(0);\n        } else {\n            txStruct.to = ls[3].toAddress();\n        }\n\n        txStruct.value = ls[4].toUint();\n        txStruct.data = ls[5].toBytes();\n        txStruct.chainId = uint64(ls[6].toUint());\n\n        return txStruct;\n    }\n\n    function decodeRLP_EIP1559(bytes memory rlp) internal pure returns (EIP1559 memory) {\n        EIP1559 memory txStruct;\n\n        bytes memory rlpWithoutPrefix = new bytes(rlp.length - 1);\n\n        for (uint256 i = 0; i < rlp.length - 1; ++i) {\n            rlpWithoutPrefix[i] = rlp[i + 1];\n        }\n\n        RLPReader.RLPItem[] memory ls = rlpWithoutPrefix.toRlpItem().toList();\n        require(ls.length == 12, \"invalid transaction\");\n\n        txStruct.chainId = uint64(ls[0].toUint());\n        txStruct.nonce = uint64(ls[1].toUint());\n        txStruct.maxPriorityFeePerGas = uint64(ls[2].toUint());\n        txStruct.maxFeePerGas = uint64(ls[3].toUint());\n        txStruct.gas = uint64(ls[4].toUint());\n\n        if (ls[5].toRlpBytes().length == 1) {\n            txStruct.to = address(0);\n        } else {\n            txStruct.to = ls[5].toAddress();\n        }\n\n        txStruct.value = uint64(ls[6].toUint());\n        txStruct.data = ls[7].toBytes();\n        txStruct.accessList = ls[8].toBytes();\n        txStruct.v = uint64(ls[9].toUint());\n        txStruct.r = bytesToBytes32(ls[10].toBytes());\n        txStruct.s = bytesToBytes32(ls[11].toBytes());\n\n        return txStruct;\n    }\n\n    function decodeRLP_EIP1559Request(bytes memory rlp) internal pure returns (EIP1559Request memory) {\n        EIP1559Request memory txStruct;\n\n        bytes memory rlpWithoutPrefix = new bytes(rlp.length - 1);\n\n        for (uint256 i = 0; i < rlp.length - 1; ++i) {\n            rlpWithoutPrefix[i] = rlp[i + 1];\n        }\n\n        RLPReader.RLPItem[] memory ls = rlpWithoutPrefix.toRlpItem().toList();\n        require(ls.length == 8, \"invalid transaction\");\n\n        txStruct.chainId = uint64(ls[0].toUint());\n        txStruct.nonce = uint64(ls[1].toUint());\n        txStruct.maxPriorityFeePerGas = uint64(ls[2].toUint());\n        txStruct.maxFeePerGas = uint64(ls[3].toUint());\n        txStruct.gas = uint64(ls[4].toUint());\n\n        if (ls[5].toRlpBytes().length == 1) {\n            txStruct.to = address(0);\n        } else {\n            txStruct.to = ls[5].toAddress();\n        }\n\n        txStruct.value = uint64(ls[6].toUint());\n        txStruct.data = ls[7].toBytes();\n\n        return txStruct;\n    }\n\n    function bytesToBytes32(bytes memory inBytes) internal pure returns (bytes32 out) {\n        require(inBytes.length == 32, \"bytesToBytes32: invalid input length\");\n        assembly {\n            out := mload(add(inBytes, 32))\n        }\n    }\n\n    function signTxn(Transactions.EIP1559Request memory request, string memory signingKey)\n        internal\n        view\n        returns (Transactions.EIP1559 memory response)\n    {\n        bytes memory rlp = Transactions.encodeRLP(request);\n        bytes memory hash = abi.encodePacked(keccak256(rlp));\n        bytes memory signature = Suave.signMessage(hash, signingKey);\n        (uint8 v, bytes32 r, bytes32 s) = decodeSignature(signature);\n\n        response.to = request.to;\n        response.gas = request.gas;\n        response.maxFeePerGas = request.maxFeePerGas;\n        response.maxPriorityFeePerGas = request.maxPriorityFeePerGas;\n        response.value = request.value;\n        response.nonce = request.nonce;\n        response.data = request.data;\n        response.chainId = request.chainId;\n        response.accessList = request.accessList;\n        response.v = v;\n        response.r = r;\n        response.s = s;\n\n        return response;\n    }\n\n    function signTxn(Transactions.EIP155Request memory request, string memory signingKey)\n        internal\n        view\n        returns (Transactions.EIP155 memory response)\n    {\n        bytes memory rlp = Transactions.encodeRLP(request);\n        bytes memory hash = abi.encodePacked(keccak256(rlp));\n        bytes memory signature = Suave.signMessage(hash, signingKey);\n\n        // TODO: check overflow\n        uint64 chainIdMul = uint64(request.chainId) * 2;\n        (uint8 v, bytes32 r, bytes32 s) = decodeSignature(signature);\n\n        uint64 v64 = uint64(v) + 35;\n        v64 += chainIdMul;\n\n        response.to = request.to;\n        response.gas = request.gas;\n        response.gasPrice = request.gasPrice;\n        response.value = request.value;\n        response.nonce = request.nonce;\n        response.data = request.data;\n        response.chainId = request.chainId;\n        response.v = v64;\n        response.r = r;\n        response.s = s;\n\n        return response;\n    }\n\n    function decodeSignature(bytes memory signature) public pure returns (uint8 v, bytes32 r, bytes32 s) {\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n    }\n}"
    },
    "contracts/oracle/BinanceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Author: Miha Lotric (halo3mic)\n\npragma solidity ^0.8.13;\n\nimport { AnyBundleContract, Suave } from \"../standard_peekers/bids.sol\";\nimport { SuaveContract } from \"../blockad/lib/SuaveContract.sol\";\nimport { floatToInt, trimStrEdges } from  \"./lib/Utils.sol\";\nimport \"../../node_modules/solady/src/utils/JSONParserLib.sol\";\nimport \"../libraries/Transactions.sol\";\n\ncontract BinanceOracle is SuaveContract {\n    using JSONParserLib for *;\n\n    uint public constant GOERLI_CHAINID = 5;\n    string public constant GOERLI_CHAINID_STR = \"5\";\n    uint8 public constant DECIMALS = 4;\n    string public constant URL_PARTIAL = \"https://data-api.binance.vision/api/v3/ticker/price?symbol=\";\n    mapping(uint => string) public idxToTicker;\n\n    event Log(string message);\n\n    function queryLatestPriceCallback(bytes memory response) public {\n        emit Log(string(response));\n    }\n\n    function queryLatestPrice(string memory ticker) external view returns (bytes memory) {\n        string[] memory headers = new string[](1);\n        headers[0] = \"Content-Type: application/json\";\n        Suave.HttpRequest memory request = Suave.HttpRequest({\n            url: string(abi.encodePacked(URL_PARTIAL, ticker)),\n            method: 'GET',\n            headers: headers,\n            body: new bytes(0),\n            withFlashbotsSignature: false\n        });\n        bytes memory response = doHttpRequest(request);\n        JSONParserLib.Item memory parsedRes = string(response).parse();\n        \n        string memory priceStr = string(parsedRes.at('\"price\"').value());\n        uint price = floatToInt(trimStrEdges(priceStr), DECIMALS);\n\n        return abi.encode(this.queryLatestPriceCallback.selector, abi.encode(price));\n    }\n\n    function doHttpRequest(Suave.HttpRequest memory request) internal view returns (bytes memory) {\n        (bool success, bytes memory data) = Suave.DO_HTTPREQUEST.staticcall(abi.encode(request));\n        crequire(success, string(data));\n        return abi.decode(data, (bytes));\n    }\n\n    /*\n        1. Create a transaction and sign it (try posting it on Goerli)\n        2. Find a way to do better nonce management \n        3. Send tx as a bundle\n        4. Create a way to store PK in a secure way\n        5. Create Goerli contract for collecting prices \n        6. Collect at least N(eg 10) price updates in the same block before updates can be posted on Goerli\n    */\n\n    function createTransaction(uint price, uint nonce) public returns (bytes memory)  {\n        Transactions.EIP155 memory transaction = Transactions.EIP155({\n            nonce: nonce,\n            gasPrice: 1 gwei,\n            gas: 0,\n            to: address(0),\n            value: 0,\n            data: abi.encode(price),\n            chainId: GOERLI_CHAINID,\n            v: 0, \n            r: bytes32(0),\n            s: bytes32(0)\n        });\n        bytes memory txRlp = Transactions.encodeRLP(transaction);\n        string memory pk = \"92ca64f6f50ca7ee8bc8f2649312d6184b51df28db6d21ebd8ef8889e23e2246\";\n        bytes memory txSigned = Suave.signEthTransaction(txRlp, GOERLI_CHAINID_STR, pk);\n\n        return txSigned;\n    }\n\n    fallback() external payable {\n    }\n\n}"
    },
    "contracts/oracle/lib/Utils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Author: Miha Lotric (halo3mic)\n\n// üö® THIS IS UNTESTED DEMO CODE - DONT USE IN PRODUCTION üö®\n\n\npragma solidity ^0.8.8;\n\n\nfunction floatToInt(string memory floatString, uint8 decimals) pure returns (uint) {\n    bytes memory stringBytes = bytes(floatString);\n    uint dotPosition;\n    \n    // Find the position of the dot\n    for (uint i = 0; i < stringBytes.length; i++) {\n        if (stringBytes[i] == 0x2E) {\n            dotPosition = i;\n            break;\n        }\n    }\n    \n    uint integerPart = 0;\n    uint decimalPart = 0;\n    uint tenPower = 1;\n    \n    // Convert integer part\n    for (uint i = dotPosition; i > 0; i--) {\n        integerPart += (uint8(stringBytes[i - 1]) - 48) * tenPower;\n        tenPower *= 10;\n    }\n    \n    // Reset power of ten\n    tenPower = 1;\n    \n    // Convert decimal part\n    for (uint i = dotPosition+decimals; i > dotPosition; i--) {\n        decimalPart += (uint8(stringBytes[i]) - 48) * tenPower;\n        tenPower *= 10;\n    }\n    \n    // Combine integer and decimal parts\n    return integerPart * (10**decimals) + decimalPart;\n}\n\nfunction trimStrEdges(string memory _input) pure returns (string memory) {\n    bytes memory input = bytes(_input);\n    require(input.length > 2, \"Input too short\");\n\n    uint newLength = input.length - 2;\n    bytes memory result = new bytes(newLength);\n\n    assembly {\n        let inputPtr := add(input, 0x21)\n        let resultPtr := add(result, 0x20)\n        let length := mload(input)\n        mstore(resultPtr, mload(inputPtr))\n        mstore(result, newLength)\n    }\n    return string(result);\n}"
    },
    "contracts/standard_peekers/bids.sol": {
      "content": "pragma solidity ^0.8.8;\n\nimport \"../libraries/Suave.sol\";\n\ncontract AnyBundleContract {\n    event DataRecordEvent(Suave.DataId dataId, uint64 decryptionCondition, address[] allowedPeekers);\n\n    function fetchConfidentialBundleData() public returns (bytes memory) {\n        require(Suave.isConfidential());\n\n        bytes memory confidentialInputs = Suave.confidentialInputs();\n        return abi.decode(confidentialInputs, (bytes));\n    }\n\n    function emitDataRecord(Suave.DataRecord calldata dataRecord) public {\n        emit DataRecordEvent(dataRecord.id, dataRecord.decryptionCondition, dataRecord.allowedPeekers);\n    }\n}\n\ncontract BundleContract is AnyBundleContract {\n    function newBundle(\n        uint64 decryptionCondition,\n        address[] memory dataAllowedPeekers,\n        address[] memory dataAllowedStores\n    ) external payable returns (bytes memory) {\n        require(Suave.isConfidential());\n\n        bytes memory bundleData = this.fetchConfidentialBundleData();\n\n        uint64 egp = Suave.simulateBundle(bundleData);\n\n        Suave.DataRecord memory dataRecord =\n            Suave.newDataRecord(decryptionCondition, dataAllowedPeekers, dataAllowedStores, \"default:v0:ethBundles\");\n\n        Suave.confidentialStore(dataRecord.id, \"default:v0:ethBundles\", bundleData);\n        Suave.confidentialStore(dataRecord.id, \"default:v0:ethBundleSimResults\", abi.encode(egp));\n\n        return emitAndReturn(dataRecord, bundleData);\n    }\n\n    function emitAndReturn(Suave.DataRecord memory dataRecord, bytes memory) internal virtual returns (bytes memory) {\n        emit DataRecordEvent(dataRecord.id, dataRecord.decryptionCondition, dataRecord.allowedPeekers);\n        return bytes.concat(this.emitDataRecord.selector, abi.encode(dataRecord));\n    }\n}\n\ncontract EthBundleSenderContract is BundleContract {\n    string[] public builderUrls;\n\n    constructor(string[] memory builderUrls_) {\n        builderUrls = builderUrls_;\n    }\n\n    function emitAndReturn(Suave.DataRecord memory dataRecord, bytes memory bundleData)\n        internal\n        virtual\n        override\n        returns (bytes memory)\n    {\n        for (uint256 i = 0; i < builderUrls.length; i++) {\n            Suave.submitBundleJsonRPC(builderUrls[i], \"eth_sendBundle\", bundleData);\n        }\n\n        return BundleContract.emitAndReturn(dataRecord, bundleData);\n    }\n}\n\ncontract MevShareContract is AnyBundleContract {\n    event HintEvent(Suave.DataId dataId, bytes hint);\n\n    event MatchEvent(Suave.DataId matchDataId, bytes matchHint);\n\n    function newTransaction(\n        uint64 decryptionCondition,\n        address[] memory dataAllowedPeekers,\n        address[] memory dataAllowedStores\n    ) external payable returns (bytes memory) {\n        // 0. check confidential execution\n        require(Suave.isConfidential());\n\n        // 1. fetch bundle data\n        bytes memory bundleData = this.fetchConfidentialBundleData();\n\n        // 2. sim bundle\n        uint64 egp = Suave.simulateBundle(bundleData);\n\n        // 3. extract hint\n        bytes memory hint = Suave.extractHint(bundleData);\n\n        // // 4. store bundle and sim results\n        Suave.DataRecord memory dataRecord = Suave.newDataRecord(\n            decryptionCondition, dataAllowedPeekers, dataAllowedStores, \"mevshare:v0:unmatchedBundles\"\n        );\n        Suave.confidentialStore(dataRecord.id, \"mevshare:v0:ethBundles\", bundleData);\n        Suave.confidentialStore(dataRecord.id, \"mevshare:v0:ethBundleSimResults\", abi.encode(egp));\n        emit DataRecordEvent(dataRecord.id, dataRecord.decryptionCondition, dataRecord.allowedPeekers);\n        emit HintEvent(dataRecord.id, hint);\n\n        // // 5. return \"callback\" to emit hint onchain\n        return bytes.concat(this.emitDataRecordAndHint.selector, abi.encode(dataRecord, hint));\n    }\n\n    function emitDataRecordAndHint(Suave.DataRecord calldata dataRecord, bytes memory hint) public {\n        emit DataRecordEvent(dataRecord.id, dataRecord.decryptionCondition, dataRecord.allowedPeekers);\n        emit HintEvent(dataRecord.id, hint);\n    }\n\n    function newMatch(\n        uint64 decryptionCondition,\n        address[] memory dataAllowedPeekers,\n        address[] memory dataAllowedStores,\n        Suave.DataId sharedataId\n    ) external payable returns (bytes memory) {\n        // WARNING : this function will copy the original mev share bid\n        // into a new key with potentially different permsissions\n\n        require(Suave.isConfidential());\n        // 1. fetch confidential data\n        bytes memory matchBundleData = this.fetchConfidentialBundleData();\n\n        // 2. sim match alone for validity\n        uint64 egp = Suave.simulateBundle(matchBundleData);\n\n        // 3. extract hint\n        bytes memory matchHint = Suave.extractHint(matchBundleData);\n\n        Suave.DataRecord memory dataRecord = Suave.newDataRecord(\n            decryptionCondition, dataAllowedPeekers, dataAllowedStores, \"mevshare:v0:matchDataRecords\"\n        );\n        Suave.confidentialStore(dataRecord.id, \"mevshare:v0:ethBundles\", matchBundleData);\n        Suave.confidentialStore(dataRecord.id, \"mevshare:v0:ethBundleSimResults\", abi.encode(0));\n\n        //4. merge data records\n        Suave.DataId[] memory dataRecords = new Suave.DataId[](2);\n        dataRecords[0] = sharedataId;\n        dataRecords[1] = dataRecord.id;\n        Suave.confidentialStore(dataRecord.id, \"mevshare:v0:mergedDataRecords\", abi.encode(dataRecords));\n\n        return emitMatchDataRecordAndHint(dataRecord, matchHint);\n    }\n\n    function emitMatchDataRecordAndHint(Suave.DataRecord memory dataRecord, bytes memory matchHint)\n        internal\n        virtual\n        returns (bytes memory)\n    {\n        emit DataRecordEvent(dataRecord.id, dataRecord.decryptionCondition, dataRecord.allowedPeekers);\n        emit MatchEvent(dataRecord.id, matchHint);\n\n        return bytes.concat(this.emitDataRecord.selector, abi.encode(dataRecord));\n    }\n}\n\ncontract MevShareBundleSenderContract is MevShareContract {\n    string[] public builderUrls;\n\n    constructor(string[] memory builderUrls_) {\n        builderUrls = builderUrls_;\n    }\n\n    function emitMatchDataRecordAndHint(Suave.DataRecord memory dataRecord, bytes memory matchHint)\n        internal\n        virtual\n        override\n        returns (bytes memory)\n    {\n        bytes memory bundleData = Suave.fillMevShareBundle(dataRecord.id);\n        for (uint256 i = 0; i < builderUrls.length; i++) {\n            Suave.submitBundleJsonRPC(builderUrls[i], \"mev_sendBundle\", bundleData);\n        }\n\n        return MevShareContract.emitMatchDataRecordAndHint(dataRecord, matchHint);\n    }\n}\n\n/* Not tested or implemented on the precompile side */\nstruct EgpRecordPair {\n    uint64 egp; // in wei, beware overflow\n    Suave.DataId dataId;\n}\n\ncontract EthBlockContract is AnyBundleContract {\n    event BuilderBoostBidEvent(Suave.DataId dataId, bytes builderBid);\n\n    function idsEqual(Suave.DataId _l, Suave.DataId _r) public pure returns (bool) {\n        bytes memory l = abi.encodePacked(_l);\n        bytes memory r = abi.encodePacked(_r);\n        for (uint256 i = 0; i < l.length; i++) {\n            if (bytes(l)[i] != r[i]) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    function buildMevShare(Suave.BuildBlockArgs memory blockArgs, uint64 blockHeight) public returns (bytes memory) {\n        require(Suave.isConfidential());\n\n        Suave.DataRecord[] memory allShareMatchDataRecords =\n            Suave.fetchDataRecords(blockHeight, \"mevshare:v0:matchDataRecords\");\n        Suave.DataRecord[] memory allShareUserDataRecords =\n            Suave.fetchDataRecords(blockHeight, \"mevshare:v0:unmatchedBundles\");\n\n        if (allShareUserDataRecords.length == 0) {\n            revert Suave.PeekerReverted(address(this), \"no data records\");\n        }\n\n        Suave.DataRecord[] memory allRecords = new Suave.DataRecord[](allShareUserDataRecords.length);\n        for (uint256 i = 0; i < allShareUserDataRecords.length; i++) {\n            // TODO: sort matches by egp first!\n            Suave.DataRecord memory dataRecordToInsert = allShareUserDataRecords[i]; // will be updated with the best match if any\n            for (uint256 j = 0; j < allShareMatchDataRecords.length; j++) {\n                // TODO: should be done once at the start and sorted\n                Suave.DataId[] memory mergeddataIds = abi.decode(\n                    Suave.confidentialRetrieve(allShareMatchDataRecords[j].id, \"mevshare:v0:mergedDataRecords\"),\n                    (Suave.DataId[])\n                );\n                if (idsEqual(mergeddataIds[0], allShareUserDataRecords[i].id)) {\n                    dataRecordToInsert = allShareMatchDataRecords[j];\n                    break;\n                }\n            }\n            allRecords[i] = dataRecordToInsert;\n        }\n\n        EgpRecordPair[] memory bidsByEGP = new EgpRecordPair[](allRecords.length);\n        for (uint256 i = 0; i < allRecords.length; i++) {\n            bytes memory simResults = Suave.confidentialRetrieve(allRecords[i].id, \"mevshare:v0:ethBundleSimResults\");\n            uint64 egp = abi.decode(simResults, (uint64));\n            bidsByEGP[i] = EgpRecordPair(egp, allRecords[i].id);\n        }\n\n        // Bubble sort, cause why not\n        uint256 n = bidsByEGP.length;\n        for (uint256 i = 0; i < n - 1; i++) {\n            for (uint256 j = i + 1; j < n; j++) {\n                if (bidsByEGP[i].egp < bidsByEGP[j].egp) {\n                    EgpRecordPair memory temp = bidsByEGP[i];\n                    bidsByEGP[i] = bidsByEGP[j];\n                    bidsByEGP[j] = temp;\n                }\n            }\n        }\n\n        Suave.DataId[] memory alldataIds = new Suave.DataId[](allRecords.length);\n        for (uint256 i = 0; i < bidsByEGP.length; i++) {\n            alldataIds[i] = bidsByEGP[i].dataId;\n        }\n\n        return buildAndEmit(blockArgs, blockHeight, alldataIds, \"mevshare:v0\");\n    }\n\n    function buildFromPool(Suave.BuildBlockArgs memory blockArgs, uint64 blockHeight) public returns (bytes memory) {\n        require(Suave.isConfidential());\n\n        Suave.DataRecord[] memory allRecords = Suave.fetchDataRecords(blockHeight, \"default:v0:ethBundles\");\n        if (allRecords.length == 0) {\n            revert Suave.PeekerReverted(address(this), \"no data records\");\n        }\n\n        EgpRecordPair[] memory bidsByEGP = new EgpRecordPair[](allRecords.length);\n        for (uint256 i = 0; i < allRecords.length; i++) {\n            bytes memory simResults = Suave.confidentialRetrieve(allRecords[i].id, \"default:v0:ethBundleSimResults\");\n            uint64 egp = abi.decode(simResults, (uint64));\n            bidsByEGP[i] = EgpRecordPair(egp, allRecords[i].id);\n        }\n\n        // Bubble sort, cause why not\n        uint256 n = bidsByEGP.length;\n        for (uint256 i = 0; i < n - 1; i++) {\n            for (uint256 j = i + 1; j < n; j++) {\n                if (bidsByEGP[i].egp < bidsByEGP[j].egp) {\n                    EgpRecordPair memory temp = bidsByEGP[i];\n                    bidsByEGP[i] = bidsByEGP[j];\n                    bidsByEGP[j] = temp;\n                }\n            }\n        }\n\n        Suave.DataId[] memory alldataIds = new Suave.DataId[](allRecords.length);\n        for (uint256 i = 0; i < bidsByEGP.length; i++) {\n            alldataIds[i] = bidsByEGP[i].dataId;\n        }\n\n        return buildAndEmit(blockArgs, blockHeight, alldataIds, \"\");\n    }\n\n    function buildAndEmit(\n        Suave.BuildBlockArgs memory blockArgs,\n        uint64 blockHeight,\n        Suave.DataId[] memory records,\n        string memory namespace\n    ) public virtual returns (bytes memory) {\n        require(Suave.isConfidential());\n\n        (Suave.DataRecord memory blockBid, bytes memory builderBid) =\n            this.doBuild(blockArgs, blockHeight, records, namespace);\n\n        emit BuilderBoostBidEvent(blockBid.id, builderBid);\n        emit DataRecordEvent(blockBid.id, blockBid.decryptionCondition, blockBid.allowedPeekers);\n        return bytes.concat(this.emitBuilderBidAndBid.selector, abi.encode(blockBid, builderBid));\n    }\n\n    function doBuild(\n        Suave.BuildBlockArgs memory blockArgs,\n        uint64 blockHeight,\n        Suave.DataId[] memory records,\n        string memory namespace\n    ) public view returns (Suave.DataRecord memory, bytes memory) {\n        address[] memory allowedPeekers = new address[](2);\n        allowedPeekers[0] = address(this);\n        allowedPeekers[1] = Suave.BUILD_ETH_BLOCK;\n\n        Suave.DataRecord memory blockBid =\n            Suave.newDataRecord(blockHeight, allowedPeekers, allowedPeekers, \"default:v0:mergedDataRecords\");\n        Suave.confidentialStore(blockBid.id, \"default:v0:mergedDataRecords\", abi.encode(records));\n\n        (bytes memory builderBid, bytes memory payload) = Suave.buildEthBlock(blockArgs, blockBid.id, namespace);\n        Suave.confidentialStore(blockBid.id, \"default:v0:builderPayload\", payload); // only through this.unlock\n\n        return (blockBid, builderBid);\n    }\n\n    function emitBuilderBidAndBid(Suave.DataRecord memory dataRecord, bytes memory builderBid)\n        public\n        returns (Suave.DataRecord memory, bytes memory)\n    {\n        emit BuilderBoostBidEvent(dataRecord.id, builderBid);\n        emit DataRecordEvent(dataRecord.id, dataRecord.decryptionCondition, dataRecord.allowedPeekers);\n        return (dataRecord, builderBid);\n    }\n\n    function unlock(Suave.DataId dataId, bytes memory signedBlindedHeader) public view returns (bytes memory) {\n        require(Suave.isConfidential());\n\n        // TODO: verify the header is correct\n        // TODO: incorporate protocol name\n        bytes memory payload = Suave.confidentialRetrieve(dataId, \"default:v0:builderPayload\");\n        return payload;\n    }\n}\n\ncontract EthBlockBidSenderContract is EthBlockContract {\n    string boostRelayUrl;\n\n    constructor(string memory boostRelayUrl_) {\n        boostRelayUrl = boostRelayUrl_;\n    }\n\n    function buildAndEmit(\n        Suave.BuildBlockArgs memory blockArgs,\n        uint64 blockHeight,\n        Suave.DataId[] memory dataRecords,\n        string memory namespace\n    ) public virtual override returns (bytes memory) {\n        require(Suave.isConfidential());\n\n        (Suave.DataRecord memory blockDataRecord, bytes memory builderBid) =\n            this.doBuild(blockArgs, blockHeight, dataRecords, namespace);\n        Suave.submitEthBlockToRelay(boostRelayUrl, builderBid);\n\n        emit DataRecordEvent(blockDataRecord.id, blockDataRecord.decryptionCondition, blockDataRecord.allowedPeekers);\n        return bytes.concat(this.emitDataRecord.selector, abi.encode(blockDataRecord));\n    }\n}\n"
    },
    "solady/src/utils/JSONParserLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for parsing JSONs.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/JSONParserLib.sol)\nlibrary JSONParserLib {\n    /*¬¥:¬∞‚Ä¢.¬∞+.*‚Ä¢¬¥.*:Àö.¬∞*.Àö‚Ä¢¬¥.¬∞:¬∞‚Ä¢.¬∞‚Ä¢.*‚Ä¢¬¥.*:Àö.¬∞*.Àö‚Ä¢¬¥.¬∞:¬∞‚Ä¢.¬∞+.*‚Ä¢¬¥.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.‚Ä¢¬∞:¬∞.¬¥+Àö.*¬∞.Àö:*.¬¥‚Ä¢*.+¬∞.‚Ä¢¬∞:¬¥*.¬¥‚Ä¢*.‚Ä¢¬∞.‚Ä¢¬∞:¬∞.¬¥:‚Ä¢Àö¬∞.*¬∞.Àö:*.¬¥+¬∞.‚Ä¢*/\n\n    /// @dev The input is invalid.\n    error ParsingFailed();\n\n    /*¬¥:¬∞‚Ä¢.¬∞+.*‚Ä¢¬¥.*:Àö.¬∞*.Àö‚Ä¢¬¥.¬∞:¬∞‚Ä¢.¬∞‚Ä¢.*‚Ä¢¬¥.*:Àö.¬∞*.Àö‚Ä¢¬¥.¬∞:¬∞‚Ä¢.¬∞+.*‚Ä¢¬¥.*:*/\n    /*                         CONSTANTS                          */\n    /*.‚Ä¢¬∞:¬∞.¬¥+Àö.*¬∞.Àö:*.¬¥‚Ä¢*.+¬∞.‚Ä¢¬∞:¬¥*.¬¥‚Ä¢*.‚Ä¢¬∞.‚Ä¢¬∞:¬∞.¬¥:‚Ä¢Àö¬∞.*¬∞.Àö:*.¬¥+¬∞.‚Ä¢*/\n\n    // There are 6 types of variables in JSON (excluding undefined).\n\n    /// @dev For denoting that an item has not been initialized.\n    /// A item returned from `parse` will never be of an undefined type.\n    /// Parsing a invalid JSON string will simply revert.\n    uint8 internal constant TYPE_UNDEFINED = 0;\n\n    /// @dev Type representing an array (e.g. `[1,2,3]`).\n    uint8 internal constant TYPE_ARRAY = 1;\n\n    /// @dev Type representing an object (e.g. `{\"a\":\"A\",\"b\":\"B\"}`).\n    uint8 internal constant TYPE_OBJECT = 2;\n\n    /// @dev Type representing a number (e.g. `-1.23e+21`).\n    uint8 internal constant TYPE_NUMBER = 3;\n\n    /// @dev Type representing a string (e.g. `\"hello\"`).\n    uint8 internal constant TYPE_STRING = 4;\n\n    /// @dev Type representing a boolean (i.e. `true` or `false`).\n    uint8 internal constant TYPE_BOOLEAN = 5;\n\n    /// @dev Type representing null (i.e. `null`).\n    uint8 internal constant TYPE_NULL = 6;\n\n    /*¬¥:¬∞‚Ä¢.¬∞+.*‚Ä¢¬¥.*:Àö.¬∞*.Àö‚Ä¢¬¥.¬∞:¬∞‚Ä¢.¬∞‚Ä¢.*‚Ä¢¬¥.*:Àö.¬∞*.Àö‚Ä¢¬¥.¬∞:¬∞‚Ä¢.¬∞+.*‚Ä¢¬¥.*:*/\n    /*                          STRUCTS                           */\n    /*.‚Ä¢¬∞:¬∞.¬¥+Àö.*¬∞.Àö:*.¬¥‚Ä¢*.+¬∞.‚Ä¢¬∞:¬¥*.¬¥‚Ä¢*.‚Ä¢¬∞.‚Ä¢¬∞:¬∞.¬¥:‚Ä¢Àö¬∞.*¬∞.Àö:*.¬¥+¬∞.‚Ä¢*/\n\n    /// @dev A pointer to a parsed JSON node.\n    struct Item {\n        // Do NOT modify the `_data` directly.\n        uint256 _data;\n    }\n\n    // Private constants for packing `_data`.\n\n    uint256 private constant _BITPOS_STRING = 32 * 7 - 8;\n    uint256 private constant _BITPOS_KEY_LENGTH = 32 * 6 - 8;\n    uint256 private constant _BITPOS_KEY = 32 * 5 - 8;\n    uint256 private constant _BITPOS_VALUE_LENGTH = 32 * 4 - 8;\n    uint256 private constant _BITPOS_VALUE = 32 * 3 - 8;\n    uint256 private constant _BITPOS_CHILD = 32 * 2 - 8;\n    uint256 private constant _BITPOS_SIBLING_OR_PARENT = 32 * 1 - 8;\n    uint256 private constant _BITMASK_POINTER = 0xffffffff;\n    uint256 private constant _BITMASK_TYPE = 7;\n    uint256 private constant _KEY_INITED = 1 << 3;\n    uint256 private constant _VALUE_INITED = 1 << 4;\n    uint256 private constant _CHILDREN_INITED = 1 << 5;\n    uint256 private constant _PARENT_IS_ARRAY = 1 << 6;\n    uint256 private constant _PARENT_IS_OBJECT = 1 << 7;\n\n    /*¬¥:¬∞‚Ä¢.¬∞+.*‚Ä¢¬¥.*:Àö.¬∞*.Àö‚Ä¢¬¥.¬∞:¬∞‚Ä¢.¬∞‚Ä¢.*‚Ä¢¬¥.*:Àö.¬∞*.Àö‚Ä¢¬¥.¬∞:¬∞‚Ä¢.¬∞+.*‚Ä¢¬¥.*:*/\n    /*                   JSON PARSING OPERATION                   */\n    /*.‚Ä¢¬∞:¬∞.¬¥+Àö.*¬∞.Àö:*.¬¥‚Ä¢*.+¬∞.‚Ä¢¬∞:¬¥*.¬¥‚Ä¢*.‚Ä¢¬∞.‚Ä¢¬∞:¬∞.¬¥:‚Ä¢Àö¬∞.*¬∞.Àö:*.¬¥+¬∞.‚Ä¢*/\n\n    /// @dev Parses the JSON string `s`, and returns the root.\n    /// Reverts if `s` is not a valid JSON as specified in RFC 8259.\n    /// Object items WILL simply contain all their children, inclusive of repeated keys,\n    /// in the same order which they appear in the JSON string.\n    ///\n    /// Note: For efficiency, this function WILL NOT make a copy of `s`.\n    /// The parsed tree WILL contain offsets to `s`.\n    /// Do NOT pass in a string that WILL be modified later on.\n    function parse(string memory s) internal pure returns (Item memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x40, result) // We will use our own allocation instead.\n        }\n        bytes32 r = _query(_toInput(s), 255);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := r\n        }\n    }\n\n    /*¬¥:¬∞‚Ä¢.¬∞+.*‚Ä¢¬¥.*:Àö.¬∞*.Àö‚Ä¢¬¥.¬∞:¬∞‚Ä¢.¬∞‚Ä¢.*‚Ä¢¬¥.*:Àö.¬∞*.Àö‚Ä¢¬¥.¬∞:¬∞‚Ä¢.¬∞+.*‚Ä¢¬¥.*:*/\n    /*                    JSON ITEM OPERATIONS                    */\n    /*.‚Ä¢¬∞:¬∞.¬¥+Àö.*¬∞.Àö:*.¬¥‚Ä¢*.+¬∞.‚Ä¢¬∞:¬¥*.¬¥‚Ä¢*.‚Ä¢¬∞.‚Ä¢¬∞:¬∞.¬¥:‚Ä¢Àö¬∞.*¬∞.Àö:*.¬¥+¬∞.‚Ä¢*/\n\n    // Note:\n    // - An item is a node in the JSON tree.\n    // - The value of a string item WILL be double-quoted, JSON encoded.\n    // - We make a distinction between `index` and `key`.\n    //   - Items in arrays are located by `index` (uint256).\n    //   - Items in objects are located by `key` (string).\n    // - Keys are always strings, double-quoted, JSON encoded.\n    //\n    // These design choices are made to balance between efficiency and ease-of-use.\n\n    /// @dev Returns the string value of the item.\n    /// This is its exact string representation in the original JSON string.\n    /// The returned string WILL have leading and trailing whitespace trimmed.\n    /// All inner whitespace WILL be preserved, exactly as it is in the original JSON string.\n    /// If the item's type is string, the returned string WILL be double-quoted, JSON encoded.\n    ///\n    /// Note: This function lazily instantiates and caches the returned string.\n    /// Do NOT modify the returned string.\n    function value(Item memory item) internal pure returns (string memory result) {\n        bytes32 r = _query(_toInput(item), 0);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := r\n        }\n    }\n\n    /// @dev Returns the index of the item in the array.\n    /// It the item's parent is not an array, returns 0.\n    function index(Item memory item) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if and(mload(item), _PARENT_IS_ARRAY) {\n                result := and(_BITMASK_POINTER, shr(_BITPOS_KEY, mload(item)))\n            }\n        }\n    }\n\n    /// @dev Returns the key of the item in the object.\n    /// It the item's parent is not an object, returns an empty string.\n    /// The returned string WILL be double-quoted, JSON encoded.\n    ///\n    /// Note: This function lazily instantiates and caches the returned string.\n    /// Do NOT modify the returned string.\n    function key(Item memory item) internal pure returns (string memory result) {\n        if (item._data & _PARENT_IS_OBJECT != 0) {\n            bytes32 r = _query(_toInput(item), 1);\n            /// @solidity memory-safe-assembly\n            assembly {\n                result := r\n            }\n        }\n    }\n\n    /// @dev Returns the key of the item in the object.\n    /// It the item is neither an array nor object, returns an empty array.\n    ///\n    /// Note: This function lazily instantiates and caches the returned array.\n    /// Do NOT modify the returned array.\n    function children(Item memory item) internal pure returns (Item[] memory result) {\n        bytes32 r = _query(_toInput(item), 3);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := r\n        }\n    }\n\n    /// @dev Returns the number of children.\n    /// It the item is neither an array nor object, returns zero.\n    function size(Item memory item) internal pure returns (uint256 result) {\n        bytes32 r = _query(_toInput(item), 3);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(r)\n        }\n    }\n\n    /// @dev Returns the item at index `i` for (array).\n    /// If `item` is not an array, the result's type WILL be undefined.\n    /// If there is no item with the index, the result's type WILL be undefined.\n    function at(Item memory item, uint256 i) internal pure returns (Item memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x40, result) // Free the default allocation. We'll allocate manually.\n        }\n        bytes32 r = _query(_toInput(item), 3);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(add(add(r, 0x20), shl(5, i)))\n            if iszero(and(lt(i, mload(r)), eq(and(mload(item), _BITMASK_TYPE), TYPE_ARRAY))) {\n                result := 0x60 // Reset to the zero pointer.\n            }\n        }\n    }\n\n    /// @dev Returns the item at key `k` for (object).\n    /// If `item` is not an object, the result's type WILL be undefined.\n    /// The key MUST be double-quoted, JSON encoded. This is for efficiency reasons.\n    /// - Correct : `item.at('\"k\"')`.\n    /// - Wrong   : `item.at(\"k\")`.\n    /// For duplicated keys, the last item with the key WILL be returned.\n    /// If there is no item with the key, the result's type WILL be undefined.\n    function at(Item memory item, string memory k) internal pure returns (Item memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x40, result) // Free the default allocation. We'll allocate manually.\n            result := 0x60 // Initialize to the zero pointer.\n        }\n        if (isObject(item)) {\n            bytes32 kHash = keccak256(bytes(k));\n            Item[] memory r = children(item);\n            // We'll just do a linear search. The alternatives are very bloated.\n            for (uint256 i = r.length << 5; i != 0;) {\n                /// @solidity memory-safe-assembly\n                assembly {\n                    item := mload(add(r, i))\n                    i := sub(i, 0x20)\n                }\n                if (keccak256(bytes(key(item))) != kHash) continue;\n                result = item;\n                break;\n            }\n        }\n    }\n\n    /// @dev Returns the item's type.\n    function getType(Item memory item) internal pure returns (uint8 result) {\n        result = uint8(item._data & _BITMASK_TYPE);\n    }\n\n    /// Note: All types are mutually exclusive.\n\n    /// @dev Returns whether the item is of type undefined.\n    function isUndefined(Item memory item) internal pure returns (bool result) {\n        result = item._data & _BITMASK_TYPE == TYPE_UNDEFINED;\n    }\n\n    /// @dev Returns whether the item is of type array.\n    function isArray(Item memory item) internal pure returns (bool result) {\n        result = item._data & _BITMASK_TYPE == TYPE_ARRAY;\n    }\n\n    /// @dev Returns whether the item is of type object.\n    function isObject(Item memory item) internal pure returns (bool result) {\n        result = item._data & _BITMASK_TYPE == TYPE_OBJECT;\n    }\n\n    /// @dev Returns whether the item is of type number.\n    function isNumber(Item memory item) internal pure returns (bool result) {\n        result = item._data & _BITMASK_TYPE == TYPE_NUMBER;\n    }\n\n    /// @dev Returns whether the item is of type string.\n    function isString(Item memory item) internal pure returns (bool result) {\n        result = item._data & _BITMASK_TYPE == TYPE_STRING;\n    }\n\n    /// @dev Returns whether the item is of type boolean.\n    function isBoolean(Item memory item) internal pure returns (bool result) {\n        result = item._data & _BITMASK_TYPE == TYPE_BOOLEAN;\n    }\n\n    /// @dev Returns whether the item is of type null.\n    function isNull(Item memory item) internal pure returns (bool result) {\n        result = item._data & _BITMASK_TYPE == TYPE_NULL;\n    }\n\n    /// @dev Returns the item's parent.\n    /// If the item does not have a parent, the result's type will be undefined.\n    function parent(Item memory item) internal pure returns (Item memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x40, result) // Free the default allocation. We've already allocated.\n            result := and(shr(_BITPOS_SIBLING_OR_PARENT, mload(item)), _BITMASK_POINTER)\n            if iszero(result) { result := 0x60 } // Reset to the zero pointer.\n        }\n    }\n\n    /*¬¥:¬∞‚Ä¢.¬∞+.*‚Ä¢¬¥.*:Àö.¬∞*.Àö‚Ä¢¬¥.¬∞:¬∞‚Ä¢.¬∞‚Ä¢.*‚Ä¢¬¥.*:Àö.¬∞*.Àö‚Ä¢¬¥.¬∞:¬∞‚Ä¢.¬∞+.*‚Ä¢¬¥.*:*/\n    /*                     UTILITY FUNCTIONS                      */\n    /*.‚Ä¢¬∞:¬∞.¬¥+Àö.*¬∞.Àö:*.¬¥‚Ä¢*.+¬∞.‚Ä¢¬∞:¬¥*.¬¥‚Ä¢*.‚Ä¢¬∞.‚Ä¢¬∞:¬∞.¬¥:‚Ä¢Àö¬∞.*¬∞.Àö:*.¬¥+¬∞.‚Ä¢*/\n\n    /// @dev Parses an unsigned integer from a string (in decimal, i.e. base 10).\n    /// Reverts if `s` is not a valid uint256 string matching the RegEx `^[0-9]+$`,\n    /// or if the parsed number is too big for a uint256.\n    function parseUint(string memory s) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(s)\n            let preMulOverflowThres := div(not(0), 10)\n            for { let i := 0 } 1 {} {\n                i := add(i, 1)\n                let digit := sub(and(mload(add(s, i)), 0xff), 48)\n                let mulOverflowed := gt(result, preMulOverflowThres)\n                let product := mul(10, result)\n                result := add(product, digit)\n                n := mul(n, iszero(or(or(mulOverflowed, lt(result, product)), gt(digit, 9))))\n                if iszero(lt(i, n)) { break }\n            }\n            if iszero(n) {\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Parses a signed integer from a string (in decimal, i.e. base 10).\n    /// Reverts if `s` is not a valid int256 string matching the RegEx `^[+-]?[0-9]+$`,\n    /// or if the parsed number cannot fit within `[-2**255 .. 2**255 - 1]`.\n    function parseInt(string memory s) internal pure returns (int256 result) {\n        uint256 n = bytes(s).length;\n        uint256 sign;\n        uint256 isNegative;\n        /// @solidity memory-safe-assembly\n        assembly {\n            if n {\n                let c := and(mload(add(s, 1)), 0xff)\n                isNegative := eq(c, 45)\n                if or(eq(c, 43), isNegative) {\n                    sign := c\n                    s := add(s, 1)\n                    mstore(s, sub(n, 1))\n                }\n                if iszero(or(sign, lt(sub(c, 48), 10))) { s := 0x60 }\n            }\n        }\n        uint256 x = parseUint(s);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(lt(x, add(shl(255, 1), isNegative))) {\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\n                revert(0x1c, 0x04)\n            }\n            if sign {\n                mstore(s, sign)\n                s := sub(s, 1)\n                mstore(s, n)\n            }\n            result := xor(x, mul(xor(x, add(not(x), 1)), isNegative))\n        }\n    }\n\n    /// @dev Parses an unsigned integer from a string (in hexadecimal, i.e. base 16).\n    /// Reverts if `s` is not a valid uint256 hex string matching the RegEx\n    /// `^(0[xX])?[0-9a-fA-F]+$`, or if the parsed number cannot fit within `[0 .. 2**256 - 1]`.\n    function parseUintFromHex(string memory s) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(s)\n            // Skip two if starts with '0x' or '0X'.\n            let i := shl(1, and(eq(0x3078, or(shr(240, mload(add(s, 0x20))), 0x20)), gt(n, 1)))\n            for {} 1 {} {\n                i := add(i, 1)\n                let c :=\n                    byte(\n                        and(0x1f, shr(and(mload(add(s, i)), 0xff), 0x3e4088843e41bac000000000000)),\n                        0x3010a071000000b0104040208000c05090d060e0f\n                    )\n                n := mul(n, iszero(or(iszero(c), shr(252, result))))\n                result := add(shl(4, result), sub(c, 1))\n                if iszero(lt(i, n)) { break }\n            }\n            if iszero(n) {\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Decodes a JSON encoded string.\n    /// The string MUST be double-quoted, JSON encoded.\n    /// Reverts if the string is invalid.\n    /// As you can see, it's pretty complex for a deceptively simple looking task.\n    function decodeString(string memory s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function fail() {\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\n                revert(0x1c, 0x04)\n            }\n\n            function decodeUnicodeEscapeSequence(pIn_, end_) -> _unicode, _pOut {\n                _pOut := add(pIn_, 4)\n                let b_ := iszero(gt(_pOut, end_))\n                let t_ := mload(pIn_) // Load the whole word.\n                for { let i_ := 0 } iszero(eq(i_, 4)) { i_ := add(i_, 1) } {\n                    let c_ := sub(byte(i_, t_), 48)\n                    if iszero(and(shr(c_, 0x7e0000007e03ff), b_)) { fail() } // Not hexadecimal.\n                    c_ := sub(c_, add(mul(gt(c_, 16), 7), shl(5, gt(c_, 48))))\n                    _unicode := add(shl(4, _unicode), c_)\n                }\n            }\n\n            function decodeUnicodeCodePoint(pIn_, end_) -> _unicode, _pOut {\n                _unicode, _pOut := decodeUnicodeEscapeSequence(pIn_, end_)\n                if iszero(or(lt(_unicode, 0xd800), gt(_unicode, 0xdbff))) {\n                    let t_ := mload(_pOut) // Load the whole word.\n                    end_ := mul(end_, eq(shr(240, t_), 0x5c75)) // Fail if not starting with '\\\\u'.\n                    t_, _pOut := decodeUnicodeEscapeSequence(add(_pOut, 2), end_)\n                    _unicode := add(0x10000, add(shl(10, and(0x3ff, _unicode)), and(0x3ff, t_)))\n                }\n            }\n\n            function appendCodePointAsUTF8(pIn_, c_) -> _pOut {\n                if iszero(gt(c_, 0x7f)) {\n                    mstore8(pIn_, c_)\n                    _pOut := add(pIn_, 1)\n                    leave\n                }\n                mstore8(0x1f, c_)\n                mstore8(0x1e, shr(6, c_))\n                if iszero(gt(c_, 0x7ff)) {\n                    mstore(pIn_, shl(240, or(0xc080, and(0x1f3f, mload(0x00)))))\n                    _pOut := add(pIn_, 2)\n                    leave\n                }\n                mstore8(0x1d, shr(12, c_))\n                if iszero(gt(c_, 0xffff)) {\n                    mstore(pIn_, shl(232, or(0xe08080, and(0x0f3f3f, mload(0x00)))))\n                    _pOut := add(pIn_, 3)\n                    leave\n                }\n                mstore8(0x1c, shr(18, c_))\n                mstore(pIn_, shl(224, or(0xf0808080, and(0x073f3f3f, mload(0x00)))))\n                _pOut := add(pIn_, shl(2, lt(c_, 0x110000)))\n            }\n\n            function chr(p_) -> _c {\n                _c := byte(0, mload(p_))\n            }\n\n            let n := mload(s)\n            let end := add(add(s, n), 0x1f)\n            if iszero(and(gt(n, 1), eq(0x2222, or(and(0xff00, mload(add(s, 2))), chr(end))))) {\n                fail() // Fail if not double-quoted.\n            }\n            let out := add(mload(0x40), 0x20)\n            for { let curr := add(s, 0x21) } iszero(eq(curr, end)) {} {\n                let c := chr(curr)\n                curr := add(curr, 1)\n                // Not '\\\\'.\n                if iszero(eq(c, 92)) {\n                    // Not '\"'.\n                    if iszero(eq(c, 34)) {\n                        mstore8(out, c)\n                        out := add(out, 1)\n                        continue\n                    }\n                    curr := end\n                }\n                if iszero(eq(curr, end)) {\n                    let escape := chr(curr)\n                    curr := add(curr, 1)\n                    // '\"', '/', '\\\\'.\n                    if and(shr(escape, 0x100000000000800400000000), 1) {\n                        mstore8(out, escape)\n                        out := add(out, 1)\n                        continue\n                    }\n                    // 'u'.\n                    if eq(escape, 117) {\n                        escape, curr := decodeUnicodeCodePoint(curr, end)\n                        out := appendCodePointAsUTF8(out, escape)\n                        continue\n                    }\n                    // `{'b':'\\b', 'f':'\\f', 'n':'\\n', 'r':'\\r', 't':'\\t'}`.\n                    escape := byte(sub(escape, 85), 0x080000000c000000000000000a0000000d0009)\n                    if escape {\n                        mstore8(out, escape)\n                        out := add(out, 1)\n                        continue\n                    }\n                }\n                fail()\n                break\n            }\n            mstore(out, 0) // Zeroize the last slot.\n            result := mload(0x40)\n            mstore(result, sub(out, add(result, 0x20))) // Store the length.\n            mstore(0x40, add(out, 0x20)) // Allocate the memory.\n        }\n    }\n\n    /*¬¥:¬∞‚Ä¢.¬∞+.*‚Ä¢¬¥.*:Àö.¬∞*.Àö‚Ä¢¬¥.¬∞:¬∞‚Ä¢.¬∞‚Ä¢.*‚Ä¢¬¥.*:Àö.¬∞*.Àö‚Ä¢¬¥.¬∞:¬∞‚Ä¢.¬∞+.*‚Ä¢¬¥.*:*/\n    /*                      PRIVATE HELPERS                       */\n    /*.‚Ä¢¬∞:¬∞.¬¥+Àö.*¬∞.Àö:*.¬¥‚Ä¢*.+¬∞.‚Ä¢¬∞:¬¥*.¬¥‚Ä¢*.‚Ä¢¬∞.‚Ä¢¬∞:¬∞.¬¥:‚Ä¢Àö¬∞.*¬∞.Àö:*.¬¥+¬∞.‚Ä¢*/\n\n    /// @dev Performs a query on the input with the given mode.\n    function _query(bytes32 input, uint256 mode) private pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function fail() {\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\n                revert(0x1c, 0x04)\n            }\n\n            function chr(p_) -> _c {\n                _c := byte(0, mload(p_))\n            }\n\n            function skipWhitespace(pIn_, end_) -> _pOut {\n                for { _pOut := pIn_ } 1 { _pOut := add(_pOut, 1) } {\n                    if iszero(and(shr(chr(_pOut), 0x100002600), 1)) { leave } // Not in ' \\n\\r\\t'.\n                }\n            }\n\n            function setP(packed_, bitpos_, p_) -> _packed {\n                // Perform an out-of-gas revert if `p_` exceeds `_BITMASK_POINTER`.\n                returndatacopy(returndatasize(), returndatasize(), gt(p_, _BITMASK_POINTER))\n                _packed := or(and(not(shl(bitpos_, _BITMASK_POINTER)), packed_), shl(bitpos_, p_))\n            }\n\n            function getP(packed_, bitpos_) -> _p {\n                _p := and(_BITMASK_POINTER, shr(bitpos_, packed_))\n            }\n\n            function mallocItem(s_, packed_, pStart_, pCurr_, type_) -> _item {\n                _item := mload(0x40)\n                // forgefmt: disable-next-item\n                packed_ := setP(setP(packed_, _BITPOS_VALUE, sub(pStart_, add(s_, 0x20))),\n                    _BITPOS_VALUE_LENGTH, sub(pCurr_, pStart_))\n                mstore(_item, or(packed_, type_))\n                mstore(0x40, add(_item, 0x20)) // Allocate memory.\n            }\n\n            function parseValue(s_, sibling_, pIn_, end_) -> _item, _pOut {\n                let packed_ := setP(mload(0x00), _BITPOS_SIBLING_OR_PARENT, sibling_)\n                _pOut := skipWhitespace(pIn_, end_)\n                if iszero(lt(_pOut, end_)) { leave }\n                for { let c_ := chr(_pOut) } 1 {} {\n                    // If starts with '\"'.\n                    if eq(c_, 34) {\n                        let pStart_ := _pOut\n                        _pOut := parseStringSub(s_, packed_, _pOut, end_)\n                        _item := mallocItem(s_, packed_, pStart_, _pOut, TYPE_STRING)\n                        break\n                    }\n                    // If starts with '['.\n                    if eq(c_, 91) {\n                        _item, _pOut := parseArray(s_, packed_, _pOut, end_)\n                        break\n                    }\n                    // If starts with '{'.\n                    if eq(c_, 123) {\n                        _item, _pOut := parseObject(s_, packed_, _pOut, end_)\n                        break\n                    }\n                    // If starts with any in '0123456789-'.\n                    if and(shr(c_, shl(45, 0x1ff9)), 1) {\n                        _item, _pOut := parseNumber(s_, packed_, _pOut, end_)\n                        break\n                    }\n                    if iszero(gt(add(_pOut, 4), end_)) {\n                        let pStart_ := _pOut\n                        let w_ := shr(224, mload(_pOut))\n                        // 'true' in hex format.\n                        if eq(w_, 0x74727565) {\n                            _pOut := add(_pOut, 4)\n                            _item := mallocItem(s_, packed_, pStart_, _pOut, TYPE_BOOLEAN)\n                            break\n                        }\n                        // 'null' in hex format.\n                        if eq(w_, 0x6e756c6c) {\n                            _pOut := add(_pOut, 4)\n                            _item := mallocItem(s_, packed_, pStart_, _pOut, TYPE_NULL)\n                            break\n                        }\n                    }\n                    if iszero(gt(add(_pOut, 5), end_)) {\n                        let pStart_ := _pOut\n                        let w_ := shr(216, mload(_pOut))\n                        // 'false' in hex format.\n                        if eq(w_, 0x66616c7365) {\n                            _pOut := add(_pOut, 5)\n                            _item := mallocItem(s_, packed_, pStart_, _pOut, TYPE_BOOLEAN)\n                            break\n                        }\n                    }\n                    fail()\n                    break\n                }\n                _pOut := skipWhitespace(_pOut, end_)\n            }\n\n            function parseArray(s_, packed_, pIn_, end_) -> _item, _pOut {\n                let j_ := 0\n                for { _pOut := add(pIn_, 1) } 1 { _pOut := add(_pOut, 1) } {\n                    if iszero(lt(_pOut, end_)) { fail() }\n                    if iszero(_item) {\n                        _pOut := skipWhitespace(_pOut, end_)\n                        if eq(chr(_pOut), 93) { break } // ']'.\n                    }\n                    _item, _pOut := parseValue(s_, _item, _pOut, end_)\n                    if _item {\n                        // forgefmt: disable-next-item\n                        mstore(_item, setP(or(_PARENT_IS_ARRAY, mload(_item)),\n                            _BITPOS_KEY, j_))\n                        j_ := add(j_, 1)\n                        let c_ := chr(_pOut)\n                        if eq(c_, 93) { break } // ']'.\n                        if eq(c_, 44) { continue } // ','.\n                    }\n                    _pOut := end_\n                }\n                _pOut := add(_pOut, 1)\n                packed_ := setP(packed_, _BITPOS_CHILD, _item)\n                _item := mallocItem(s_, packed_, pIn_, _pOut, TYPE_ARRAY)\n            }\n\n            function parseObject(s_, packed_, pIn_, end_) -> _item, _pOut {\n                for { _pOut := add(pIn_, 1) } 1 { _pOut := add(_pOut, 1) } {\n                    if iszero(lt(_pOut, end_)) { fail() }\n                    if iszero(_item) {\n                        _pOut := skipWhitespace(_pOut, end_)\n                        if eq(chr(_pOut), 125) { break } // '}'.\n                    }\n                    _pOut := skipWhitespace(_pOut, end_)\n                    let pKeyStart_ := _pOut\n                    let pKeyEnd_ := parseStringSub(s_, _item, _pOut, end_)\n                    _pOut := skipWhitespace(pKeyEnd_, end_)\n                    // If ':'.\n                    if eq(chr(_pOut), 58) {\n                        _item, _pOut := parseValue(s_, _item, add(_pOut, 1), end_)\n                        if _item {\n                            // forgefmt: disable-next-item\n                            mstore(_item, setP(setP(or(_PARENT_IS_OBJECT, mload(_item)),\n                                _BITPOS_KEY_LENGTH, sub(pKeyEnd_, pKeyStart_)),\n                                    _BITPOS_KEY, sub(pKeyStart_, add(s_, 0x20))))\n                            let c_ := chr(_pOut)\n                            if eq(c_, 125) { break } // '}'.\n                            if eq(c_, 44) { continue } // ','.\n                        }\n                    }\n                    _pOut := end_\n                }\n                _pOut := add(_pOut, 1)\n                packed_ := setP(packed_, _BITPOS_CHILD, _item)\n                _item := mallocItem(s_, packed_, pIn_, _pOut, TYPE_OBJECT)\n            }\n\n            function checkStringU(p_, o_) {\n                // If not in '0123456789abcdefABCDEF', revert.\n                if iszero(and(shr(sub(chr(add(p_, o_)), 48), 0x7e0000007e03ff), 1)) { fail() }\n                if iszero(eq(o_, 5)) { checkStringU(p_, add(o_, 1)) }\n            }\n\n            function parseStringSub(s_, packed_, pIn_, end_) -> _pOut {\n                if iszero(lt(pIn_, end_)) { fail() }\n                for { _pOut := add(pIn_, 1) } 1 {} {\n                    let c_ := chr(_pOut)\n                    if eq(c_, 34) { break } // '\"'.\n                    // Not '\\'.\n                    if iszero(eq(c_, 92)) {\n                        _pOut := add(_pOut, 1)\n                        continue\n                    }\n                    c_ := chr(add(_pOut, 1))\n                    // '\"', '\\', '//', 'b', 'f', 'n', 'r', 't'.\n                    if and(shr(sub(c_, 34), 0x510110400000000002001), 1) {\n                        _pOut := add(_pOut, 2)\n                        continue\n                    }\n                    // 'u'.\n                    if eq(c_, 117) {\n                        checkStringU(_pOut, 2)\n                        _pOut := add(_pOut, 6)\n                        continue\n                    }\n                    _pOut := end_\n                    break\n                }\n                if iszero(lt(_pOut, end_)) { fail() }\n                _pOut := add(_pOut, 1)\n            }\n\n            function skip0To9s(pIn_, end_, atLeastOne_) -> _pOut {\n                for { _pOut := pIn_ } 1 { _pOut := add(_pOut, 1) } {\n                    if iszero(lt(sub(chr(_pOut), 48), 10)) { break } // Not '0'..'9'.\n                }\n                if and(atLeastOne_, eq(pIn_, _pOut)) { fail() }\n            }\n\n            function parseNumber(s_, packed_, pIn_, end_) -> _item, _pOut {\n                _pOut := pIn_\n                if eq(chr(_pOut), 45) { _pOut := add(_pOut, 1) } // '-'.\n                if iszero(lt(sub(chr(_pOut), 48), 10)) { fail() } // Not '0'..'9'.\n                let c_ := chr(_pOut)\n                _pOut := add(_pOut, 1)\n                if iszero(eq(c_, 48)) { _pOut := skip0To9s(_pOut, end_, 0) } // Not '0'.\n                if eq(chr(_pOut), 46) { _pOut := skip0To9s(add(_pOut, 1), end_, 1) } // '.'.\n                let t_ := mload(_pOut)\n                // 'E', 'e'.\n                if eq(or(0x20, byte(0, t_)), 101) {\n                    // forgefmt: disable-next-item\n                    _pOut := skip0To9s(add(byte(sub(byte(1, t_), 14), 0x010001), // '+', '-'.\n                        add(_pOut, 1)), end_, 1)\n                }\n                _item := mallocItem(s_, packed_, pIn_, _pOut, TYPE_NUMBER)\n            }\n\n            function copyStr(s_, offset_, len_) -> _sCopy {\n                _sCopy := mload(0x40)\n                s_ := add(s_, offset_)\n                let w_ := not(0x1f)\n                for { let i_ := and(add(len_, 0x1f), w_) } 1 {} {\n                    mstore(add(_sCopy, i_), mload(add(s_, i_)))\n                    i_ := add(i_, w_) // `sub(i_, 0x20)`.\n                    if iszero(i_) { break }\n                }\n                mstore(_sCopy, len_) // Copy the length.\n                mstore(add(add(_sCopy, 0x20), len_), 0) // Zeroize the last slot.\n                mstore(0x40, add(add(_sCopy, 0x40), len_)) // Allocate memory.\n            }\n\n            function value(item_) -> _value {\n                let packed_ := mload(item_)\n                _value := getP(packed_, _BITPOS_VALUE) // The offset in the string.\n                if iszero(and(_VALUE_INITED, packed_)) {\n                    let s_ := getP(packed_, _BITPOS_STRING)\n                    _value := copyStr(s_, _value, getP(packed_, _BITPOS_VALUE_LENGTH))\n                    packed_ := setP(packed_, _BITPOS_VALUE, _value)\n                    mstore(s_, or(_VALUE_INITED, packed_))\n                }\n            }\n\n            function children(item_) -> _arr {\n                _arr := 0x60 // Initialize to the zero pointer.\n                let packed_ := mload(item_)\n                for {} iszero(gt(and(_BITMASK_TYPE, packed_), TYPE_OBJECT)) {} {\n                    if or(iszero(packed_), iszero(item_)) { break }\n                    if and(packed_, _CHILDREN_INITED) {\n                        _arr := getP(packed_, _BITPOS_CHILD)\n                        break\n                    }\n                    _arr := mload(0x40)\n                    let o_ := add(_arr, 0x20)\n                    for { let h_ := getP(packed_, _BITPOS_CHILD) } h_ {} {\n                        mstore(o_, h_)\n                        let q_ := mload(h_)\n                        let y_ := getP(q_, _BITPOS_SIBLING_OR_PARENT)\n                        mstore(h_, setP(q_, _BITPOS_SIBLING_OR_PARENT, item_))\n                        h_ := y_\n                        o_ := add(o_, 0x20)\n                    }\n                    let w_ := not(0x1f)\n                    let n_ := add(w_, sub(o_, _arr))\n                    mstore(_arr, shr(5, n_))\n                    mstore(0x40, o_) // Allocate memory.\n                    packed_ := setP(packed_, _BITPOS_CHILD, _arr)\n                    mstore(item_, or(_CHILDREN_INITED, packed_))\n                    // Reverse the array.\n                    if iszero(lt(n_, 0x40)) {\n                        let lo_ := add(_arr, 0x20)\n                        let hi_ := add(_arr, n_)\n                        for {} 1 {} {\n                            let temp_ := mload(lo_)\n                            mstore(lo_, mload(hi_))\n                            mstore(hi_, temp_)\n                            hi_ := add(hi_, w_)\n                            lo_ := add(lo_, 0x20)\n                            if iszero(lt(lo_, hi_)) { break }\n                        }\n                    }\n                    break\n                }\n            }\n\n            function getStr(item_, bitpos_, bitposLength_, bitmaskInited_) -> _result {\n                _result := 0x60 // Initialize to the zero pointer.\n                let packed_ := mload(item_)\n                if or(iszero(item_), iszero(packed_)) { leave }\n                _result := getP(packed_, bitpos_)\n                if iszero(and(bitmaskInited_, packed_)) {\n                    let s_ := getP(packed_, _BITPOS_STRING)\n                    _result := copyStr(s_, _result, getP(packed_, bitposLength_))\n                    mstore(item_, or(bitmaskInited_, setP(packed_, bitpos_, _result)))\n                }\n            }\n\n            switch mode\n            // Get value.\n            case 0 { result := getStr(input, _BITPOS_VALUE, _BITPOS_VALUE_LENGTH, _VALUE_INITED) }\n            // Get key.\n            case 1 { result := getStr(input, _BITPOS_KEY, _BITPOS_KEY_LENGTH, _KEY_INITED) }\n            // Get children.\n            case 3 { result := children(input) }\n            // Parse.\n            default {\n                let p := add(input, 0x20)\n                let e := add(p, mload(input))\n                if iszero(eq(p, e)) {\n                    let c := chr(e)\n                    mstore8(e, 34) // Place a '\"' at the end to speed up parsing.\n                    // The `34 << 248` makes `mallocItem` preserve '\"' at the end.\n                    mstore(0x00, setP(shl(248, 34), _BITPOS_STRING, input))\n                    result, p := parseValue(input, 0, p, e)\n                    mstore8(e, c) // Restore the original char at the end.\n                }\n                if or(lt(p, e), iszero(result)) { fail() }\n            }\n        }\n    }\n\n    /// @dev Casts the input to a bytes32.\n    function _toInput(string memory input) private pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := input\n        }\n    }\n\n    /// @dev Casts the input to a bytes32.\n    function _toInput(Item memory input) private pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := input\n        }\n    }\n}\n"
    },
    "solidity-rlp/contracts/RLPReader.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * @author Hamdi Allam hamdi.allam97@gmail.com\n * Please reach out with any questions or concerns\n */\npragma solidity >=0.5.10 <0.9.0;\n\nlibrary RLPReader {\n    uint8 constant STRING_SHORT_START = 0x80;\n    uint8 constant STRING_LONG_START = 0xb8;\n    uint8 constant LIST_SHORT_START = 0xc0;\n    uint8 constant LIST_LONG_START = 0xf8;\n    uint8 constant WORD_SIZE = 32;\n\n    struct RLPItem {\n        uint256 len;\n        uint256 memPtr;\n    }\n\n    struct Iterator {\n        RLPItem item; // Item that's being iterated over.\n        uint256 nextPtr; // Position of the next item in the list.\n    }\n\n    /*\n     * @dev Returns the next element in the iteration. Reverts if it has not next element.\n     * @param self The iterator.\n     * @return The next element in the iteration.\n     */\n    function next(Iterator memory self) internal pure returns (RLPItem memory) {\n        require(hasNext(self));\n\n        uint256 ptr = self.nextPtr;\n        uint256 itemLength = _itemLength(ptr);\n        self.nextPtr = ptr + itemLength;\n\n        return RLPItem(itemLength, ptr);\n    }\n\n    /*\n     * @dev Returns true if the iteration has more elements.\n     * @param self The iterator.\n     * @return true if the iteration has more elements.\n     */\n    function hasNext(Iterator memory self) internal pure returns (bool) {\n        RLPItem memory item = self.item;\n        return self.nextPtr < item.memPtr + item.len;\n    }\n\n    /*\n     * @param item RLP encoded bytes\n     */\n    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\n        uint256 memPtr;\n        assembly {\n            memPtr := add(item, 0x20)\n        }\n\n        return RLPItem(item.length, memPtr);\n    }\n\n    /*\n     * @dev Create an iterator. Reverts if item is not a list.\n     * @param self The RLP item.\n     * @return An 'Iterator' over the item.\n     */\n    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {\n        require(isList(self));\n\n        uint256 ptr = self.memPtr + _payloadOffset(self.memPtr);\n        return Iterator(self, ptr);\n    }\n\n    /*\n     * @param the RLP item.\n     */\n    function rlpLen(RLPItem memory item) internal pure returns (uint256) {\n        return item.len;\n    }\n\n    /*\n     * @param the RLP item.\n     * @return (memPtr, len) pair: location of the item's payload in memory.\n     */\n    function payloadLocation(RLPItem memory item) internal pure returns (uint256, uint256) {\n        uint256 offset = _payloadOffset(item.memPtr);\n        uint256 memPtr = item.memPtr + offset;\n        uint256 len = item.len - offset; // data length\n        return (memPtr, len);\n    }\n\n    /*\n     * @param the RLP item.\n     */\n    function payloadLen(RLPItem memory item) internal pure returns (uint256) {\n        (, uint256 len) = payloadLocation(item);\n        return len;\n    }\n\n    /*\n     * @param the RLP item containing the encoded list.\n     */\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {\n        require(isList(item));\n\n        uint256 items = numItems(item);\n        RLPItem[] memory result = new RLPItem[](items);\n\n        uint256 memPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint256 dataLen;\n        for (uint256 i = 0; i < items; i++) {\n            dataLen = _itemLength(memPtr);\n            result[i] = RLPItem(dataLen, memPtr);\n            memPtr = memPtr + dataLen;\n        }\n\n        return result;\n    }\n\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\n    function isList(RLPItem memory item) internal pure returns (bool) {\n        if (item.len == 0) return false;\n\n        uint8 byte0;\n        uint256 memPtr = item.memPtr;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < LIST_SHORT_START) return false;\n        return true;\n    }\n\n    /*\n     * @dev A cheaper version of keccak256(toRlpBytes(item)) that avoids copying memory.\n     * @return keccak256 hash of RLP encoded bytes.\n     */\n    function rlpBytesKeccak256(RLPItem memory item) internal pure returns (bytes32) {\n        uint256 ptr = item.memPtr;\n        uint256 len = item.len;\n        bytes32 result;\n        assembly {\n            result := keccak256(ptr, len)\n        }\n        return result;\n    }\n\n    /*\n     * @dev A cheaper version of keccak256(toBytes(item)) that avoids copying memory.\n     * @return keccak256 hash of the item payload.\n     */\n    function payloadKeccak256(RLPItem memory item) internal pure returns (bytes32) {\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\n        bytes32 result;\n        assembly {\n            result := keccak256(memPtr, len)\n        }\n        return result;\n    }\n\n    /** RLPItem conversions into data types **/\n\n    // @returns raw rlp encoding in bytes\n    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {\n        bytes memory result = new bytes(item.len);\n        if (result.length == 0) return result;\n\n        uint256 ptr;\n        assembly {\n            ptr := add(0x20, result)\n        }\n\n        copy(item.memPtr, ptr, item.len);\n        return result;\n    }\n\n    // any non-zero byte except \"0x80\" is considered true\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\n        require(item.len == 1);\n        uint256 result;\n        uint256 memPtr = item.memPtr;\n        assembly {\n            result := byte(0, mload(memPtr))\n        }\n\n        // SEE Github Issue #5.\n        // Summary: Most commonly used RLP libraries (i.e Geth) will encode\n        // \"0\" as \"0x80\" instead of as \"0\". We handle this edge case explicitly\n        // here.\n        if (result == 0 || result == STRING_SHORT_START) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    function toAddress(RLPItem memory item) internal pure returns (address) {\n        // 1 byte for the length prefix\n        require(item.len == 21);\n\n        return address(uint160(toUint(item)));\n    }\n\n    function toUint(RLPItem memory item) internal pure returns (uint256) {\n        require(item.len > 0 && item.len <= 33);\n\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\n\n        uint256 result;\n        assembly {\n            result := mload(memPtr)\n\n            // shift to the correct location if neccesary\n            if lt(len, 32) {\n                result := div(result, exp(256, sub(32, len)))\n            }\n        }\n\n        return result;\n    }\n\n    // enforces 32 byte length\n    function toUintStrict(RLPItem memory item) internal pure returns (uint256) {\n        // one byte prefix\n        require(item.len == 33);\n\n        uint256 result;\n        uint256 memPtr = item.memPtr + 1;\n        assembly {\n            result := mload(memPtr)\n        }\n\n        return result;\n    }\n\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\n        require(item.len > 0);\n\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\n        bytes memory result = new bytes(len);\n\n        uint256 destPtr;\n        assembly {\n            destPtr := add(0x20, result)\n        }\n\n        copy(memPtr, destPtr, len);\n        return result;\n    }\n\n    /*\n     * Private Helpers\n     */\n\n    // @return number of payload items inside an encoded list.\n    function numItems(RLPItem memory item) private pure returns (uint256) {\n        if (item.len == 0) return 0;\n\n        uint256 count = 0;\n        uint256 currPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint256 endPtr = item.memPtr + item.len;\n        while (currPtr < endPtr) {\n            currPtr = currPtr + _itemLength(currPtr); // skip over an item\n            count++;\n        }\n\n        return count;\n    }\n\n    // @return entire rlp item byte length\n    function _itemLength(uint256 memPtr) private pure returns (uint256) {\n        uint256 itemLen;\n        uint256 byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START) {\n            itemLen = 1;\n        } else if (byte0 < STRING_LONG_START) {\n            itemLen = byte0 - STRING_SHORT_START + 1;\n        } else if (byte0 < LIST_SHORT_START) {\n            assembly {\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\n                memPtr := add(memPtr, 1) // skip over the first byte\n\n                /* 32 byte word size */\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\n                itemLen := add(dataLen, add(byteLen, 1))\n            }\n        } else if (byte0 < LIST_LONG_START) {\n            itemLen = byte0 - LIST_SHORT_START + 1;\n        } else {\n            assembly {\n                let byteLen := sub(byte0, 0xf7)\n                memPtr := add(memPtr, 1)\n\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\n                itemLen := add(dataLen, add(byteLen, 1))\n            }\n        }\n\n        return itemLen;\n    }\n\n    // @return number of bytes until the data\n    function _payloadOffset(uint256 memPtr) private pure returns (uint256) {\n        uint256 byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START) {\n            return 0;\n        } else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START)) {\n            return 1;\n        } else if (byte0 < LIST_SHORT_START) {\n            // being explicit\n            return byte0 - (STRING_LONG_START - 1) + 1;\n        } else {\n            return byte0 - (LIST_LONG_START - 1) + 1;\n        }\n    }\n\n    /*\n     * @param src Pointer to source\n     * @param dest Pointer to destination\n     * @param len Amount of memory to copy from the source\n     */\n    function copy(uint256 src, uint256 dest, uint256 len) private pure {\n        if (len == 0) return;\n\n        // copy as many word sizes as possible\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n\n            src += WORD_SIZE;\n            dest += WORD_SIZE;\n        }\n\n        if (len > 0) {\n            // left over bytes. Mask is used to remove unwanted bytes from the word\n            uint256 mask = 256**(WORD_SIZE - len) - 1;\n            assembly {\n                let srcpart := and(mload(src), not(mask)) // zero out src\n                let destpart := and(mload(dest), mask) // retrieve the bytes\n                mstore(dest, or(destpart, srcpart))\n            }\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}