{
  "address": "0xc803334c79650708Daf3a3462AC4B48296b1352a",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "name": "PeekerReverted",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "message",
          "type": "string"
        }
      ],
      "name": "SuaveError",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "message",
          "type": "string"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "SuaveErrorWithData",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "string",
          "name": "ticker",
          "type": "string"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "price",
          "type": "uint256"
        }
      ],
      "name": "PriceSubmission",
      "type": "event"
    },
    {
      "stateMutability": "payable",
      "type": "fallback"
    },
    {
      "inputs": [],
      "name": "DECIMALS",
      "outputs": [
        {
          "internalType": "uint8",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "HOLESKY_BUNDLE_ENDPOINT",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "HOLESKY_CHAINID",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "HOLESKY_CHAINID_STR",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "REMOTE_HOLESKY_RPC",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "S_NAMESPACE",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "URL_PARTIAL",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "confidentialConstructor",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "Suave.DataId",
          "name": "_pkBidId",
          "type": "bytes16"
        },
        {
          "internalType": "address",
          "name": "pkAddress",
          "type": "address"
        }
      ],
      "name": "confidentialConstructorCallback",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "controller",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "pkBidId",
      "outputs": [
        {
          "internalType": "Suave.DataId",
          "name": "",
          "type": "bytes16"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "ticker",
          "type": "string"
        },
        {
          "internalType": "uint256",
          "name": "nonce",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "gasPrice",
          "type": "uint256"
        },
        {
          "internalType": "uint64",
          "name": "settlementBlockNum",
          "type": "uint64"
        },
        {
          "internalType": "bool",
          "name": "privateSubmission",
          "type": "bool"
        }
      ],
      "name": "queryAndSubmit",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "ticker",
          "type": "string"
        },
        {
          "internalType": "uint256",
          "name": "price",
          "type": "uint256"
        }
      ],
      "name": "queryAndSubmitCallback",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "ticker",
          "type": "string"
        }
      ],
      "name": "queryLatestPrice",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "price",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_settlementContract",
          "type": "address"
        }
      ],
      "name": "registerCallback",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_settlementContract",
          "type": "address"
        }
      ],
      "name": "registerSettlementContract",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "txSigned",
          "type": "bytes"
        }
      ],
      "name": "sendRawTx",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "settlementContract",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xb2df809f2e851dc578ffbb04790138cf0a837c3930632367f6391642c64a49c8",
  "receipt": {
    "to": null,
    "from": "0x16f2Aa8dF055b6e672b93Ded41FecCCabAB565B0",
    "contractAddress": "0xc803334c79650708Daf3a3462AC4B48296b1352a",
    "transactionIndex": 0,
    "gasUsed": "4938842",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x8d8b56cfd7b07a89fd5344578768ff1e0a4aa832f337963af3a9a4eebb001e6c",
    "transactionHash": "0xb2df809f2e851dc578ffbb04790138cf0a837c3930632367f6391642c64a49c8",
    "logs": [],
    "blockNumber": 3253311,
    "cumulativeGasUsed": "4938842",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "58b5f03dcf41452f7838ae9c428c3bfe",
  "metadata": "{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"PeekerReverted\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"SuaveError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SuaveErrorWithData\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"ticker\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"PriceSubmission\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"DECIMALS\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"HOLESKY_BUNDLE_ENDPOINT\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"HOLESKY_CHAINID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"HOLESKY_CHAINID_STR\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REMOTE_HOLESKY_RPC\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"S_NAMESPACE\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"URL_PARTIAL\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"confidentialConstructor\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"Suave.DataId\",\"name\":\"_pkBidId\",\"type\":\"bytes16\"},{\"internalType\":\"address\",\"name\":\"pkAddress\",\"type\":\"address\"}],\"name\":\"confidentialConstructorCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pkBidId\",\"outputs\":[{\"internalType\":\"Suave.DataId\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"ticker\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"settlementBlockNum\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"privateSubmission\",\"type\":\"bool\"}],\"name\":\"queryAndSubmit\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"ticker\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"queryAndSubmitCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"ticker\",\"type\":\"string\"}],\"name\":\"queryLatestPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_settlementContract\",\"type\":\"address\"}],\"name\":\"registerCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_settlementContract\",\"type\":\"address\"}],\"name\":\"registerSettlementContract\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"txSigned\",\"type\":\"bytes\"}],\"name\":\"sendRawTx\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"settlementContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/oracle/BinanceOracle.sol\":\"BinanceOracle\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/blockad/lib/SuaveContract.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// Author: Miha Lotric (halo3mic)\\n\\npragma solidity ^0.8.8;\\n\\nimport { Suave } from \\\"../../standard_peekers/bids.sol\\\";\\n\\n\\nabstract contract SuaveContract {\\n\\terror SuaveError(string message);\\n\\terror SuaveErrorWithData(string message, bytes data);\\n\\n\\tmodifier onlyConfidential() {\\n\\t\\tcrequire(Suave.isConfidential(), \\\"Not confidential\\\");\\n\\t\\t_;\\n\\t}\\n\\n\\tfunction simulateBundleSafe(bytes memory bundle, bool doRevert) internal view returns (bool valid, uint64 egp) {\\n\\t\\t(bool success, bytes memory d) = Suave.SIMULATE_BUNDLE.staticcall{ gas: 20_000 }(abi.encode(bundle));\\n\\t\\tcrequire(!doRevert || success, string(d));\\n\\t\\tif (success) {\\n\\t\\t\\treturn (true, abi.decode(d, (uint64)));\\n\\t\\t}\\n\\t}\\n\\n\\tfunction crequire(bool condition, string memory message) internal pure {\\n\\t\\tif (!condition) {\\n\\t\\t\\trevert SuaveError(message);\\n\\t\\t}\\n\\t}\\n}\\n\",\"keccak256\":\"0x64eb01469afe18f29050571acd52ee35faca1da2c00a87e01d5ea0fdbcdf4bec\",\"license\":\"MIT\"},\"contracts/libraries/Bundle.sol\":{\"content\":\"// Source: https://github.com/flashbots/suave-std/blob/main/src/protocols/Bundle.sol\\n\\n\\n// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\nimport \\\"./Suave.sol\\\";\\nimport \\\"solady/src/utils/LibString.sol\\\";\\n\\n// https://docs.flashbots.net/flashbots-auction/advanced/rpc-endpoint#eth_sendbundle\\nlibrary Bundle {\\n    struct BundleObj {\\n        uint64 blockNumber;\\n        uint64 minTimestamp;\\n        uint64 maxTimestamp;\\n        bytes[] txns;\\n    }\\n\\n    function sendBundle(string memory url, BundleObj memory bundle) internal view returns (bytes memory) {\\n        Suave.HttpRequest memory request = encodeBundle(bundle);\\n        request.url = url;\\n        return Suave.doHTTPRequest(request);\\n    }\\n\\n    function encodeBundle(BundleObj memory args) internal pure returns (Suave.HttpRequest memory) {\\n        require(args.txns.length > 0, \\\"Bundle: no txns\\\");\\n\\n        bytes memory params =\\n            abi.encodePacked('{\\\"blockNumber\\\": \\\"', LibString.toHexString(args.blockNumber), '\\\", \\\"txs\\\": [');\\n        for (uint256 i = 0; i < args.txns.length; i++) {\\n            params = abi.encodePacked(params, '\\\"', LibString.toHexString(args.txns[i]), '\\\"');\\n            if (i < args.txns.length - 1) {\\n                params = abi.encodePacked(params, \\\",\\\");\\n            } else {\\n                params = abi.encodePacked(params, \\\"]\\\");\\n            }\\n        }\\n        if (args.minTimestamp > 0) {\\n            params = abi.encodePacked(params, ', \\\"minTimestamp\\\": ', LibString.toString(args.minTimestamp));\\n        }\\n        if (args.maxTimestamp > 0) {\\n            params = abi.encodePacked(params, ', \\\"maxTimestamp\\\": ', LibString.toString(args.maxTimestamp));\\n        }\\n        params = abi.encodePacked(params, ', \\\"maxTimestamp\\\": ', LibString.toString(args.maxTimestamp));\\n        params = abi.encodePacked(params, \\\"}\\\");\\n\\n        bytes memory body =\\n            abi.encodePacked('{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"method\\\":\\\"eth_sendBundle\\\",\\\"params\\\":[', params, '],\\\"id\\\":1}');\\n\\n        Suave.HttpRequest memory request;\\n        request.method = \\\"POST\\\";\\n        request.body = body;\\n        request.headers = new string[](1);\\n        request.headers[0] = \\\"Content-Type: application/json\\\";\\n        request.withFlashbotsSignature = true;\\n\\n        return request;\\n    }\\n}\",\"keccak256\":\"0xf5cf91af6fe20a45a901fa5187886f7ebfaf30dc6f7f83471fa697ed93acc684\",\"license\":\"Unlicense\"},\"contracts/libraries/RLPWriter.sol\":{\"content\":\"// Source: https://github.com/flashbots/suave-std/blob/main/src/utils/RLPWriter.sol\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @custom:attribution https://github.com/bakaoh/solidity-rlp-encode\\n * @title RLPWriter\\n * @author RLPWriter is a library for encoding Solidity types to RLP bytes. Adapted from Bakaoh's\\n *         RLPEncode library (https://github.com/bakaoh/solidity-rlp-encode) with minor\\n *         modifications to improve legibility.\\n */\\nlibrary RLPWriter {\\n    /**\\n     * @notice RLP encodes a byte string.\\n     *\\n     * @param _in The byte string to encode.\\n     *\\n     * @return The RLP encoded string in bytes.\\n     */\\n    function writeBytes(bytes memory _in) internal pure returns (bytes memory) {\\n        bytes memory encoded;\\n\\n        if (_in.length == 1 && uint8(_in[0]) < 128) {\\n            encoded = _in;\\n        } else {\\n            encoded = abi.encodePacked(_writeLength(_in.length, 128), _in);\\n        }\\n\\n        return encoded;\\n    }\\n\\n    /**\\n     * @notice RLP encodes a list of RLP encoded byte byte strings.\\n     *\\n     * @param _in The list of RLP encoded byte strings.\\n     *\\n     * @return The RLP encoded list of items in bytes.\\n     */\\n    function writeList(bytes[] memory _in) internal pure returns (bytes memory) {\\n        bytes memory list = _flatten(_in);\\n        return abi.encodePacked(_writeLength(list.length, 192), list);\\n    }\\n\\n    /**\\n     * @notice RLP encodes a string.\\n     *\\n     * @param _in The string to encode.\\n     *\\n     * @return The RLP encoded string in bytes.\\n     */\\n    function writeString(string memory _in) internal pure returns (bytes memory) {\\n        return writeBytes(bytes(_in));\\n    }\\n\\n    /**\\n     * @notice RLP encodes an address.\\n     *\\n     * @param _in The address to encode.\\n     *\\n     * @return The RLP encoded address in bytes.\\n     */\\n    function writeAddress(address _in) internal pure returns (bytes memory) {\\n        return writeBytes(abi.encodePacked(_in));\\n    }\\n\\n    /**\\n     * @notice RLP encodes a uint.\\n     *\\n     * @param _in The uint256 to encode.\\n     *\\n     * @return The RLP encoded uint256 in bytes.\\n     */\\n    function writeUint(uint256 _in) internal pure returns (bytes memory) {\\n        return writeBytes(_toBinary(_in));\\n    }\\n\\n    /**\\n     * @notice RLP encodes a bool.\\n     *\\n     * @param _in The bool to encode.\\n     *\\n     * @return The RLP encoded bool in bytes.\\n     */\\n    function writeBool(bool _in) internal pure returns (bytes memory) {\\n        bytes memory encoded = new bytes(1);\\n        encoded[0] = (_in ? bytes1(0x01) : bytes1(0x80));\\n        return encoded;\\n    }\\n\\n    /**\\n     * @notice Encode the first byte and then the `len` in binary form if `length` is more than 55.\\n     *\\n     * @param _len    The length of the string or the payload.\\n     * @param _offset 128 if item is string, 192 if item is list.\\n     *\\n     * @return RLP encoded bytes.\\n     */\\n    function _writeLength(uint256 _len, uint256 _offset) private pure returns (bytes memory) {\\n        bytes memory encoded;\\n\\n        if (_len < 56) {\\n            encoded = new bytes(1);\\n            encoded[0] = bytes1(uint8(_len) + uint8(_offset));\\n        } else {\\n            uint256 lenLen;\\n            uint256 i = 1;\\n            while (_len / i != 0) {\\n                lenLen++;\\n                i *= 256;\\n            }\\n\\n            encoded = new bytes(lenLen + 1);\\n            encoded[0] = bytes1(uint8(lenLen) + uint8(_offset) + 55);\\n            for (i = 1; i <= lenLen; i++) {\\n                encoded[i] = bytes1(uint8((_len / (256 ** (lenLen - i))) % 256));\\n            }\\n        }\\n\\n        return encoded;\\n    }\\n\\n    /**\\n     * @notice Encode integer in big endian binary form with no leading zeroes.\\n     *\\n     * @param _x The integer to encode.\\n     *\\n     * @return RLP encoded bytes.\\n     */\\n    function _toBinary(uint256 _x) private pure returns (bytes memory) {\\n        bytes memory b = abi.encodePacked(_x);\\n\\n        uint256 i = 0;\\n        for (; i < 32; i++) {\\n            if (b[i] != 0) {\\n                break;\\n            }\\n        }\\n\\n        bytes memory res = new bytes(32 - i);\\n        for (uint256 j = 0; j < res.length; j++) {\\n            res[j] = b[i++];\\n        }\\n\\n        return res;\\n    }\\n\\n    /**\\n     * @custom:attribution https://github.com/Arachnid/solidity-stringutils\\n     * @notice Copies a piece of memory to another location.\\n     *\\n     * @param _dest Destination location.\\n     * @param _src  Source location.\\n     * @param _len  Length of memory to copy.\\n     */\\n    function _memcpy(uint256 _dest, uint256 _src, uint256 _len) private pure {\\n        uint256 dest = _dest;\\n        uint256 src = _src;\\n        uint256 len = _len;\\n\\n        for (; len >= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        uint256 mask;\\n        unchecked {\\n            mask = 256 ** (32 - len) - 1;\\n        }\\n        assembly {\\n            let srcpart := and(mload(src), not(mask))\\n            let destpart := and(mload(dest), mask)\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n    }\\n\\n    /**\\n     * @custom:attribution https://github.com/sammayo/solidity-rlp-encoder\\n     * @notice Flattens a list of byte strings into one byte string.\\n     *\\n     * @param _list List of byte strings to flatten.\\n     *\\n     * @return The flattened byte string.\\n     */\\n    function _flatten(bytes[] memory _list) private pure returns (bytes memory) {\\n        if (_list.length == 0) {\\n            return new bytes(0);\\n        }\\n\\n        uint256 len;\\n        uint256 i = 0;\\n        for (; i < _list.length; i++) {\\n            len += _list[i].length;\\n        }\\n\\n        bytes memory flattened = new bytes(len);\\n        uint256 flattenedPtr;\\n        assembly {\\n            flattenedPtr := add(flattened, 0x20)\\n        }\\n\\n        for (i = 0; i < _list.length; i++) {\\n            bytes memory item = _list[i];\\n\\n            uint256 listPtr;\\n            assembly {\\n                listPtr := add(item, 0x20)\\n            }\\n\\n            _memcpy(flattenedPtr, listPtr, item.length);\\n            flattenedPtr += _list[i].length;\\n        }\\n\\n        return flattened;\\n    }\\n}\",\"keccak256\":\"0x56651ebc297bf3681217d96f035f3f1fdd3027ae64f55087095182c90307f703\",\"license\":\"MIT\"},\"contracts/libraries/Suave.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.8;\\n\\nlibrary Suave {\\n    error PeekerReverted(address, bytes);\\n\\n    enum CryptoSignature {\\n        SECP256,\\n        BLS\\n    }\\n\\n    type DataId is bytes16;\\n\\n    struct BuildBlockArgs {\\n        uint64 slot;\\n        bytes proposerPubkey;\\n        bytes32 parent;\\n        uint64 timestamp;\\n        address feeRecipient;\\n        uint64 gasLimit;\\n        bytes32 random;\\n        Withdrawal[] withdrawals;\\n        bytes extra;\\n        bytes32 parentBeaconBlockRoot;\\n        bool fillPending;\\n    }\\n\\n    struct DataRecord {\\n        DataId id;\\n        DataId salt;\\n        uint64 decryptionCondition;\\n        address[] allowedPeekers;\\n        address[] allowedStores;\\n        string version;\\n    }\\n\\n    struct HttpRequest {\\n        string url;\\n        string method;\\n        string[] headers;\\n        bytes body;\\n        bool withFlashbotsSignature;\\n    }\\n\\n    struct SimulateTransactionResult {\\n        uint64 egp;\\n        SimulatedLog[] logs;\\n        bool success;\\n        string error;\\n    }\\n\\n    struct SimulatedLog {\\n        bytes data;\\n        address addr;\\n        bytes32[] topics;\\n    }\\n\\n    struct Withdrawal {\\n        uint64 index;\\n        uint64 validator;\\n        address Address;\\n        uint64 amount;\\n    }\\n\\n    address public constant ANYALLOWED = 0xC8df3686b4Afb2BB53e60EAe97EF043FE03Fb829;\\n\\n    address public constant IS_CONFIDENTIAL_ADDR = 0x0000000000000000000000000000000042010000;\\n\\n    address public constant BUILD_ETH_BLOCK = 0x0000000000000000000000000000000042100001;\\n\\n    address public constant CONFIDENTIAL_INPUTS = 0x0000000000000000000000000000000042010001;\\n\\n    address public constant CONFIDENTIAL_RETRIEVE = 0x0000000000000000000000000000000042020001;\\n\\n    address public constant CONFIDENTIAL_STORE = 0x0000000000000000000000000000000042020000;\\n\\n    address public constant DO_HTTPREQUEST = 0x0000000000000000000000000000000043200002;\\n\\n    address public constant ETHstaticcall = 0x0000000000000000000000000000000042100003;\\n\\n    address public constant EXTRACT_HINT = 0x0000000000000000000000000000000042100037;\\n\\n    address public constant FETCH_DATA_RECORDS = 0x0000000000000000000000000000000042030001;\\n\\n    address public constant FILL_MEV_SHARE_BUNDLE = 0x0000000000000000000000000000000043200001;\\n\\n    address public constant NEW_BUILDER = 0x0000000000000000000000000000000053200001;\\n\\n    address public constant NEW_DATA_RECORD = 0x0000000000000000000000000000000042030000;\\n\\n    address public constant PRIVATE_KEY_GEN = 0x0000000000000000000000000000000053200003;\\n\\n    address public constant SIGN_ETH_TRANSACTION = 0x0000000000000000000000000000000040100001;\\n\\n    address public constant SIGN_MESSAGE = 0x0000000000000000000000000000000040100003;\\n\\n    address public constant SIMULATE_BUNDLE = 0x0000000000000000000000000000000042100000;\\n\\n    address public constant SIMULATE_TRANSACTION = 0x0000000000000000000000000000000053200002;\\n\\n    address public constant SUBMIT_BUNDLE_JSON_RPC = 0x0000000000000000000000000000000043000001;\\n\\n    address public constant SUBMIT_ETH_BLOCK_TO_RELAY = 0x0000000000000000000000000000000042100002;\\n\\n    // Returns whether execution is off- or on-chain\\n    function isConfidential() internal view returns (bool b) {\\n        (bool success, bytes memory isConfidentialBytes) = IS_CONFIDENTIAL_ADDR.staticcall(\\\"\\\");\\n        if (!success) {\\n            revert PeekerReverted(IS_CONFIDENTIAL_ADDR, isConfidentialBytes);\\n        }\\n        assembly {\\n            // Load the length of data (first 32 bytes)\\n            let len := mload(isConfidentialBytes)\\n            // Load the data after 32 bytes, so add 0x20\\n            b := mload(add(isConfidentialBytes, 0x20))\\n        }\\n    }\\n\\n    function buildEthBlock(BuildBlockArgs memory blockArgs, DataId dataId, string memory namespace)\\n        internal\\n        view\\n        returns (bytes memory, bytes memory)\\n    {\\n        (bool success, bytes memory data) = BUILD_ETH_BLOCK.staticcall(abi.encode(blockArgs, dataId, namespace));\\n        if (!success) {\\n            revert PeekerReverted(BUILD_ETH_BLOCK, data);\\n        }\\n\\n        return abi.decode(data, (bytes, bytes));\\n    }\\n\\n    function confidentialInputs() internal view returns (bytes memory) {\\n        (bool success, bytes memory data) = CONFIDENTIAL_INPUTS.staticcall(abi.encode());\\n        if (!success) {\\n            revert PeekerReverted(CONFIDENTIAL_INPUTS, data);\\n        }\\n\\n        return data;\\n    }\\n\\n    function confidentialRetrieve(DataId dataId, string memory key) internal view returns (bytes memory) {\\n        (bool success, bytes memory data) = CONFIDENTIAL_RETRIEVE.staticcall(abi.encode(dataId, key));\\n        if (!success) {\\n            revert PeekerReverted(CONFIDENTIAL_RETRIEVE, data);\\n        }\\n\\n        return data;\\n    }\\n\\n    function confidentialStore(DataId dataId, string memory key, bytes memory value) internal view {\\n        (bool success, bytes memory data) = CONFIDENTIAL_STORE.staticcall(abi.encode(dataId, key, value));\\n        if (!success) {\\n            revert PeekerReverted(CONFIDENTIAL_STORE, data);\\n        }\\n    }\\n\\n    function doHTTPRequest(HttpRequest memory request) internal view returns (bytes memory) {\\n        (bool success, bytes memory data) = DO_HTTPREQUEST.staticcall(abi.encode(request));\\n        if (!success) {\\n            revert PeekerReverted(DO_HTTPREQUEST, data);\\n        }\\n\\n        return abi.decode(data, (bytes));\\n    }\\n\\n    function ethstaticcall(address contractAddr, bytes memory input1) internal view returns (bytes memory) {\\n        (bool success, bytes memory data) = ETHstaticcall.staticcall(abi.encode(contractAddr, input1));\\n        if (!success) {\\n            revert PeekerReverted(ETHstaticcall, data);\\n        }\\n\\n        return abi.decode(data, (bytes));\\n    }\\n\\n    function extractHint(bytes memory bundleData) internal view returns (bytes memory) {\\n        require(isConfidential());\\n        (bool success, bytes memory data) = EXTRACT_HINT.staticcall(abi.encode(bundleData));\\n        if (!success) {\\n            revert PeekerReverted(EXTRACT_HINT, data);\\n        }\\n\\n        return data;\\n    }\\n\\n    function fetchDataRecords(uint64 cond, string memory namespace) internal view returns (DataRecord[] memory) {\\n        (bool success, bytes memory data) = FETCH_DATA_RECORDS.staticcall(abi.encode(cond, namespace));\\n        if (!success) {\\n            revert PeekerReverted(FETCH_DATA_RECORDS, data);\\n        }\\n\\n        return abi.decode(data, (DataRecord[]));\\n    }\\n\\n    function fillMevShareBundle(DataId dataId) internal view returns (bytes memory) {\\n        require(isConfidential());\\n        (bool success, bytes memory data) = FILL_MEV_SHARE_BUNDLE.staticcall(abi.encode(dataId));\\n        if (!success) {\\n            revert PeekerReverted(FILL_MEV_SHARE_BUNDLE, data);\\n        }\\n\\n        return data;\\n    }\\n\\n    function newBuilder() internal view returns (string memory) {\\n        (bool success, bytes memory data) = NEW_BUILDER.staticcall(abi.encode());\\n        if (!success) {\\n            revert PeekerReverted(NEW_BUILDER, data);\\n        }\\n\\n        return abi.decode(data, (string));\\n    }\\n\\n    function newDataRecord(\\n        uint64 decryptionCondition,\\n        address[] memory allowedPeekers,\\n        address[] memory allowedStores,\\n        string memory dataType\\n    ) internal view returns (DataRecord memory) {\\n        (bool success, bytes memory data) =\\n            NEW_DATA_RECORD.staticcall(abi.encode(decryptionCondition, allowedPeekers, allowedStores, dataType));\\n        if (!success) {\\n            revert PeekerReverted(NEW_DATA_RECORD, data);\\n        }\\n\\n        return abi.decode(data, (DataRecord));\\n    }\\n\\n    function privateKeyGen(CryptoSignature crypto) internal view returns (string memory) {\\n        (bool success, bytes memory data) = PRIVATE_KEY_GEN.staticcall(abi.encode(crypto));\\n        if (!success) {\\n            revert PeekerReverted(PRIVATE_KEY_GEN, data);\\n        }\\n\\n        return abi.decode(data, (string));\\n    }\\n\\n    function signEthTransaction(bytes memory txn, string memory chainId, string memory signingKey)\\n        internal\\n        view\\n        returns (bytes memory)\\n    {\\n        (bool success, bytes memory data) = SIGN_ETH_TRANSACTION.staticcall(abi.encode(txn, chainId, signingKey));\\n        if (!success) {\\n            revert PeekerReverted(SIGN_ETH_TRANSACTION, data);\\n        }\\n\\n        return abi.decode(data, (bytes));\\n    }\\n\\n    function signMessage(bytes memory digest, CryptoSignature crypto, string memory signingKey)\\n        internal\\n        view\\n        returns (bytes memory)\\n    {\\n        require(isConfidential());\\n        (bool success, bytes memory data) = SIGN_MESSAGE.staticcall(abi.encode(digest, crypto, signingKey));\\n        if (!success) {\\n            revert PeekerReverted(SIGN_MESSAGE, data);\\n        }\\n\\n        return abi.decode(data, (bytes));\\n    }\\n\\n    function simulateBundle(bytes memory bundleData) internal view returns (uint64) {\\n        (bool success, bytes memory data) = SIMULATE_BUNDLE.staticcall(abi.encode(bundleData));\\n        if (!success) {\\n            revert PeekerReverted(SIMULATE_BUNDLE, data);\\n        }\\n\\n        return abi.decode(data, (uint64));\\n    }\\n\\n    function simulateTransaction(string memory sessionid, bytes memory txn)\\n        internal\\n        view\\n        returns (SimulateTransactionResult memory)\\n    {\\n        (bool success, bytes memory data) = SIMULATE_TRANSACTION.staticcall(abi.encode(sessionid, txn));\\n        if (!success) {\\n            revert PeekerReverted(SIMULATE_TRANSACTION, data);\\n        }\\n\\n        return abi.decode(data, (SimulateTransactionResult));\\n    }\\n\\n    function submitBundleJsonRPC(string memory url, string memory method, bytes memory params)\\n        internal\\n        view\\n        returns (bytes memory)\\n    {\\n        require(isConfidential());\\n        (bool success, bytes memory data) = SUBMIT_BUNDLE_JSON_RPC.staticcall(abi.encode(url, method, params));\\n        if (!success) {\\n            revert PeekerReverted(SUBMIT_BUNDLE_JSON_RPC, data);\\n        }\\n\\n        return data;\\n    }\\n\\n    function submitEthBlockToRelay(string memory relayUrl, bytes memory builderBid) internal view returns (bytes memory) {\\n        require(isConfidential());\\n        (bool success, bytes memory data) = SUBMIT_ETH_BLOCK_TO_RELAY.staticcall(abi.encode(relayUrl, builderBid));\\n        if (!success) {\\n            revert PeekerReverted(SUBMIT_ETH_BLOCK_TO_RELAY, data);\\n        }\\n\\n        return data;\\n    }\\n}\\n\",\"keccak256\":\"0x54efb1edf83132bf4b1c7d1df6b370c57a8d2ad7c77c690bcd146df2d8c6d224\",\"license\":\"UNLICENSED\"},\"contracts/libraries/Transactions.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\nimport \\\"./RLPWriter.sol\\\";\\nimport \\\"./Suave.sol\\\";\\nimport \\\"solidity-rlp/contracts/RLPReader.sol\\\";\\n\\nlibrary Transactions {\\n    using RLPReader for RLPReader.RLPItem;\\n    using RLPReader for RLPReader.Iterator;\\n    using RLPReader for bytes;\\n\\n    struct EIP155 {\\n        address to;\\n        uint256 gas;\\n        uint256 gasPrice;\\n        uint256 value;\\n        uint256 nonce;\\n        bytes data;\\n        uint256 chainId;\\n        bytes32 r;\\n        bytes32 s;\\n        uint64 v;\\n    }\\n\\n    struct EIP155Request {\\n        address to;\\n        uint256 gas;\\n        uint256 gasPrice;\\n        uint256 value;\\n        uint256 nonce;\\n        bytes data;\\n        uint256 chainId;\\n    }\\n\\n    struct EIP1559 {\\n        address to;\\n        uint64 gas;\\n        uint64 maxFeePerGas;\\n        uint64 maxPriorityFeePerGas;\\n        uint64 value;\\n        uint64 nonce;\\n        bytes data;\\n        uint64 chainId;\\n        bytes accessList;\\n        bytes32 r;\\n        bytes32 s;\\n        uint64 v;\\n    }\\n\\n    struct EIP1559Request {\\n        address to;\\n        uint64 gas;\\n        uint64 maxFeePerGas;\\n        uint64 maxPriorityFeePerGas;\\n        uint64 value;\\n        uint64 nonce;\\n        bytes data;\\n        uint64 chainId;\\n        bytes accessList;\\n    }\\n\\n    function encodeRLP(EIP155 memory txStruct) internal pure returns (bytes memory) {\\n        bytes[] memory items = new bytes[](9);\\n\\n        items[0] = RLPWriter.writeUint(txStruct.nonce);\\n        items[1] = RLPWriter.writeUint(txStruct.gasPrice);\\n        items[2] = RLPWriter.writeUint(txStruct.gas);\\n\\n        if (txStruct.to == address(0)) {\\n            items[3] = RLPWriter.writeBytes(bytes(\\\"\\\"));\\n        } else {\\n            items[3] = RLPWriter.writeAddress(txStruct.to);\\n        }\\n        items[4] = RLPWriter.writeUint(txStruct.value);\\n        items[5] = RLPWriter.writeBytes(txStruct.data);\\n        items[6] = RLPWriter.writeUint(uint256(txStruct.v));\\n        items[7] = RLPWriter.writeBytes(abi.encodePacked(txStruct.r));\\n        items[8] = RLPWriter.writeBytes(abi.encodePacked(txStruct.s));\\n\\n        return RLPWriter.writeList(items);\\n    }\\n\\n    function encodeRLP(EIP155Request memory txStruct) internal pure returns (bytes memory) {\\n        bytes[] memory items = new bytes[](9);\\n\\n        items[0] = RLPWriter.writeUint(txStruct.nonce);\\n        items[1] = RLPWriter.writeUint(txStruct.gasPrice);\\n        items[2] = RLPWriter.writeUint(txStruct.gas);\\n\\n        if (txStruct.to == address(0)) {\\n            items[3] = RLPWriter.writeBytes(bytes(\\\"\\\"));\\n        } else {\\n            items[3] = RLPWriter.writeAddress(txStruct.to);\\n        }\\n        items[4] = RLPWriter.writeUint(txStruct.value);\\n        items[5] = RLPWriter.writeBytes(txStruct.data);\\n        items[6] = RLPWriter.writeUint(txStruct.chainId);\\n        items[7] = RLPWriter.writeBytes(\\\"\\\");\\n        items[8] = RLPWriter.writeBytes(\\\"\\\");\\n\\n        return RLPWriter.writeList(items);\\n    }\\n\\n    function encodeRLP(EIP1559 memory txStruct) internal pure returns (bytes memory) {\\n        bytes[] memory items = new bytes[](12);\\n\\n        items[0] = RLPWriter.writeUint(txStruct.chainId);\\n        items[1] = RLPWriter.writeUint(txStruct.nonce);\\n        items[2] = RLPWriter.writeUint(txStruct.maxPriorityFeePerGas);\\n        items[3] = RLPWriter.writeUint(txStruct.maxFeePerGas);\\n        items[4] = RLPWriter.writeUint(txStruct.gas);\\n\\n        if (txStruct.to == address(0)) {\\n            items[5] = RLPWriter.writeBytes(bytes(\\\"\\\"));\\n        } else {\\n            items[5] = RLPWriter.writeAddress(txStruct.to);\\n        }\\n\\n        items[6] = RLPWriter.writeUint(txStruct.value);\\n        items[7] = RLPWriter.writeBytes(txStruct.data);\\n\\n        if (txStruct.accessList.length == 0) {\\n            items[8] = hex\\\"c0\\\"; // Empty list encoding\\n        } else {\\n            items[8] = RLPWriter.writeBytes(txStruct.accessList);\\n        }\\n\\n        items[9] = RLPWriter.writeUint(uint256(txStruct.v));\\n        items[10] = RLPWriter.writeBytes(abi.encodePacked(txStruct.r));\\n        items[11] = RLPWriter.writeBytes(abi.encodePacked(txStruct.s));\\n\\n        bytes memory rlpTxn = RLPWriter.writeList(items);\\n\\n        bytes memory txn = new bytes(1 + rlpTxn.length);\\n        txn[0] = 0x02;\\n\\n        for (uint256 i = 0; i < rlpTxn.length; ++i) {\\n            txn[i + 1] = rlpTxn[i];\\n        }\\n\\n        return txn;\\n    }\\n\\n    function encodeRLP(EIP1559Request memory txStruct) internal pure returns (bytes memory) {\\n        bytes[] memory items = new bytes[](9);\\n\\n        items[0] = RLPWriter.writeUint(txStruct.chainId);\\n        items[1] = RLPWriter.writeUint(txStruct.nonce);\\n        items[2] = RLPWriter.writeUint(txStruct.maxPriorityFeePerGas);\\n        items[3] = RLPWriter.writeUint(txStruct.maxFeePerGas);\\n        items[4] = RLPWriter.writeUint(txStruct.gas);\\n\\n        if (txStruct.to == address(0)) {\\n            items[5] = RLPWriter.writeBytes(bytes(\\\"\\\"));\\n        } else {\\n            items[5] = RLPWriter.writeAddress(txStruct.to);\\n        }\\n\\n        items[6] = RLPWriter.writeUint(txStruct.value);\\n        items[7] = RLPWriter.writeBytes(txStruct.data);\\n\\n        if (txStruct.accessList.length == 0) {\\n            items[8] = hex\\\"c0\\\"; // Empty list encoding\\n        } else {\\n            items[8] = RLPWriter.writeBytes(txStruct.accessList);\\n        }\\n\\n        bytes memory rlpTxn = RLPWriter.writeList(items);\\n\\n        bytes memory txn = new bytes(1 + rlpTxn.length);\\n        txn[0] = 0x02;\\n\\n        for (uint256 i = 0; i < rlpTxn.length; ++i) {\\n            txn[i + 1] = rlpTxn[i];\\n        }\\n\\n        return txn;\\n    }\\n\\n    function decodeRLP_EIP155(bytes memory rlp) internal pure returns (EIP155 memory) {\\n        EIP155 memory txStruct;\\n\\n        RLPReader.RLPItem[] memory ls = rlp.toRlpItem().toList();\\n        require(ls.length == 9, \\\"invalid transaction\\\");\\n\\n        txStruct.nonce = uint64(ls[0].toUint());\\n        txStruct.gasPrice = uint64(ls[1].toUint());\\n        txStruct.gas = uint64(ls[2].toUint());\\n\\n        if (ls[3].toRlpBytes().length == 1) {\\n            txStruct.to = address(0);\\n        } else {\\n            txStruct.to = ls[3].toAddress();\\n        }\\n\\n        txStruct.value = uint64(ls[4].toUint());\\n        txStruct.data = ls[5].toBytes();\\n        txStruct.v = uint64(ls[6].toUint());\\n        txStruct.r = bytesToBytes32(ls[7].toBytes());\\n        txStruct.s = bytesToBytes32(ls[8].toBytes());\\n\\n        return txStruct;\\n    }\\n\\n    function decodeRLP_EIP155Request(bytes memory rlp) internal pure returns (EIP155Request memory) {\\n        EIP155Request memory txStruct;\\n\\n        RLPReader.RLPItem[] memory ls = rlp.toRlpItem().toList();\\n        require(ls.length == 9, \\\"invalid transaction\\\");\\n\\n        txStruct.nonce = ls[0].toUint();\\n        txStruct.gasPrice = ls[1].toUint();\\n        txStruct.gas = ls[2].toUint();\\n\\n        if (ls[3].toRlpBytes().length == 1) {\\n            txStruct.to = address(0);\\n        } else {\\n            txStruct.to = ls[3].toAddress();\\n        }\\n\\n        txStruct.value = ls[4].toUint();\\n        txStruct.data = ls[5].toBytes();\\n        txStruct.chainId = uint64(ls[6].toUint());\\n\\n        return txStruct;\\n    }\\n\\n    function decodeRLP_EIP1559(bytes memory rlp) internal pure returns (EIP1559 memory) {\\n        EIP1559 memory txStruct;\\n\\n        bytes memory rlpWithoutPrefix = new bytes(rlp.length - 1);\\n\\n        for (uint256 i = 0; i < rlp.length - 1; ++i) {\\n            rlpWithoutPrefix[i] = rlp[i + 1];\\n        }\\n\\n        RLPReader.RLPItem[] memory ls = rlpWithoutPrefix.toRlpItem().toList();\\n        require(ls.length == 12, \\\"invalid transaction\\\");\\n\\n        txStruct.chainId = uint64(ls[0].toUint());\\n        txStruct.nonce = uint64(ls[1].toUint());\\n        txStruct.maxPriorityFeePerGas = uint64(ls[2].toUint());\\n        txStruct.maxFeePerGas = uint64(ls[3].toUint());\\n        txStruct.gas = uint64(ls[4].toUint());\\n\\n        if (ls[5].toRlpBytes().length == 1) {\\n            txStruct.to = address(0);\\n        } else {\\n            txStruct.to = ls[5].toAddress();\\n        }\\n\\n        txStruct.value = uint64(ls[6].toUint());\\n        txStruct.data = ls[7].toBytes();\\n        txStruct.accessList = ls[8].toBytes();\\n        txStruct.v = uint64(ls[9].toUint());\\n        txStruct.r = bytesToBytes32(ls[10].toBytes());\\n        txStruct.s = bytesToBytes32(ls[11].toBytes());\\n\\n        return txStruct;\\n    }\\n\\n    function decodeRLP_EIP1559Request(bytes memory rlp) internal pure returns (EIP1559Request memory) {\\n        EIP1559Request memory txStruct;\\n\\n        bytes memory rlpWithoutPrefix = new bytes(rlp.length - 1);\\n\\n        for (uint256 i = 0; i < rlp.length - 1; ++i) {\\n            rlpWithoutPrefix[i] = rlp[i + 1];\\n        }\\n\\n        RLPReader.RLPItem[] memory ls = rlpWithoutPrefix.toRlpItem().toList();\\n        require(ls.length == 8, \\\"invalid transaction\\\");\\n\\n        txStruct.chainId = uint64(ls[0].toUint());\\n        txStruct.nonce = uint64(ls[1].toUint());\\n        txStruct.maxPriorityFeePerGas = uint64(ls[2].toUint());\\n        txStruct.maxFeePerGas = uint64(ls[3].toUint());\\n        txStruct.gas = uint64(ls[4].toUint());\\n\\n        if (ls[5].toRlpBytes().length == 1) {\\n            txStruct.to = address(0);\\n        } else {\\n            txStruct.to = ls[5].toAddress();\\n        }\\n\\n        txStruct.value = uint64(ls[6].toUint());\\n        txStruct.data = ls[7].toBytes();\\n\\n        return txStruct;\\n    }\\n\\n    function bytesToBytes32(bytes memory inBytes) internal pure returns (bytes32 out) {\\n        require(inBytes.length == 32, \\\"bytesToBytes32: invalid input length\\\");\\n        assembly {\\n            out := mload(add(inBytes, 32))\\n        }\\n    }\\n\\n    function signTxn(Transactions.EIP1559Request memory request, string memory signingKey)\\n        internal\\n        view\\n        returns (Transactions.EIP1559 memory response)\\n    {\\n        bytes memory rlp = Transactions.encodeRLP(request);\\n        bytes memory hash = abi.encodePacked(keccak256(rlp));\\n        bytes memory signature = Suave.signMessage(hash, Suave.CryptoSignature.SECP256, signingKey);\\n        (uint8 v, bytes32 r, bytes32 s) = decodeSignature(signature);\\n\\n        response.to = request.to;\\n        response.gas = request.gas;\\n        response.maxFeePerGas = request.maxFeePerGas;\\n        response.maxPriorityFeePerGas = request.maxPriorityFeePerGas;\\n        response.value = request.value;\\n        response.nonce = request.nonce;\\n        response.data = request.data;\\n        response.chainId = request.chainId;\\n        response.accessList = request.accessList;\\n        response.v = v;\\n        response.r = r;\\n        response.s = s;\\n\\n        return response;\\n    }\\n\\n    function signTxn(Transactions.EIP155Request memory request, string memory signingKey)\\n        internal\\n        view\\n        returns (Transactions.EIP155 memory response)\\n    {\\n        bytes memory rlp = Transactions.encodeRLP(request);\\n        bytes memory hash = abi.encodePacked(keccak256(rlp));\\n        bytes memory signature = Suave.signMessage(hash, Suave.CryptoSignature.SECP256, signingKey);\\n\\n        // TODO: check overflow\\n        uint64 chainIdMul = uint64(request.chainId) * 2;\\n        (uint8 v, bytes32 r, bytes32 s) = decodeSignature(signature);\\n\\n        uint64 v64 = uint64(v) + 35;\\n        v64 += chainIdMul;\\n\\n        response.to = request.to;\\n        response.gas = request.gas;\\n        response.gasPrice = request.gasPrice;\\n        response.value = request.value;\\n        response.nonce = request.nonce;\\n        response.data = request.data;\\n        response.chainId = request.chainId;\\n        response.v = v64;\\n        response.r = r;\\n        response.s = s;\\n\\n        return response;\\n    }\\n\\n    function decodeSignature(bytes memory signature) public pure returns (uint8 v, bytes32 r, bytes32 s) {\\n        assembly {\\n            r := mload(add(signature, 0x20))\\n            s := mload(add(signature, 0x40))\\n            v := byte(0, mload(add(signature, 0x60)))\\n        }\\n    }\\n}\",\"keccak256\":\"0xf38128cc64664516ee19211e45c79832aff166734a462670d715a05a41b59148\",\"license\":\"Unlicense\"},\"contracts/oracle/BinanceOracle.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// Author: Miha Lotric (halo3mic)\\n\\npragma solidity ^0.8.13;\\n\\nimport { AnyBundleContract, Suave } from \\\"../standard_peekers/bids.sol\\\";\\nimport { SuaveContract } from \\\"../blockad/lib/SuaveContract.sol\\\";\\nimport \\\"../../node_modules/solady/src/utils/JSONParserLib.sol\\\";\\nimport \\\"../libraries/Transactions.sol\\\";\\nimport \\\"../libraries/Bundle.sol\\\";\\nimport \\\"solady/src/utils/LibString.sol\\\";\\n\\n\\ncontract BinanceOracle is SuaveContract {\\n    using JSONParserLib for *;\\n\\n    uint public constant HOLESKY_CHAINID = 17000;\\n    string public constant HOLESKY_CHAINID_STR = \\\"0x4268\\\";\\n    uint8 public constant DECIMALS = 4;\\n    string public constant S_NAMESPACE = \\\"oracle:v0:pksecret\\\";\\n    string public constant REMOTE_HOLESKY_RPC = \\\"https://ethereum-holesky-rpc.publicnode.com\\\";\\n    string public constant URL_PARTIAL = \\\"https://data-api.binance.vision/api/v3/ticker/price?symbol=\\\";\\n    string public constant HOLESKY_BUNDLE_ENDPOINT = \\\"https://relay-holesky.flashbots.net\\\";\\n    \\n    bool isInitialized;\\n    Suave.DataId public pkBidId;\\n    address public controller;\\n    address public settlementContract;\\n\\n    event PriceSubmission(string ticker, uint price);\\n\\n    // \\u26d3\\ufe0f EVM Methods\\n\\n    function confidentialConstructorCallback(\\n        Suave.DataId _pkBidId, \\n        address pkAddress\\n    ) public {\\n        crequire(!isInitialized, \\\"Already initialized\\\");\\n        pkBidId = _pkBidId;\\n        controller = pkAddress;\\n        isInitialized = true;\\n    }\\n\\n    function registerCallback(address _settlementContract) public {\\n        require(settlementContract == address(0), \\\"Already registered\\\");\\n        settlementContract = _settlementContract;\\n    }\\n\\n    // ! Warning: This method is not restricted and emitted events should not be relied upon\\n    function queryAndSubmitCallback(string memory ticker, uint price) public {\\n        emit PriceSubmission(ticker, price);\\n    }\\n\\n    fallback() external payable {\\n        // Needed to accept MEVM calls with no callbacks\\n    }\\n\\n    // \\ud83e\\udd10 MEVM Methods\\n\\n    function confidentialConstructor() external view onlyConfidential returns (bytes memory) {\\n        crequire(!isInitialized, \\\"Already initialized\\\");\\n\\n        string memory pk = Suave.privateKeyGen(Suave.CryptoSignature.SECP256);\\n        address pkAddress = getAddressForPk(pk);\\n\\t\\tSuave.DataId bidId = storePK(bytes(pk));\\n\\n        return abi.encodeWithSelector(\\n            this.confidentialConstructorCallback.selector, \\n            bidId, \\n            pkAddress\\n        );\\n    }\\n\\n    function registerSettlementContract(\\n        address _settlementContract\\n    ) external view onlyConfidential() returns (bytes memory) {\\n        // Allow multiple registrations for the same address (consider the intial tx is not commited to the chain)\\n        require(_settlementContract == settlementContract || settlementContract == address(0), \\\"Already registered\\\");\\n        bytes memory signedTx = createRegisterTx(_settlementContract);\\n        sendRawTx(signedTx);\\n        return abi.encodeWithSelector(this.registerCallback.selector, _settlementContract);\\n    }\\n\\n    function queryAndSubmit(\\n        string memory ticker,\\n        uint nonce,\\n        uint gasPrice,\\n        uint64 settlementBlockNum,\\n        bool privateSubmission\\n    ) external view onlyConfidential returns (bytes memory) {\\n        uint price = queryLatestPrice(ticker);\\n        submitPriceUpdate(ticker, price, nonce, gasPrice, settlementBlockNum, privateSubmission);\\n        return abi.encodeWithSelector(this.queryAndSubmitCallback.selector, ticker, price);\\n    }\\n\\n    function queryLatestPrice(string memory ticker) public view returns (uint price) {\\n        bytes memory response = doBinanceQuery(ticker);\\n        JSONParserLib.Item memory parsedRes = string(response).parse();\\n        // solhint-disable-next-line\\n        string memory priceStr = string(parsedRes.at('\\\"price\\\"').value());\\n        price = floatToInt(trimStrEdges(priceStr), DECIMALS);\\n    }\\n\\n    function submitPriceUpdate(\\n        string memory ticker,\\n        uint price, \\n        uint nonce,\\n        uint gasPrice,\\n        uint64 settlementBlockNum,\\n        bool privateSubmission\\n    ) internal view {\\n        bytes memory signedTx = createPriceUpdateTx(ticker, price, nonce, gasPrice);\\n        if (privateSubmission) {\\n            sendBundle(signedTx, settlementBlockNum);\\n        } else {\\n            sendRawTx(signedTx);\\n        }\\n    }\\n\\n    function createRegisterTx(address _settlementContract) internal view returns (bytes memory txSigned) {\\n        Transactions.EIP155 memory transaction = Transactions.EIP155({\\n            nonce: 0,\\n            gasPrice: 100 gwei,\\n            gas: 100_000,\\n            to: _settlementContract,\\n            value: 0,\\n            data: abi.encodeWithSignature(\\\"register()\\\"),\\n            chainId: HOLESKY_CHAINID,\\n            v: 27,\\n            r: hex\\\"1111111111111111111111111111111111111111111111111111111111111111\\\",\\n            s: hex\\\"1111111111111111111111111111111111111111111111111111111111111111\\\"\\n        });\\n        bytes memory txRlp = Transactions.encodeRLP(transaction);\\n        string memory pk = retreivePK();\\n        txSigned = Suave.signEthTransaction(txRlp, HOLESKY_CHAINID_STR, pk);\\n    }\\n\\n    function createPriceUpdateTx(\\n        string memory ticker, \\n        uint price, \\n        uint nonce, \\n        uint gasPrice\\n    ) internal view returns (bytes memory txSigned)  {\\n        Transactions.EIP155 memory transaction = Transactions.EIP155({\\n            nonce: nonce,\\n            gasPrice: gasPrice,\\n            gas: 100_000,\\n            to: settlementContract,\\n            value: 0,\\n            data: abi.encodeWithSignature(\\\"updatePrice(string,uint256)\\\", ticker, price),\\n            chainId: HOLESKY_CHAINID,\\n            v: 27,\\n            r: hex\\\"1111111111111111111111111111111111111111111111111111111111111111\\\",\\n            s: hex\\\"1111111111111111111111111111111111111111111111111111111111111111\\\"\\n        });\\n        bytes memory txRlp = Transactions.encodeRLP(transaction);\\n        string memory pk = retreivePK();\\n        txSigned = Suave.signEthTransaction(txRlp, HOLESKY_CHAINID_STR, pk);\\n    }\\n\\n    function sendRawTx(bytes memory txSigned) public view returns (bytes memory) {\\n        /* solhint-disable */\\n        bytes memory body = abi.encodePacked(\\n            '{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"method\\\":\\\"eth_sendRawTransaction\\\",\\\"params\\\":[\\\"', \\n            LibString.toHexString(txSigned), \\n            '\\\"],\\\"id\\\":1}'\\n        );\\n        /* solhint-enable */\\n        Suave.HttpRequest memory request;\\n        request.method = \\\"POST\\\";\\n        request.body = body;\\n        request.headers = new string[](1);\\n        request.headers[0] = \\\"Content-Type: application/json\\\";\\n        request.withFlashbotsSignature = false;\\n        request.url = REMOTE_HOLESKY_RPC;\\n        return doHttpRequest(request);\\n    }\\n\\n    function sendBundle(bytes memory txSigned, uint64 settlementBlockNum) internal view {\\n        simulateTx(txSigned);\\n        sendTxViaBundle(txSigned, settlementBlockNum);\\n    }\\n\\n    function simulateTx(bytes memory signedTx) internal view {\\n        // solhint-disable-next-line\\n        bytes memory bundle = abi.encodePacked('{\\\"txs\\\": [\\\"', LibString.toHexString(signedTx), '\\\"]}');\\n        (bool successSim, bytes memory data) = Suave.SIMULATE_BUNDLE.staticcall(abi.encode(bundle));\\n        crequire(successSim,  string(abi.encodePacked(\\\"BundleSimulationFailed: \\\", string(data))));\\n    }\\n\\n    function doBinanceQuery(string memory ticker) internal view returns (bytes memory) {\\n        string[] memory headers = new string[](1);\\n        headers[0] = \\\"Content-Type: application/json\\\";\\n        Suave.HttpRequest memory request = Suave.HttpRequest({\\n            url: string(abi.encodePacked(URL_PARTIAL, ticker)),\\n            method: \\\"GET\\\",\\n            headers: headers,\\n            body: new bytes(0),\\n            withFlashbotsSignature: false\\n        });\\n        return doHttpRequest(request);\\n    }\\n\\n    function doHttpRequest(Suave.HttpRequest memory request) internal view returns (bytes memory) {\\n        (bool success, bytes memory data) = Suave.DO_HTTPREQUEST.staticcall(abi.encode(request));\\n        crequire(success, string(data));\\n        return abi.decode(data, (bytes));\\n    }\\n\\n    function sendTxViaBundle(bytes memory txSigned, uint64 settlementBlockNum) internal view {\\n        bytes[] memory txns = new bytes[](1);\\n        txns[0] = txSigned;\\n        bytes memory bundleReqParams = bundleRequestParams(txns, settlementBlockNum);\\n        (bool successReq, bytes memory dataReq) = Suave.SUBMIT_BUNDLE_JSON_RPC.staticcall(abi.encode(\\n            HOLESKY_BUNDLE_ENDPOINT, \\n            \\\"eth_sendBundle\\\", \\n            bundleReqParams\\n        ));\\n        crequire(successReq, string(abi.encodePacked(\\\"BundleSubmissionFailed: \\\", string(dataReq))));\\n    }\\n\\n    function bundleRequestParams(bytes[] memory txns, uint blockNumber) internal pure returns (bytes memory) {\\n        // solhint-disable-next-line\\n        bytes memory params = abi.encodePacked('{\\\"blockNumber\\\": \\\"', LibString.toHexString(blockNumber), '\\\", \\\"txs\\\": [');\\n        for (uint256 i = 0; i < txns.length; i++) {\\n            // solhint-disable-next-line\\n            params = abi.encodePacked(params, '\\\"', LibString.toHexString(txns[i]), '\\\"');\\n            if (i < txns.length - 1) {\\n                params = abi.encodePacked(params, \\\",\\\");\\n            } else {\\n                params = abi.encodePacked(params, \\\"]\\\");\\n            }\\n        }\\n        params = abi.encodePacked(params, \\\"}\\\");\\n\\n        return params;\\n    }\\n\\n    function storePK(bytes memory pk) internal view returns (Suave.DataId) {\\n\\t\\taddress[] memory peekers = new address[](3);\\n\\t\\tpeekers[0] = address(this);\\n\\t\\tpeekers[1] = Suave.FETCH_DATA_RECORDS;\\n\\t\\tpeekers[2] = Suave.CONFIDENTIAL_RETRIEVE;\\n\\t\\tSuave.DataRecord memory secretBid = Suave.newDataRecord(0, peekers, peekers, S_NAMESPACE);\\n\\t\\tSuave.confidentialStore(secretBid.id, S_NAMESPACE, pk);\\n\\t\\treturn secretBid.id;\\n\\t}\\n\\n    function retreivePK() internal view returns (string memory) {\\n        bytes memory pkBytes =  Suave.confidentialRetrieve(pkBidId, S_NAMESPACE);\\n        return string(pkBytes);\\n    }\\n\\n}\\n\\n// \\ud83d\\udd27 Utils\\n\\nfunction floatToInt(string memory floatString, uint8 decimals) pure returns (uint) {\\n    bytes memory stringBytes = bytes(floatString);\\n    uint dotPosition;\\n    \\n    // Find the position of the dot\\n    for (uint i = 0; i < stringBytes.length; i++) {\\n        if (stringBytes[i] == 0x2E) {\\n            dotPosition = i;\\n            break;\\n        }\\n    }\\n    \\n    uint integerPart = 0;\\n    uint decimalPart = 0;\\n    uint tenPower = 1;\\n    \\n    // Convert integer part\\n    for (uint i = dotPosition; i > 0; i--) {\\n        integerPart += (uint8(stringBytes[i - 1]) - 48) * tenPower;\\n        tenPower *= 10;\\n    }\\n    // Reset power of ten\\n    tenPower = 1;\\n    // Convert decimal part\\n    for (uint i = dotPosition+decimals; i > dotPosition; i--) {\\n        decimalPart += (uint8(stringBytes[i]) - 48) * tenPower;\\n        tenPower *= 10;\\n    }\\n    // Combine integer and decimal parts\\n    return integerPart * (10**decimals) + decimalPart;\\n}\\n\\nfunction trimStrEdges(string memory _input) pure returns (string memory) {\\n    bytes memory input = bytes(_input);\\n    require(input.length > 2, \\\"Input too short\\\");\\n\\n    uint newLength = input.length - 2;\\n    bytes memory result = new bytes(newLength);\\n\\n    assembly {\\n        let inputPtr := add(input, 0x21)\\n        let resultPtr := add(result, 0x20)\\n        let length := mload(input)\\n        mstore(resultPtr, mload(inputPtr))\\n        mstore(result, newLength)\\n    }\\n    return string(result);\\n}\\n\\nfunction getAddressForPk(string memory pk) view returns (address) {\\n    bytes32 digest = keccak256(abi.encode(\\\"yo\\\"));\\n    bytes memory sig = Suave.signMessage(abi.encodePacked(digest), Suave.CryptoSignature.SECP256, pk);\\n    return recoverSigner(digest, sig);\\n}\\n\\nfunction recoverSigner(bytes32 _ethSignedMessageHash, bytes memory _signature) pure returns (address) {\\n    (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);\\n    return ecrecover(_ethSignedMessageHash, v, r, s);\\n}\\n\\nfunction splitSignature(bytes memory sig) pure returns (bytes32 r, bytes32 s, uint8 v) {\\n    require(sig.length == 65, \\\"invalid signature length\\\");\\n    assembly {\\n        r := mload(add(sig, 32))\\n        s := mload(add(sig, 64))\\n        v := byte(0, mload(add(sig, 96)))\\n    }\\n    if (v < 27) {\\n        v += 27;\\n    }\\n}\",\"keccak256\":\"0x45ceedfed30dfe3df20e2f904488e274803d58f705510be58a7cd46c1c75773c\",\"license\":\"MIT\"},\"contracts/standard_peekers/bids.sol\":{\"content\":\"pragma solidity ^0.8.8;\\n\\nimport \\\"../libraries/Suave.sol\\\";\\n\\ncontract AnyBundleContract {\\n    event DataRecordEvent(Suave.DataId dataId, uint64 decryptionCondition, address[] allowedPeekers);\\n\\n    function fetchConfidentialBundleData() public returns (bytes memory) {\\n        require(Suave.isConfidential());\\n\\n        bytes memory confidentialInputs = Suave.confidentialInputs();\\n        return abi.decode(confidentialInputs, (bytes));\\n    }\\n\\n    function emitDataRecord(Suave.DataRecord calldata dataRecord) public {\\n        emit DataRecordEvent(dataRecord.id, dataRecord.decryptionCondition, dataRecord.allowedPeekers);\\n    }\\n}\\n\\ncontract BundleContract is AnyBundleContract {\\n    function newBundle(\\n        uint64 decryptionCondition,\\n        address[] memory dataAllowedPeekers,\\n        address[] memory dataAllowedStores\\n    ) external payable returns (bytes memory) {\\n        require(Suave.isConfidential());\\n\\n        bytes memory bundleData = this.fetchConfidentialBundleData();\\n\\n        uint64 egp = Suave.simulateBundle(bundleData);\\n\\n        Suave.DataRecord memory dataRecord =\\n            Suave.newDataRecord(decryptionCondition, dataAllowedPeekers, dataAllowedStores, \\\"default:v0:ethBundles\\\");\\n\\n        Suave.confidentialStore(dataRecord.id, \\\"default:v0:ethBundles\\\", bundleData);\\n        Suave.confidentialStore(dataRecord.id, \\\"default:v0:ethBundleSimResults\\\", abi.encode(egp));\\n\\n        return emitAndReturn(dataRecord, bundleData);\\n    }\\n\\n    function emitAndReturn(Suave.DataRecord memory dataRecord, bytes memory) internal virtual returns (bytes memory) {\\n        emit DataRecordEvent(dataRecord.id, dataRecord.decryptionCondition, dataRecord.allowedPeekers);\\n        return bytes.concat(this.emitDataRecord.selector, abi.encode(dataRecord));\\n    }\\n}\\n\\ncontract EthBundleSenderContract is BundleContract {\\n    string[] public builderUrls;\\n\\n    constructor(string[] memory builderUrls_) {\\n        builderUrls = builderUrls_;\\n    }\\n\\n    function emitAndReturn(Suave.DataRecord memory dataRecord, bytes memory bundleData)\\n        internal\\n        virtual\\n        override\\n        returns (bytes memory)\\n    {\\n        for (uint256 i = 0; i < builderUrls.length; i++) {\\n            Suave.submitBundleJsonRPC(builderUrls[i], \\\"eth_sendBundle\\\", bundleData);\\n        }\\n\\n        return BundleContract.emitAndReturn(dataRecord, bundleData);\\n    }\\n}\\n\\ncontract MevShareContract is AnyBundleContract {\\n    event HintEvent(Suave.DataId dataId, bytes hint);\\n\\n    event MatchEvent(Suave.DataId matchDataId, bytes matchHint);\\n\\n    function newTransaction(\\n        uint64 decryptionCondition,\\n        address[] memory dataAllowedPeekers,\\n        address[] memory dataAllowedStores\\n    ) external payable returns (bytes memory) {\\n        // 0. check confidential execution\\n        require(Suave.isConfidential());\\n\\n        // 1. fetch bundle data\\n        bytes memory bundleData = this.fetchConfidentialBundleData();\\n\\n        // 2. sim bundle\\n        uint64 egp = Suave.simulateBundle(bundleData);\\n\\n        // 3. extract hint\\n        bytes memory hint = Suave.extractHint(bundleData);\\n\\n        // // 4. store bundle and sim results\\n        Suave.DataRecord memory dataRecord = Suave.newDataRecord(\\n            decryptionCondition, dataAllowedPeekers, dataAllowedStores, \\\"mevshare:v0:unmatchedBundles\\\"\\n        );\\n        Suave.confidentialStore(dataRecord.id, \\\"mevshare:v0:ethBundles\\\", bundleData);\\n        Suave.confidentialStore(dataRecord.id, \\\"mevshare:v0:ethBundleSimResults\\\", abi.encode(egp));\\n        emit DataRecordEvent(dataRecord.id, dataRecord.decryptionCondition, dataRecord.allowedPeekers);\\n        emit HintEvent(dataRecord.id, hint);\\n\\n        // // 5. return \\\"callback\\\" to emit hint onchain\\n        return bytes.concat(this.emitDataRecordAndHint.selector, abi.encode(dataRecord, hint));\\n    }\\n\\n    function emitDataRecordAndHint(Suave.DataRecord calldata dataRecord, bytes memory hint) public {\\n        emit DataRecordEvent(dataRecord.id, dataRecord.decryptionCondition, dataRecord.allowedPeekers);\\n        emit HintEvent(dataRecord.id, hint);\\n    }\\n\\n    function newMatch(\\n        uint64 decryptionCondition,\\n        address[] memory dataAllowedPeekers,\\n        address[] memory dataAllowedStores,\\n        Suave.DataId sharedataId\\n    ) external payable returns (bytes memory) {\\n        // WARNING : this function will copy the original mev share bid\\n        // into a new key with potentially different permsissions\\n\\n        require(Suave.isConfidential());\\n        // 1. fetch confidential data\\n        bytes memory matchBundleData = this.fetchConfidentialBundleData();\\n\\n        // 2. sim match alone for validity\\n        uint64 egp = Suave.simulateBundle(matchBundleData);\\n\\n        // 3. extract hint\\n        bytes memory matchHint = Suave.extractHint(matchBundleData);\\n\\n        Suave.DataRecord memory dataRecord = Suave.newDataRecord(\\n            decryptionCondition, dataAllowedPeekers, dataAllowedStores, \\\"mevshare:v0:matchDataRecords\\\"\\n        );\\n        Suave.confidentialStore(dataRecord.id, \\\"mevshare:v0:ethBundles\\\", matchBundleData);\\n        Suave.confidentialStore(dataRecord.id, \\\"mevshare:v0:ethBundleSimResults\\\", abi.encode(0));\\n\\n        //4. merge data records\\n        Suave.DataId[] memory dataRecords = new Suave.DataId[](2);\\n        dataRecords[0] = sharedataId;\\n        dataRecords[1] = dataRecord.id;\\n        Suave.confidentialStore(dataRecord.id, \\\"mevshare:v0:mergedDataRecords\\\", abi.encode(dataRecords));\\n\\n        return emitMatchDataRecordAndHint(dataRecord, matchHint);\\n    }\\n\\n    function emitMatchDataRecordAndHint(Suave.DataRecord memory dataRecord, bytes memory matchHint)\\n        internal\\n        virtual\\n        returns (bytes memory)\\n    {\\n        emit DataRecordEvent(dataRecord.id, dataRecord.decryptionCondition, dataRecord.allowedPeekers);\\n        emit MatchEvent(dataRecord.id, matchHint);\\n\\n        return bytes.concat(this.emitDataRecord.selector, abi.encode(dataRecord));\\n    }\\n}\\n\\ncontract MevShareBundleSenderContract is MevShareContract {\\n    string[] public builderUrls;\\n\\n    constructor(string[] memory builderUrls_) {\\n        builderUrls = builderUrls_;\\n    }\\n\\n    function emitMatchDataRecordAndHint(Suave.DataRecord memory dataRecord, bytes memory matchHint)\\n        internal\\n        virtual\\n        override\\n        returns (bytes memory)\\n    {\\n        bytes memory bundleData = Suave.fillMevShareBundle(dataRecord.id);\\n        for (uint256 i = 0; i < builderUrls.length; i++) {\\n            Suave.submitBundleJsonRPC(builderUrls[i], \\\"mev_sendBundle\\\", bundleData);\\n        }\\n\\n        return MevShareContract.emitMatchDataRecordAndHint(dataRecord, matchHint);\\n    }\\n}\\n\\n/* Not tested or implemented on the precompile side */\\nstruct EgpRecordPair {\\n    uint64 egp; // in wei, beware overflow\\n    Suave.DataId dataId;\\n}\\n\\ncontract EthBlockContract is AnyBundleContract {\\n    event BuilderBoostBidEvent(Suave.DataId dataId, bytes builderBid);\\n\\n    function idsEqual(Suave.DataId _l, Suave.DataId _r) public pure returns (bool) {\\n        bytes memory l = abi.encodePacked(_l);\\n        bytes memory r = abi.encodePacked(_r);\\n        for (uint256 i = 0; i < l.length; i++) {\\n            if (bytes(l)[i] != r[i]) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    function buildMevShare(Suave.BuildBlockArgs memory blockArgs, uint64 blockHeight) public returns (bytes memory) {\\n        require(Suave.isConfidential());\\n\\n        Suave.DataRecord[] memory allShareMatchDataRecords =\\n            Suave.fetchDataRecords(blockHeight, \\\"mevshare:v0:matchDataRecords\\\");\\n        Suave.DataRecord[] memory allShareUserDataRecords =\\n            Suave.fetchDataRecords(blockHeight, \\\"mevshare:v0:unmatchedBundles\\\");\\n\\n        if (allShareUserDataRecords.length == 0) {\\n            revert Suave.PeekerReverted(address(this), \\\"no data records\\\");\\n        }\\n\\n        Suave.DataRecord[] memory allRecords = new Suave.DataRecord[](allShareUserDataRecords.length);\\n        for (uint256 i = 0; i < allShareUserDataRecords.length; i++) {\\n            // TODO: sort matches by egp first!\\n            Suave.DataRecord memory dataRecordToInsert = allShareUserDataRecords[i]; // will be updated with the best match if any\\n            for (uint256 j = 0; j < allShareMatchDataRecords.length; j++) {\\n                // TODO: should be done once at the start and sorted\\n                Suave.DataId[] memory mergeddataIds = abi.decode(\\n                    Suave.confidentialRetrieve(allShareMatchDataRecords[j].id, \\\"mevshare:v0:mergedDataRecords\\\"),\\n                    (Suave.DataId[])\\n                );\\n                if (idsEqual(mergeddataIds[0], allShareUserDataRecords[i].id)) {\\n                    dataRecordToInsert = allShareMatchDataRecords[j];\\n                    break;\\n                }\\n            }\\n            allRecords[i] = dataRecordToInsert;\\n        }\\n\\n        EgpRecordPair[] memory bidsByEGP = new EgpRecordPair[](allRecords.length);\\n        for (uint256 i = 0; i < allRecords.length; i++) {\\n            bytes memory simResults = Suave.confidentialRetrieve(allRecords[i].id, \\\"mevshare:v0:ethBundleSimResults\\\");\\n            uint64 egp = abi.decode(simResults, (uint64));\\n            bidsByEGP[i] = EgpRecordPair(egp, allRecords[i].id);\\n        }\\n\\n        // Bubble sort, cause why not\\n        uint256 n = bidsByEGP.length;\\n        for (uint256 i = 0; i < n - 1; i++) {\\n            for (uint256 j = i + 1; j < n; j++) {\\n                if (bidsByEGP[i].egp < bidsByEGP[j].egp) {\\n                    EgpRecordPair memory temp = bidsByEGP[i];\\n                    bidsByEGP[i] = bidsByEGP[j];\\n                    bidsByEGP[j] = temp;\\n                }\\n            }\\n        }\\n\\n        Suave.DataId[] memory alldataIds = new Suave.DataId[](allRecords.length);\\n        for (uint256 i = 0; i < bidsByEGP.length; i++) {\\n            alldataIds[i] = bidsByEGP[i].dataId;\\n        }\\n\\n        return buildAndEmit(blockArgs, blockHeight, alldataIds, \\\"mevshare:v0\\\");\\n    }\\n\\n    function buildFromPool(Suave.BuildBlockArgs memory blockArgs, uint64 blockHeight) public returns (bytes memory) {\\n        require(Suave.isConfidential());\\n\\n        Suave.DataRecord[] memory allRecords = Suave.fetchDataRecords(blockHeight, \\\"default:v0:ethBundles\\\");\\n        if (allRecords.length == 0) {\\n            revert Suave.PeekerReverted(address(this), \\\"no data records\\\");\\n        }\\n\\n        EgpRecordPair[] memory bidsByEGP = new EgpRecordPair[](allRecords.length);\\n        for (uint256 i = 0; i < allRecords.length; i++) {\\n            bytes memory simResults = Suave.confidentialRetrieve(allRecords[i].id, \\\"default:v0:ethBundleSimResults\\\");\\n            uint64 egp = abi.decode(simResults, (uint64));\\n            bidsByEGP[i] = EgpRecordPair(egp, allRecords[i].id);\\n        }\\n\\n        // Bubble sort, cause why not\\n        uint256 n = bidsByEGP.length;\\n        for (uint256 i = 0; i < n - 1; i++) {\\n            for (uint256 j = i + 1; j < n; j++) {\\n                if (bidsByEGP[i].egp < bidsByEGP[j].egp) {\\n                    EgpRecordPair memory temp = bidsByEGP[i];\\n                    bidsByEGP[i] = bidsByEGP[j];\\n                    bidsByEGP[j] = temp;\\n                }\\n            }\\n        }\\n\\n        Suave.DataId[] memory alldataIds = new Suave.DataId[](allRecords.length);\\n        for (uint256 i = 0; i < bidsByEGP.length; i++) {\\n            alldataIds[i] = bidsByEGP[i].dataId;\\n        }\\n\\n        return buildAndEmit(blockArgs, blockHeight, alldataIds, \\\"\\\");\\n    }\\n\\n    function buildAndEmit(\\n        Suave.BuildBlockArgs memory blockArgs,\\n        uint64 blockHeight,\\n        Suave.DataId[] memory records,\\n        string memory namespace\\n    ) public virtual returns (bytes memory) {\\n        require(Suave.isConfidential());\\n\\n        (Suave.DataRecord memory blockBid, bytes memory builderBid) =\\n            this.doBuild(blockArgs, blockHeight, records, namespace);\\n\\n        emit BuilderBoostBidEvent(blockBid.id, builderBid);\\n        emit DataRecordEvent(blockBid.id, blockBid.decryptionCondition, blockBid.allowedPeekers);\\n        return bytes.concat(this.emitBuilderBidAndBid.selector, abi.encode(blockBid, builderBid));\\n    }\\n\\n    function doBuild(\\n        Suave.BuildBlockArgs memory blockArgs,\\n        uint64 blockHeight,\\n        Suave.DataId[] memory records,\\n        string memory namespace\\n    ) public view returns (Suave.DataRecord memory, bytes memory) {\\n        address[] memory allowedPeekers = new address[](2);\\n        allowedPeekers[0] = address(this);\\n        allowedPeekers[1] = Suave.BUILD_ETH_BLOCK;\\n\\n        Suave.DataRecord memory blockBid =\\n            Suave.newDataRecord(blockHeight, allowedPeekers, allowedPeekers, \\\"default:v0:mergedDataRecords\\\");\\n        Suave.confidentialStore(blockBid.id, \\\"default:v0:mergedDataRecords\\\", abi.encode(records));\\n\\n        (bytes memory builderBid, bytes memory payload) = Suave.buildEthBlock(blockArgs, blockBid.id, namespace);\\n        Suave.confidentialStore(blockBid.id, \\\"default:v0:builderPayload\\\", payload); // only through this.unlock\\n\\n        return (blockBid, builderBid);\\n    }\\n\\n    function emitBuilderBidAndBid(Suave.DataRecord memory dataRecord, bytes memory builderBid)\\n        public\\n        returns (Suave.DataRecord memory, bytes memory)\\n    {\\n        emit BuilderBoostBidEvent(dataRecord.id, builderBid);\\n        emit DataRecordEvent(dataRecord.id, dataRecord.decryptionCondition, dataRecord.allowedPeekers);\\n        return (dataRecord, builderBid);\\n    }\\n\\n    function unlock(Suave.DataId dataId, bytes memory signedBlindedHeader) public view returns (bytes memory) {\\n        require(Suave.isConfidential());\\n\\n        // TODO: verify the header is correct\\n        // TODO: incorporate protocol name\\n        bytes memory payload = Suave.confidentialRetrieve(dataId, \\\"default:v0:builderPayload\\\");\\n        return payload;\\n    }\\n}\\n\\ncontract EthBlockBidSenderContract is EthBlockContract {\\n    string boostRelayUrl;\\n\\n    constructor(string memory boostRelayUrl_) {\\n        boostRelayUrl = boostRelayUrl_;\\n    }\\n\\n    function buildAndEmit(\\n        Suave.BuildBlockArgs memory blockArgs,\\n        uint64 blockHeight,\\n        Suave.DataId[] memory dataRecords,\\n        string memory namespace\\n    ) public virtual override returns (bytes memory) {\\n        require(Suave.isConfidential());\\n\\n        (Suave.DataRecord memory blockDataRecord, bytes memory builderBid) =\\n            this.doBuild(blockArgs, blockHeight, dataRecords, namespace);\\n        Suave.submitEthBlockToRelay(boostRelayUrl, builderBid);\\n\\n        emit DataRecordEvent(blockDataRecord.id, blockDataRecord.decryptionCondition, blockDataRecord.allowedPeekers);\\n        return bytes.concat(this.emitDataRecord.selector, abi.encode(blockDataRecord));\\n    }\\n}\\n\",\"keccak256\":\"0x69d1971b3f0841d3cc7c28122a240b06f1d28d71510bce6a7f915ee392f47918\"},\"node_modules/solady/src/utils/JSONParserLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library for parsing JSONs.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/JSONParserLib.sol)\\nlibrary JSONParserLib {\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The input is invalid.\\n    error ParsingFailed();\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    // There are 6 types of variables in JSON (excluding undefined).\\n\\n    /// @dev For denoting that an item has not been initialized.\\n    /// A item returned from `parse` will never be of an undefined type.\\n    /// Parsing a invalid JSON string will simply revert.\\n    uint8 internal constant TYPE_UNDEFINED = 0;\\n\\n    /// @dev Type representing an array (e.g. `[1,2,3]`).\\n    uint8 internal constant TYPE_ARRAY = 1;\\n\\n    /// @dev Type representing an object (e.g. `{\\\"a\\\":\\\"A\\\",\\\"b\\\":\\\"B\\\"}`).\\n    uint8 internal constant TYPE_OBJECT = 2;\\n\\n    /// @dev Type representing a number (e.g. `-1.23e+21`).\\n    uint8 internal constant TYPE_NUMBER = 3;\\n\\n    /// @dev Type representing a string (e.g. `\\\"hello\\\"`).\\n    uint8 internal constant TYPE_STRING = 4;\\n\\n    /// @dev Type representing a boolean (i.e. `true` or `false`).\\n    uint8 internal constant TYPE_BOOLEAN = 5;\\n\\n    /// @dev Type representing null (i.e. `null`).\\n    uint8 internal constant TYPE_NULL = 6;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                          STRUCTS                           */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev A pointer to a parsed JSON node.\\n    struct Item {\\n        // Do NOT modify the `_data` directly.\\n        uint256 _data;\\n    }\\n\\n    // Private constants for packing `_data`.\\n\\n    uint256 private constant _BITPOS_STRING = 32 * 7 - 8;\\n    uint256 private constant _BITPOS_KEY_LENGTH = 32 * 6 - 8;\\n    uint256 private constant _BITPOS_KEY = 32 * 5 - 8;\\n    uint256 private constant _BITPOS_VALUE_LENGTH = 32 * 4 - 8;\\n    uint256 private constant _BITPOS_VALUE = 32 * 3 - 8;\\n    uint256 private constant _BITPOS_CHILD = 32 * 2 - 8;\\n    uint256 private constant _BITPOS_SIBLING_OR_PARENT = 32 * 1 - 8;\\n    uint256 private constant _BITMASK_POINTER = 0xffffffff;\\n    uint256 private constant _BITMASK_TYPE = 7;\\n    uint256 private constant _KEY_INITED = 1 << 3;\\n    uint256 private constant _VALUE_INITED = 1 << 4;\\n    uint256 private constant _CHILDREN_INITED = 1 << 5;\\n    uint256 private constant _PARENT_IS_ARRAY = 1 << 6;\\n    uint256 private constant _PARENT_IS_OBJECT = 1 << 7;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                   JSON PARSING OPERATION                   */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Parses the JSON string `s`, and returns the root.\\n    /// Reverts if `s` is not a valid JSON as specified in RFC 8259.\\n    /// Object items WILL simply contain all their children, inclusive of repeated keys,\\n    /// in the same order which they appear in the JSON string.\\n    ///\\n    /// Note: For efficiency, this function WILL NOT make a copy of `s`.\\n    /// The parsed tree WILL contain offsets to `s`.\\n    /// Do NOT pass in a string that WILL be modified later on.\\n    function parse(string memory s) internal pure returns (Item memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x40, result) // We will use our own allocation instead.\\n        }\\n        bytes32 r = _query(_toInput(s), 255);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := r\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                    JSON ITEM OPERATIONS                    */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    // Note:\\n    // - An item is a node in the JSON tree.\\n    // - The value of a string item WILL be double-quoted, JSON encoded.\\n    // - We make a distinction between `index` and `key`.\\n    //   - Items in arrays are located by `index` (uint256).\\n    //   - Items in objects are located by `key` (string).\\n    // - Keys are always strings, double-quoted, JSON encoded.\\n    //\\n    // These design choices are made to balance between efficiency and ease-of-use.\\n\\n    /// @dev Returns the string value of the item.\\n    /// This is its exact string representation in the original JSON string.\\n    /// The returned string WILL have leading and trailing whitespace trimmed.\\n    /// All inner whitespace WILL be preserved, exactly as it is in the original JSON string.\\n    /// If the item's type is string, the returned string WILL be double-quoted, JSON encoded.\\n    ///\\n    /// Note: This function lazily instantiates and caches the returned string.\\n    /// Do NOT modify the returned string.\\n    function value(Item memory item) internal pure returns (string memory result) {\\n        bytes32 r = _query(_toInput(item), 0);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := r\\n        }\\n    }\\n\\n    /// @dev Returns the index of the item in the array.\\n    /// It the item's parent is not an array, returns 0.\\n    function index(Item memory item) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if and(mload(item), _PARENT_IS_ARRAY) {\\n                result := and(_BITMASK_POINTER, shr(_BITPOS_KEY, mload(item)))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the key of the item in the object.\\n    /// It the item's parent is not an object, returns an empty string.\\n    /// The returned string WILL be double-quoted, JSON encoded.\\n    ///\\n    /// Note: This function lazily instantiates and caches the returned string.\\n    /// Do NOT modify the returned string.\\n    function key(Item memory item) internal pure returns (string memory result) {\\n        if (item._data & _PARENT_IS_OBJECT != 0) {\\n            bytes32 r = _query(_toInput(item), 1);\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                result := r\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the key of the item in the object.\\n    /// It the item is neither an array nor object, returns an empty array.\\n    ///\\n    /// Note: This function lazily instantiates and caches the returned array.\\n    /// Do NOT modify the returned array.\\n    function children(Item memory item) internal pure returns (Item[] memory result) {\\n        bytes32 r = _query(_toInput(item), 3);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := r\\n        }\\n    }\\n\\n    /// @dev Returns the number of children.\\n    /// It the item is neither an array nor object, returns zero.\\n    function size(Item memory item) internal pure returns (uint256 result) {\\n        bytes32 r = _query(_toInput(item), 3);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(r)\\n        }\\n    }\\n\\n    /// @dev Returns the item at index `i` for (array).\\n    /// If `item` is not an array, the result's type WILL be undefined.\\n    /// If there is no item with the index, the result's type WILL be undefined.\\n    function at(Item memory item, uint256 i) internal pure returns (Item memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x40, result) // Free the default allocation. We'll allocate manually.\\n        }\\n        bytes32 r = _query(_toInput(item), 3);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(add(add(r, 0x20), shl(5, i)))\\n            if iszero(and(lt(i, mload(r)), eq(and(mload(item), _BITMASK_TYPE), TYPE_ARRAY))) {\\n                result := 0x60 // Reset to the zero pointer.\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the item at key `k` for (object).\\n    /// If `item` is not an object, the result's type WILL be undefined.\\n    /// The key MUST be double-quoted, JSON encoded. This is for efficiency reasons.\\n    /// - Correct : `item.at('\\\"k\\\"')`.\\n    /// - Wrong   : `item.at(\\\"k\\\")`.\\n    /// For duplicated keys, the last item with the key WILL be returned.\\n    /// If there is no item with the key, the result's type WILL be undefined.\\n    function at(Item memory item, string memory k) internal pure returns (Item memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x40, result) // Free the default allocation. We'll allocate manually.\\n            result := 0x60 // Initialize to the zero pointer.\\n        }\\n        if (isObject(item)) {\\n            bytes32 kHash = keccak256(bytes(k));\\n            Item[] memory r = children(item);\\n            // We'll just do a linear search. The alternatives are very bloated.\\n            for (uint256 i = r.length << 5; i != 0;) {\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    item := mload(add(r, i))\\n                    i := sub(i, 0x20)\\n                }\\n                if (keccak256(bytes(key(item))) != kHash) continue;\\n                result = item;\\n                break;\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the item's type.\\n    function getType(Item memory item) internal pure returns (uint8 result) {\\n        result = uint8(item._data & _BITMASK_TYPE);\\n    }\\n\\n    /// Note: All types are mutually exclusive.\\n\\n    /// @dev Returns whether the item is of type undefined.\\n    function isUndefined(Item memory item) internal pure returns (bool result) {\\n        result = item._data & _BITMASK_TYPE == TYPE_UNDEFINED;\\n    }\\n\\n    /// @dev Returns whether the item is of type array.\\n    function isArray(Item memory item) internal pure returns (bool result) {\\n        result = item._data & _BITMASK_TYPE == TYPE_ARRAY;\\n    }\\n\\n    /// @dev Returns whether the item is of type object.\\n    function isObject(Item memory item) internal pure returns (bool result) {\\n        result = item._data & _BITMASK_TYPE == TYPE_OBJECT;\\n    }\\n\\n    /// @dev Returns whether the item is of type number.\\n    function isNumber(Item memory item) internal pure returns (bool result) {\\n        result = item._data & _BITMASK_TYPE == TYPE_NUMBER;\\n    }\\n\\n    /// @dev Returns whether the item is of type string.\\n    function isString(Item memory item) internal pure returns (bool result) {\\n        result = item._data & _BITMASK_TYPE == TYPE_STRING;\\n    }\\n\\n    /// @dev Returns whether the item is of type boolean.\\n    function isBoolean(Item memory item) internal pure returns (bool result) {\\n        result = item._data & _BITMASK_TYPE == TYPE_BOOLEAN;\\n    }\\n\\n    /// @dev Returns whether the item is of type null.\\n    function isNull(Item memory item) internal pure returns (bool result) {\\n        result = item._data & _BITMASK_TYPE == TYPE_NULL;\\n    }\\n\\n    /// @dev Returns the item's parent.\\n    /// If the item does not have a parent, the result's type will be undefined.\\n    function parent(Item memory item) internal pure returns (Item memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x40, result) // Free the default allocation. We've already allocated.\\n            result := and(shr(_BITPOS_SIBLING_OR_PARENT, mload(item)), _BITMASK_POINTER)\\n            if iszero(result) { result := 0x60 } // Reset to the zero pointer.\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                     UTILITY FUNCTIONS                      */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Parses an unsigned integer from a string (in decimal, i.e. base 10).\\n    /// Reverts if `s` is not a valid uint256 string matching the RegEx `^[0-9]+$`,\\n    /// or if the parsed number is too big for a uint256.\\n    function parseUint(string memory s) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let n := mload(s)\\n            let preMulOverflowThres := div(not(0), 10)\\n            for { let i := 0 } 1 {} {\\n                i := add(i, 1)\\n                let digit := sub(and(mload(add(s, i)), 0xff), 48)\\n                let mulOverflowed := gt(result, preMulOverflowThres)\\n                let product := mul(10, result)\\n                result := add(product, digit)\\n                n := mul(n, iszero(or(or(mulOverflowed, lt(result, product)), gt(digit, 9))))\\n                if iszero(lt(i, n)) { break }\\n            }\\n            if iszero(n) {\\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Parses a signed integer from a string (in decimal, i.e. base 10).\\n    /// Reverts if `s` is not a valid int256 string matching the RegEx `^[+-]?[0-9]+$`,\\n    /// or if the parsed number cannot fit within `[-2**255 .. 2**255 - 1]`.\\n    function parseInt(string memory s) internal pure returns (int256 result) {\\n        uint256 n = bytes(s).length;\\n        uint256 sign;\\n        uint256 isNegative;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if n {\\n                let c := and(mload(add(s, 1)), 0xff)\\n                isNegative := eq(c, 45)\\n                if or(eq(c, 43), isNegative) {\\n                    sign := c\\n                    s := add(s, 1)\\n                    mstore(s, sub(n, 1))\\n                }\\n                if iszero(or(sign, lt(sub(c, 48), 10))) { s := 0x60 }\\n            }\\n        }\\n        uint256 x = parseUint(s);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(lt(x, add(shl(255, 1), isNegative))) {\\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if sign {\\n                mstore(s, sign)\\n                s := sub(s, 1)\\n                mstore(s, n)\\n            }\\n            result := xor(x, mul(xor(x, add(not(x), 1)), isNegative))\\n        }\\n    }\\n\\n    /// @dev Parses an unsigned integer from a string (in hexadecimal, i.e. base 16).\\n    /// Reverts if `s` is not a valid uint256 hex string matching the RegEx\\n    /// `^(0[xX])?[0-9a-fA-F]+$`, or if the parsed number cannot fit within `[0 .. 2**256 - 1]`.\\n    function parseUintFromHex(string memory s) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let n := mload(s)\\n            // Skip two if starts with '0x' or '0X'.\\n            let i := shl(1, and(eq(0x3078, or(shr(240, mload(add(s, 0x20))), 0x20)), gt(n, 1)))\\n            for {} 1 {} {\\n                i := add(i, 1)\\n                let c :=\\n                    byte(\\n                        and(0x1f, shr(and(mload(add(s, i)), 0xff), 0x3e4088843e41bac000000000000)),\\n                        0x3010a071000000b0104040208000c05090d060e0f\\n                    )\\n                n := mul(n, iszero(or(iszero(c), shr(252, result))))\\n                result := add(shl(4, result), sub(c, 1))\\n                if iszero(lt(i, n)) { break }\\n            }\\n            if iszero(n) {\\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Decodes a JSON encoded string.\\n    /// The string MUST be double-quoted, JSON encoded.\\n    /// Reverts if the string is invalid.\\n    /// As you can see, it's pretty complex for a deceptively simple looking task.\\n    function decodeString(string memory s) internal pure returns (string memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            function fail() {\\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n\\n            function decodeUnicodeEscapeSequence(pIn_, end_) -> _unicode, _pOut {\\n                _pOut := add(pIn_, 4)\\n                let b_ := iszero(gt(_pOut, end_))\\n                let t_ := mload(pIn_) // Load the whole word.\\n                for { let i_ := 0 } iszero(eq(i_, 4)) { i_ := add(i_, 1) } {\\n                    let c_ := sub(byte(i_, t_), 48)\\n                    if iszero(and(shr(c_, 0x7e0000007e03ff), b_)) { fail() } // Not hexadecimal.\\n                    c_ := sub(c_, add(mul(gt(c_, 16), 7), shl(5, gt(c_, 48))))\\n                    _unicode := add(shl(4, _unicode), c_)\\n                }\\n            }\\n\\n            function decodeUnicodeCodePoint(pIn_, end_) -> _unicode, _pOut {\\n                _unicode, _pOut := decodeUnicodeEscapeSequence(pIn_, end_)\\n                if iszero(or(lt(_unicode, 0xd800), gt(_unicode, 0xdbff))) {\\n                    let t_ := mload(_pOut) // Load the whole word.\\n                    end_ := mul(end_, eq(shr(240, t_), 0x5c75)) // Fail if not starting with '\\\\\\\\u'.\\n                    t_, _pOut := decodeUnicodeEscapeSequence(add(_pOut, 2), end_)\\n                    _unicode := add(0x10000, add(shl(10, and(0x3ff, _unicode)), and(0x3ff, t_)))\\n                }\\n            }\\n\\n            function appendCodePointAsUTF8(pIn_, c_) -> _pOut {\\n                if iszero(gt(c_, 0x7f)) {\\n                    mstore8(pIn_, c_)\\n                    _pOut := add(pIn_, 1)\\n                    leave\\n                }\\n                mstore8(0x1f, c_)\\n                mstore8(0x1e, shr(6, c_))\\n                if iszero(gt(c_, 0x7ff)) {\\n                    mstore(pIn_, shl(240, or(0xc080, and(0x1f3f, mload(0x00)))))\\n                    _pOut := add(pIn_, 2)\\n                    leave\\n                }\\n                mstore8(0x1d, shr(12, c_))\\n                if iszero(gt(c_, 0xffff)) {\\n                    mstore(pIn_, shl(232, or(0xe08080, and(0x0f3f3f, mload(0x00)))))\\n                    _pOut := add(pIn_, 3)\\n                    leave\\n                }\\n                mstore8(0x1c, shr(18, c_))\\n                mstore(pIn_, shl(224, or(0xf0808080, and(0x073f3f3f, mload(0x00)))))\\n                _pOut := add(pIn_, shl(2, lt(c_, 0x110000)))\\n            }\\n\\n            function chr(p_) -> _c {\\n                _c := byte(0, mload(p_))\\n            }\\n\\n            let n := mload(s)\\n            let end := add(add(s, n), 0x1f)\\n            if iszero(and(gt(n, 1), eq(0x2222, or(and(0xff00, mload(add(s, 2))), chr(end))))) {\\n                fail() // Fail if not double-quoted.\\n            }\\n            let out := add(mload(0x40), 0x20)\\n            for { let curr := add(s, 0x21) } iszero(eq(curr, end)) {} {\\n                let c := chr(curr)\\n                curr := add(curr, 1)\\n                // Not '\\\\\\\\'.\\n                if iszero(eq(c, 92)) {\\n                    // Not '\\\"'.\\n                    if iszero(eq(c, 34)) {\\n                        mstore8(out, c)\\n                        out := add(out, 1)\\n                        continue\\n                    }\\n                    curr := end\\n                }\\n                if iszero(eq(curr, end)) {\\n                    let escape := chr(curr)\\n                    curr := add(curr, 1)\\n                    // '\\\"', '/', '\\\\\\\\'.\\n                    if and(shr(escape, 0x100000000000800400000000), 1) {\\n                        mstore8(out, escape)\\n                        out := add(out, 1)\\n                        continue\\n                    }\\n                    // 'u'.\\n                    if eq(escape, 117) {\\n                        escape, curr := decodeUnicodeCodePoint(curr, end)\\n                        out := appendCodePointAsUTF8(out, escape)\\n                        continue\\n                    }\\n                    // `{'b':'\\\\b', 'f':'\\\\f', 'n':'\\\\n', 'r':'\\\\r', 't':'\\\\t'}`.\\n                    escape := byte(sub(escape, 85), 0x080000000c000000000000000a0000000d0009)\\n                    if escape {\\n                        mstore8(out, escape)\\n                        out := add(out, 1)\\n                        continue\\n                    }\\n                }\\n                fail()\\n                break\\n            }\\n            mstore(out, 0) // Zeroize the last slot.\\n            result := mload(0x40)\\n            mstore(result, sub(out, add(result, 0x20))) // Store the length.\\n            mstore(0x40, add(out, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                      PRIVATE HELPERS                       */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Performs a query on the input with the given mode.\\n    function _query(bytes32 input, uint256 mode) private pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            function fail() {\\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n\\n            function chr(p_) -> _c {\\n                _c := byte(0, mload(p_))\\n            }\\n\\n            function skipWhitespace(pIn_, end_) -> _pOut {\\n                for { _pOut := pIn_ } 1 { _pOut := add(_pOut, 1) } {\\n                    if iszero(and(shr(chr(_pOut), 0x100002600), 1)) { leave } // Not in ' \\\\n\\\\r\\\\t'.\\n                }\\n            }\\n\\n            function setP(packed_, bitpos_, p_) -> _packed {\\n                // Perform an out-of-gas revert if `p_` exceeds `_BITMASK_POINTER`.\\n                returndatacopy(returndatasize(), returndatasize(), gt(p_, _BITMASK_POINTER))\\n                _packed := or(and(not(shl(bitpos_, _BITMASK_POINTER)), packed_), shl(bitpos_, p_))\\n            }\\n\\n            function getP(packed_, bitpos_) -> _p {\\n                _p := and(_BITMASK_POINTER, shr(bitpos_, packed_))\\n            }\\n\\n            function mallocItem(s_, packed_, pStart_, pCurr_, type_) -> _item {\\n                _item := mload(0x40)\\n                // forgefmt: disable-next-item\\n                packed_ := setP(setP(packed_, _BITPOS_VALUE, sub(pStart_, add(s_, 0x20))),\\n                    _BITPOS_VALUE_LENGTH, sub(pCurr_, pStart_))\\n                mstore(_item, or(packed_, type_))\\n                mstore(0x40, add(_item, 0x20)) // Allocate memory.\\n            }\\n\\n            function parseValue(s_, sibling_, pIn_, end_) -> _item, _pOut {\\n                let packed_ := setP(mload(0x00), _BITPOS_SIBLING_OR_PARENT, sibling_)\\n                _pOut := skipWhitespace(pIn_, end_)\\n                if iszero(lt(_pOut, end_)) { leave }\\n                for { let c_ := chr(_pOut) } 1 {} {\\n                    // If starts with '\\\"'.\\n                    if eq(c_, 34) {\\n                        let pStart_ := _pOut\\n                        _pOut := parseStringSub(s_, packed_, _pOut, end_)\\n                        _item := mallocItem(s_, packed_, pStart_, _pOut, TYPE_STRING)\\n                        break\\n                    }\\n                    // If starts with '['.\\n                    if eq(c_, 91) {\\n                        _item, _pOut := parseArray(s_, packed_, _pOut, end_)\\n                        break\\n                    }\\n                    // If starts with '{'.\\n                    if eq(c_, 123) {\\n                        _item, _pOut := parseObject(s_, packed_, _pOut, end_)\\n                        break\\n                    }\\n                    // If starts with any in '0123456789-'.\\n                    if and(shr(c_, shl(45, 0x1ff9)), 1) {\\n                        _item, _pOut := parseNumber(s_, packed_, _pOut, end_)\\n                        break\\n                    }\\n                    if iszero(gt(add(_pOut, 4), end_)) {\\n                        let pStart_ := _pOut\\n                        let w_ := shr(224, mload(_pOut))\\n                        // 'true' in hex format.\\n                        if eq(w_, 0x74727565) {\\n                            _pOut := add(_pOut, 4)\\n                            _item := mallocItem(s_, packed_, pStart_, _pOut, TYPE_BOOLEAN)\\n                            break\\n                        }\\n                        // 'null' in hex format.\\n                        if eq(w_, 0x6e756c6c) {\\n                            _pOut := add(_pOut, 4)\\n                            _item := mallocItem(s_, packed_, pStart_, _pOut, TYPE_NULL)\\n                            break\\n                        }\\n                    }\\n                    if iszero(gt(add(_pOut, 5), end_)) {\\n                        let pStart_ := _pOut\\n                        let w_ := shr(216, mload(_pOut))\\n                        // 'false' in hex format.\\n                        if eq(w_, 0x66616c7365) {\\n                            _pOut := add(_pOut, 5)\\n                            _item := mallocItem(s_, packed_, pStart_, _pOut, TYPE_BOOLEAN)\\n                            break\\n                        }\\n                    }\\n                    fail()\\n                    break\\n                }\\n                _pOut := skipWhitespace(_pOut, end_)\\n            }\\n\\n            function parseArray(s_, packed_, pIn_, end_) -> _item, _pOut {\\n                let j_ := 0\\n                for { _pOut := add(pIn_, 1) } 1 { _pOut := add(_pOut, 1) } {\\n                    if iszero(lt(_pOut, end_)) { fail() }\\n                    if iszero(_item) {\\n                        _pOut := skipWhitespace(_pOut, end_)\\n                        if eq(chr(_pOut), 93) { break } // ']'.\\n                    }\\n                    _item, _pOut := parseValue(s_, _item, _pOut, end_)\\n                    if _item {\\n                        // forgefmt: disable-next-item\\n                        mstore(_item, setP(or(_PARENT_IS_ARRAY, mload(_item)),\\n                            _BITPOS_KEY, j_))\\n                        j_ := add(j_, 1)\\n                        let c_ := chr(_pOut)\\n                        if eq(c_, 93) { break } // ']'.\\n                        if eq(c_, 44) { continue } // ','.\\n                    }\\n                    _pOut := end_\\n                }\\n                _pOut := add(_pOut, 1)\\n                packed_ := setP(packed_, _BITPOS_CHILD, _item)\\n                _item := mallocItem(s_, packed_, pIn_, _pOut, TYPE_ARRAY)\\n            }\\n\\n            function parseObject(s_, packed_, pIn_, end_) -> _item, _pOut {\\n                for { _pOut := add(pIn_, 1) } 1 { _pOut := add(_pOut, 1) } {\\n                    if iszero(lt(_pOut, end_)) { fail() }\\n                    if iszero(_item) {\\n                        _pOut := skipWhitespace(_pOut, end_)\\n                        if eq(chr(_pOut), 125) { break } // '}'.\\n                    }\\n                    _pOut := skipWhitespace(_pOut, end_)\\n                    let pKeyStart_ := _pOut\\n                    let pKeyEnd_ := parseStringSub(s_, _item, _pOut, end_)\\n                    _pOut := skipWhitespace(pKeyEnd_, end_)\\n                    // If ':'.\\n                    if eq(chr(_pOut), 58) {\\n                        _item, _pOut := parseValue(s_, _item, add(_pOut, 1), end_)\\n                        if _item {\\n                            // forgefmt: disable-next-item\\n                            mstore(_item, setP(setP(or(_PARENT_IS_OBJECT, mload(_item)),\\n                                _BITPOS_KEY_LENGTH, sub(pKeyEnd_, pKeyStart_)),\\n                                    _BITPOS_KEY, sub(pKeyStart_, add(s_, 0x20))))\\n                            let c_ := chr(_pOut)\\n                            if eq(c_, 125) { break } // '}'.\\n                            if eq(c_, 44) { continue } // ','.\\n                        }\\n                    }\\n                    _pOut := end_\\n                }\\n                _pOut := add(_pOut, 1)\\n                packed_ := setP(packed_, _BITPOS_CHILD, _item)\\n                _item := mallocItem(s_, packed_, pIn_, _pOut, TYPE_OBJECT)\\n            }\\n\\n            function checkStringU(p_, o_) {\\n                // If not in '0123456789abcdefABCDEF', revert.\\n                if iszero(and(shr(sub(chr(add(p_, o_)), 48), 0x7e0000007e03ff), 1)) { fail() }\\n                if iszero(eq(o_, 5)) { checkStringU(p_, add(o_, 1)) }\\n            }\\n\\n            function parseStringSub(s_, packed_, pIn_, end_) -> _pOut {\\n                if iszero(lt(pIn_, end_)) { fail() }\\n                for { _pOut := add(pIn_, 1) } 1 {} {\\n                    let c_ := chr(_pOut)\\n                    if eq(c_, 34) { break } // '\\\"'.\\n                    // Not '\\\\'.\\n                    if iszero(eq(c_, 92)) {\\n                        _pOut := add(_pOut, 1)\\n                        continue\\n                    }\\n                    c_ := chr(add(_pOut, 1))\\n                    // '\\\"', '\\\\', '//', 'b', 'f', 'n', 'r', 't'.\\n                    if and(shr(sub(c_, 34), 0x510110400000000002001), 1) {\\n                        _pOut := add(_pOut, 2)\\n                        continue\\n                    }\\n                    // 'u'.\\n                    if eq(c_, 117) {\\n                        checkStringU(_pOut, 2)\\n                        _pOut := add(_pOut, 6)\\n                        continue\\n                    }\\n                    _pOut := end_\\n                    break\\n                }\\n                if iszero(lt(_pOut, end_)) { fail() }\\n                _pOut := add(_pOut, 1)\\n            }\\n\\n            function skip0To9s(pIn_, end_, atLeastOne_) -> _pOut {\\n                for { _pOut := pIn_ } 1 { _pOut := add(_pOut, 1) } {\\n                    if iszero(lt(sub(chr(_pOut), 48), 10)) { break } // Not '0'..'9'.\\n                }\\n                if and(atLeastOne_, eq(pIn_, _pOut)) { fail() }\\n            }\\n\\n            function parseNumber(s_, packed_, pIn_, end_) -> _item, _pOut {\\n                _pOut := pIn_\\n                if eq(chr(_pOut), 45) { _pOut := add(_pOut, 1) } // '-'.\\n                if iszero(lt(sub(chr(_pOut), 48), 10)) { fail() } // Not '0'..'9'.\\n                let c_ := chr(_pOut)\\n                _pOut := add(_pOut, 1)\\n                if iszero(eq(c_, 48)) { _pOut := skip0To9s(_pOut, end_, 0) } // Not '0'.\\n                if eq(chr(_pOut), 46) { _pOut := skip0To9s(add(_pOut, 1), end_, 1) } // '.'.\\n                let t_ := mload(_pOut)\\n                // 'E', 'e'.\\n                if eq(or(0x20, byte(0, t_)), 101) {\\n                    // forgefmt: disable-next-item\\n                    _pOut := skip0To9s(add(byte(sub(byte(1, t_), 14), 0x010001), // '+', '-'.\\n                        add(_pOut, 1)), end_, 1)\\n                }\\n                _item := mallocItem(s_, packed_, pIn_, _pOut, TYPE_NUMBER)\\n            }\\n\\n            function copyStr(s_, offset_, len_) -> _sCopy {\\n                _sCopy := mload(0x40)\\n                s_ := add(s_, offset_)\\n                let w_ := not(0x1f)\\n                for { let i_ := and(add(len_, 0x1f), w_) } 1 {} {\\n                    mstore(add(_sCopy, i_), mload(add(s_, i_)))\\n                    i_ := add(i_, w_) // `sub(i_, 0x20)`.\\n                    if iszero(i_) { break }\\n                }\\n                mstore(_sCopy, len_) // Copy the length.\\n                mstore(add(add(_sCopy, 0x20), len_), 0) // Zeroize the last slot.\\n                mstore(0x40, add(add(_sCopy, 0x40), len_)) // Allocate memory.\\n            }\\n\\n            function value(item_) -> _value {\\n                let packed_ := mload(item_)\\n                _value := getP(packed_, _BITPOS_VALUE) // The offset in the string.\\n                if iszero(and(_VALUE_INITED, packed_)) {\\n                    let s_ := getP(packed_, _BITPOS_STRING)\\n                    _value := copyStr(s_, _value, getP(packed_, _BITPOS_VALUE_LENGTH))\\n                    packed_ := setP(packed_, _BITPOS_VALUE, _value)\\n                    mstore(s_, or(_VALUE_INITED, packed_))\\n                }\\n            }\\n\\n            function children(item_) -> _arr {\\n                _arr := 0x60 // Initialize to the zero pointer.\\n                let packed_ := mload(item_)\\n                for {} iszero(gt(and(_BITMASK_TYPE, packed_), TYPE_OBJECT)) {} {\\n                    if or(iszero(packed_), iszero(item_)) { break }\\n                    if and(packed_, _CHILDREN_INITED) {\\n                        _arr := getP(packed_, _BITPOS_CHILD)\\n                        break\\n                    }\\n                    _arr := mload(0x40)\\n                    let o_ := add(_arr, 0x20)\\n                    for { let h_ := getP(packed_, _BITPOS_CHILD) } h_ {} {\\n                        mstore(o_, h_)\\n                        let q_ := mload(h_)\\n                        let y_ := getP(q_, _BITPOS_SIBLING_OR_PARENT)\\n                        mstore(h_, setP(q_, _BITPOS_SIBLING_OR_PARENT, item_))\\n                        h_ := y_\\n                        o_ := add(o_, 0x20)\\n                    }\\n                    let w_ := not(0x1f)\\n                    let n_ := add(w_, sub(o_, _arr))\\n                    mstore(_arr, shr(5, n_))\\n                    mstore(0x40, o_) // Allocate memory.\\n                    packed_ := setP(packed_, _BITPOS_CHILD, _arr)\\n                    mstore(item_, or(_CHILDREN_INITED, packed_))\\n                    // Reverse the array.\\n                    if iszero(lt(n_, 0x40)) {\\n                        let lo_ := add(_arr, 0x20)\\n                        let hi_ := add(_arr, n_)\\n                        for {} 1 {} {\\n                            let temp_ := mload(lo_)\\n                            mstore(lo_, mload(hi_))\\n                            mstore(hi_, temp_)\\n                            hi_ := add(hi_, w_)\\n                            lo_ := add(lo_, 0x20)\\n                            if iszero(lt(lo_, hi_)) { break }\\n                        }\\n                    }\\n                    break\\n                }\\n            }\\n\\n            function getStr(item_, bitpos_, bitposLength_, bitmaskInited_) -> _result {\\n                _result := 0x60 // Initialize to the zero pointer.\\n                let packed_ := mload(item_)\\n                if or(iszero(item_), iszero(packed_)) { leave }\\n                _result := getP(packed_, bitpos_)\\n                if iszero(and(bitmaskInited_, packed_)) {\\n                    let s_ := getP(packed_, _BITPOS_STRING)\\n                    _result := copyStr(s_, _result, getP(packed_, bitposLength_))\\n                    mstore(item_, or(bitmaskInited_, setP(packed_, bitpos_, _result)))\\n                }\\n            }\\n\\n            switch mode\\n            // Get value.\\n            case 0 { result := getStr(input, _BITPOS_VALUE, _BITPOS_VALUE_LENGTH, _VALUE_INITED) }\\n            // Get key.\\n            case 1 { result := getStr(input, _BITPOS_KEY, _BITPOS_KEY_LENGTH, _KEY_INITED) }\\n            // Get children.\\n            case 3 { result := children(input) }\\n            // Parse.\\n            default {\\n                let p := add(input, 0x20)\\n                let e := add(p, mload(input))\\n                if iszero(eq(p, e)) {\\n                    let c := chr(e)\\n                    mstore8(e, 34) // Place a '\\\"' at the end to speed up parsing.\\n                    // The `34 << 248` makes `mallocItem` preserve '\\\"' at the end.\\n                    mstore(0x00, setP(shl(248, 34), _BITPOS_STRING, input))\\n                    result, p := parseValue(input, 0, p, e)\\n                    mstore8(e, c) // Restore the original char at the end.\\n                }\\n                if or(lt(p, e), iszero(result)) { fail() }\\n            }\\n        }\\n    }\\n\\n    /// @dev Casts the input to a bytes32.\\n    function _toInput(string memory input) private pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := input\\n        }\\n    }\\n\\n    /// @dev Casts the input to a bytes32.\\n    function _toInput(Item memory input) private pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := input\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x24ddc4015b10af1bcf9eb4fd69d1e03a575698b0104b9ecc60c0c25464cd4d03\",\"license\":\"MIT\"},\"solady/src/utils/LibString.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library for converting numbers into strings and other string operations.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibString.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)\\n///\\n/// Note:\\n/// For performance and bytecode compactness, most of the string operations are restricted to\\n/// byte strings (7-bit ASCII), except where otherwise specified.\\n/// Usage of byte string operations on charsets with runes spanning two or more bytes\\n/// can lead to undefined behavior.\\nlibrary LibString {\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                        CUSTOM ERRORS                       */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The length of the output is too small to contain all the hex digits.\\n    error HexLengthInsufficient();\\n\\n    /// @dev The length of the string is more than 32 bytes.\\n    error TooBigForSmallString();\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The constant returned when the `search` is not found in the string.\\n    uint256 internal constant NOT_FOUND = type(uint256).max;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                     DECIMAL OPERATIONS                     */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns the base 10 decimal representation of `value`.\\n    function toString(uint256 value) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\\n            // and 3 words for a maximum of 78 digits.\\n            str := add(mload(0x40), 0x80)\\n            // Update the free memory pointer to allocate.\\n            mstore(0x40, add(str, 0x20))\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end of the memory to calculate the length later.\\n            let end := str\\n\\n            let w := not(0) // Tsk.\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for { let temp := value } 1 {} {\\n                str := add(str, w) // `sub(str, 1)`.\\n                // Write the character to the pointer.\\n                // The ASCII index of the '0' character is 48.\\n                mstore8(str, add(48, mod(temp, 10)))\\n                // Keep dividing `temp` until zero.\\n                temp := div(temp, 10)\\n                if iszero(temp) { break }\\n            }\\n\\n            let length := sub(end, str)\\n            // Move the pointer 32 bytes leftwards to make room for the length.\\n            str := sub(str, 0x20)\\n            // Store the length.\\n            mstore(str, length)\\n        }\\n    }\\n\\n    /// @dev Returns the base 10 decimal representation of `value`.\\n    function toString(int256 value) internal pure returns (string memory str) {\\n        if (value >= 0) {\\n            return toString(uint256(value));\\n        }\\n        unchecked {\\n            str = toString(~uint256(value) + 1);\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We still have some spare memory space on the left,\\n            // as we have allocated 3 words (96 bytes) for up to 78 digits.\\n            let length := mload(str) // Load the string length.\\n            mstore(str, 0x2d) // Store the '-' character.\\n            str := sub(str, 1) // Move back the string pointer by a byte.\\n            mstore(str, add(length, 1)) // Update the string length.\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                   HEXADECIMAL OPERATIONS                   */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns the hexadecimal representation of `value`,\\n    /// left-padded to an input length of `length` bytes.\\n    /// The output is prefixed with \\\"0x\\\" encoded using 2 hexadecimal digits per byte,\\n    /// giving a total length of `length * 2 + 2` bytes.\\n    /// Reverts if `length` is too small for the output to contain all the digits.\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value, length);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Write the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`,\\n    /// left-padded to an input length of `length` bytes.\\n    /// The output is prefixed with \\\"0x\\\" encoded using 2 hexadecimal digits per byte,\\n    /// giving a total length of `length * 2` bytes.\\n    /// Reverts if `length` is too small for the output to contain all the digits.\\n    function toHexStringNoPrefix(uint256 value, uint256 length)\\n        internal\\n        pure\\n        returns (string memory str)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes\\n            // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.\\n            // We add 0x20 to the total and round down to a multiple of 0x20.\\n            // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.\\n            str := add(mload(0x40), and(add(shl(1, length), 0x42), not(0x1f)))\\n            // Allocate the memory.\\n            mstore(0x40, add(str, 0x20))\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end to calculate the length later.\\n            let end := str\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            let start := sub(str, add(length, length))\\n            let w := not(1) // Tsk.\\n            let temp := value\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for {} 1 {} {\\n                str := add(str, w) // `sub(str, 2)`.\\n                mstore8(add(str, 1), mload(and(temp, 15)))\\n                mstore8(str, mload(and(shr(4, temp), 15)))\\n                temp := shr(8, temp)\\n                if iszero(xor(str, start)) { break }\\n            }\\n\\n            if temp {\\n                mstore(0x00, 0x2194895a) // `HexLengthInsufficient()`.\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Compute the string's length.\\n            let strLength := sub(end, str)\\n            // Move the pointer and write the length.\\n            str := sub(str, 0x20)\\n            mstore(str, strLength)\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\" and encoded using 2 hexadecimal digits per byte.\\n    /// As address are 20 bytes long, the output will left-padded to have\\n    /// a length of `20 * 2 + 2` bytes.\\n    function toHexString(uint256 value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Write the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\".\\n    /// The output excludes leading \\\"0\\\" from the `toHexString` output.\\n    /// `0x00: \\\"0x0\\\", 0x01: \\\"0x1\\\", 0x12: \\\"0x12\\\", 0x123: \\\"0x123\\\"`.\\n    function toMinimalHexString(uint256 value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(add(str, o), 0x3078) // Write the \\\"0x\\\" prefix, accounting for leading zero.\\n            str := sub(add(str, o), 2) // Move the pointer, accounting for leading zero.\\n            mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output excludes leading \\\"0\\\" from the `toHexStringNoPrefix` output.\\n    /// `0x00: \\\"0\\\", 0x01: \\\"1\\\", 0x12: \\\"12\\\", 0x123: \\\"123\\\"`.\\n    function toMinimalHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\\n            let strLength := mload(str) // Get the length.\\n            str := add(str, o) // Move the pointer, accounting for leading zero.\\n            mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    /// As address are 20 bytes long, the output will left-padded to have\\n    /// a length of `20 * 2` bytes.\\n    function toHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\\n            // 0x02 bytes for the prefix, and 0x40 bytes for the digits.\\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.\\n            str := add(mload(0x40), 0x80)\\n            // Allocate the memory.\\n            mstore(0x40, add(str, 0x20))\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end to calculate the length later.\\n            let end := str\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            let w := not(1) // Tsk.\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for { let temp := value } 1 {} {\\n                str := add(str, w) // `sub(str, 2)`.\\n                mstore8(add(str, 1), mload(and(temp, 15)))\\n                mstore8(str, mload(and(shr(4, temp), 15)))\\n                temp := shr(8, temp)\\n                if iszero(temp) { break }\\n            }\\n\\n            // Compute the string's length.\\n            let strLength := sub(end, str)\\n            // Move the pointer and write the length.\\n            str := sub(str, 0x20)\\n            mstore(str, strLength)\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\", encoded using 2 hexadecimal digits per byte,\\n    /// and the alphabets are capitalized conditionally according to\\n    /// https://eips.ethereum.org/EIPS/eip-55\\n    function toHexStringChecksummed(address value) internal pure returns (string memory str) {\\n        str = toHexString(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`\\n            let o := add(str, 0x22)\\n            let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `\\n            let t := shl(240, 136) // `0b10001000 << 240`\\n            for { let i := 0 } 1 {} {\\n                mstore(add(i, i), mul(t, byte(i, hashed)))\\n                i := add(i, 1)\\n                if eq(i, 20) { break }\\n            }\\n            mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))\\n            o := add(o, 0x20)\\n            mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\" and encoded using 2 hexadecimal digits per byte.\\n    function toHexString(address value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Write the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    function toHexStringNoPrefix(address value) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            str := mload(0x40)\\n\\n            // Allocate the memory.\\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\\n            // 0x02 bytes for the prefix, and 0x28 bytes for the digits.\\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.\\n            mstore(0x40, add(str, 0x80))\\n\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            str := add(str, 2)\\n            mstore(str, 40)\\n\\n            let o := add(str, 0x20)\\n            mstore(add(o, 40), 0)\\n\\n            value := shl(96, value)\\n\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for { let i := 0 } 1 {} {\\n                let p := add(o, add(i, i))\\n                let temp := byte(i, value)\\n                mstore8(add(p, 1), mload(and(temp, 15)))\\n                mstore8(p, mload(shr(4, temp)))\\n                i := add(i, 1)\\n                if eq(i, 20) { break }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the hex encoded string from the raw bytes.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    function toHexString(bytes memory raw) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(raw);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Write the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hex encoded string from the raw bytes.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    function toHexStringNoPrefix(bytes memory raw) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let length := mload(raw)\\n            str := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.\\n            mstore(str, add(length, length)) // Store the length of the output.\\n\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            let o := add(str, 0x20)\\n            let end := add(raw, length)\\n\\n            for {} iszero(eq(raw, end)) {} {\\n                raw := add(raw, 1)\\n                mstore8(add(o, 1), mload(and(mload(raw), 15)))\\n                mstore8(o, mload(and(shr(4, mload(raw)), 15)))\\n                o := add(o, 2)\\n            }\\n            mstore(o, 0) // Zeroize the slot after the string.\\n            mstore(0x40, add(o, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                   RUNE STRING OPERATIONS                   */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns the number of UTF characters in the string.\\n    function runeCount(string memory s) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if mload(s) {\\n                mstore(0x00, div(not(0), 255))\\n                mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)\\n                let o := add(s, 0x20)\\n                let end := add(o, mload(s))\\n                for { result := 1 } 1 { result := add(result, 1) } {\\n                    o := add(o, byte(0, mload(shr(250, mload(o)))))\\n                    if iszero(lt(o, end)) { break }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns if this string is a 7-bit ASCII string.\\n    /// (i.e. all characters codes are in [0..127])\\n    function is7BitASCII(string memory s) internal pure returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let mask := shl(7, div(not(0), 255))\\n            result := 1\\n            let n := mload(s)\\n            if n {\\n                let o := add(s, 0x20)\\n                let end := add(o, n)\\n                let last := mload(end)\\n                mstore(end, 0)\\n                for {} 1 {} {\\n                    if and(mask, mload(o)) {\\n                        result := 0\\n                        break\\n                    }\\n                    o := add(o, 0x20)\\n                    if iszero(lt(o, end)) { break }\\n                }\\n                mstore(end, last)\\n            }\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                   BYTE STRING OPERATIONS                   */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    // For performance and bytecode compactness, byte string operations are restricted\\n    // to 7-bit ASCII strings. All offsets are byte offsets, not UTF character offsets.\\n    // Usage of byte string operations on charsets with runes spanning two or more bytes\\n    // can lead to undefined behavior.\\n\\n    /// @dev Returns `subject` all occurrences of `search` replaced with `replacement`.\\n    function replace(string memory subject, string memory search, string memory replacement)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            let searchLength := mload(search)\\n            let replacementLength := mload(replacement)\\n\\n            subject := add(subject, 0x20)\\n            search := add(search, 0x20)\\n            replacement := add(replacement, 0x20)\\n            result := add(mload(0x40), 0x20)\\n\\n            let subjectEnd := add(subject, subjectLength)\\n            if iszero(gt(searchLength, subjectLength)) {\\n                let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)\\n                let h := 0\\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\\n                let s := mload(search)\\n                for {} 1 {} {\\n                    let t := mload(subject)\\n                    // Whether the first `searchLength % 32` bytes of\\n                    // `subject` and `search` matches.\\n                    if iszero(shr(m, xor(t, s))) {\\n                        if h {\\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\\n                                mstore(result, t)\\n                                result := add(result, 1)\\n                                subject := add(subject, 1)\\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\\n                                continue\\n                            }\\n                        }\\n                        // Copy the `replacement` one word at a time.\\n                        for { let o := 0 } 1 {} {\\n                            mstore(add(result, o), mload(add(replacement, o)))\\n                            o := add(o, 0x20)\\n                            if iszero(lt(o, replacementLength)) { break }\\n                        }\\n                        result := add(result, replacementLength)\\n                        subject := add(subject, searchLength)\\n                        if searchLength {\\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\\n                            continue\\n                        }\\n                    }\\n                    mstore(result, t)\\n                    result := add(result, 1)\\n                    subject := add(subject, 1)\\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\\n                }\\n            }\\n\\n            let resultRemainder := result\\n            result := add(mload(0x40), 0x20)\\n            let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))\\n            // Copy the rest of the string one word at a time.\\n            for {} lt(subject, subjectEnd) {} {\\n                mstore(resultRemainder, mload(subject))\\n                resultRemainder := add(resultRemainder, 0x20)\\n                subject := add(subject, 0x20)\\n            }\\n            result := sub(result, 0x20)\\n            let last := add(add(result, 0x20), k) // Zeroize the slot after the string.\\n            mstore(last, 0)\\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n            mstore(result, k) // Store the length.\\n        }\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from left to right, starting from `from`.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function indexOf(string memory subject, string memory search, uint256 from)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for { let subjectLength := mload(subject) } 1 {} {\\n                if iszero(mload(search)) {\\n                    if iszero(gt(from, subjectLength)) {\\n                        result := from\\n                        break\\n                    }\\n                    result := subjectLength\\n                    break\\n                }\\n                let searchLength := mload(search)\\n                let subjectStart := add(subject, 0x20)\\n\\n                result := not(0) // Initialize to `NOT_FOUND`.\\n\\n                subject := add(subjectStart, from)\\n                let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)\\n\\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\\n                let s := mload(add(search, 0x20))\\n\\n                if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }\\n\\n                if iszero(lt(searchLength, 0x20)) {\\n                    for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\\n                        if iszero(shr(m, xor(mload(subject), s))) {\\n                            if eq(keccak256(subject, searchLength), h) {\\n                                result := sub(subject, subjectStart)\\n                                break\\n                            }\\n                        }\\n                        subject := add(subject, 1)\\n                        if iszero(lt(subject, end)) { break }\\n                    }\\n                    break\\n                }\\n                for {} 1 {} {\\n                    if iszero(shr(m, xor(mload(subject), s))) {\\n                        result := sub(subject, subjectStart)\\n                        break\\n                    }\\n                    subject := add(subject, 1)\\n                    if iszero(lt(subject, end)) { break }\\n                }\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from left to right.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function indexOf(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        result = indexOf(subject, search, 0);\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from right to left, starting from `from`.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function lastIndexOf(string memory subject, string memory search, uint256 from)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {} 1 {} {\\n                result := not(0) // Initialize to `NOT_FOUND`.\\n                let searchLength := mload(search)\\n                if gt(searchLength, mload(subject)) { break }\\n                let w := result\\n\\n                let fromMax := sub(mload(subject), searchLength)\\n                if iszero(gt(fromMax, from)) { from := fromMax }\\n\\n                let end := add(add(subject, 0x20), w)\\n                subject := add(add(subject, 0x20), from)\\n                if iszero(gt(subject, end)) { break }\\n                // As this function is not too often used,\\n                // we shall simply use keccak256 for smaller bytecode size.\\n                for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\\n                    if eq(keccak256(subject, searchLength), h) {\\n                        result := sub(subject, add(end, 1))\\n                        break\\n                    }\\n                    subject := add(subject, w) // `sub(subject, 1)`.\\n                    if iszero(gt(subject, end)) { break }\\n                }\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from right to left.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function lastIndexOf(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        result = lastIndexOf(subject, search, uint256(int256(-1)));\\n    }\\n\\n    /// @dev Returns true if `search` is found in `subject`, false otherwise.\\n    function contains(string memory subject, string memory search) internal pure returns (bool) {\\n        return indexOf(subject, search) != NOT_FOUND;\\n    }\\n\\n    /// @dev Returns whether `subject` starts with `search`.\\n    function startsWith(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (bool result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let searchLength := mload(search)\\n            // Just using keccak256 directly is actually cheaper.\\n            // forgefmt: disable-next-item\\n            result := and(\\n                iszero(gt(searchLength, mload(subject))),\\n                eq(\\n                    keccak256(add(subject, 0x20), searchLength),\\n                    keccak256(add(search, 0x20), searchLength)\\n                )\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns whether `subject` ends with `search`.\\n    function endsWith(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (bool result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let searchLength := mload(search)\\n            let subjectLength := mload(subject)\\n            // Whether `search` is not longer than `subject`.\\n            let withinRange := iszero(gt(searchLength, subjectLength))\\n            // Just using keccak256 directly is actually cheaper.\\n            // forgefmt: disable-next-item\\n            result := and(\\n                withinRange,\\n                eq(\\n                    keccak256(\\n                        // `subject + 0x20 + max(subjectLength - searchLength, 0)`.\\n                        add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),\\n                        searchLength\\n                    ),\\n                    keccak256(add(search, 0x20), searchLength)\\n                )\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns `subject` repeated `times`.\\n    function repeat(string memory subject, uint256 times)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            if iszero(or(iszero(times), iszero(subjectLength))) {\\n                subject := add(subject, 0x20)\\n                result := mload(0x40)\\n                let output := add(result, 0x20)\\n                for {} 1 {} {\\n                    // Copy the `subject` one word at a time.\\n                    for { let o := 0 } 1 {} {\\n                        mstore(add(output, o), mload(add(subject, o)))\\n                        o := add(o, 0x20)\\n                        if iszero(lt(o, subjectLength)) { break }\\n                    }\\n                    output := add(output, subjectLength)\\n                    times := sub(times, 1)\\n                    if iszero(times) { break }\\n                }\\n                mstore(output, 0) // Zeroize the slot after the string.\\n                let resultLength := sub(output, add(result, 0x20))\\n                mstore(result, resultLength) // Store the length.\\n                // Allocate the memory.\\n                mstore(0x40, add(result, add(resultLength, 0x20)))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\\n    /// `start` and `end` are byte offsets.\\n    function slice(string memory subject, uint256 start, uint256 end)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            if iszero(gt(subjectLength, end)) { end := subjectLength }\\n            if iszero(gt(subjectLength, start)) { start := subjectLength }\\n            if lt(start, end) {\\n                result := mload(0x40)\\n                let resultLength := sub(end, start)\\n                mstore(result, resultLength)\\n                subject := add(subject, start)\\n                let w := not(0x1f)\\n                // Copy the `subject` one word at a time, backwards.\\n                for { let o := and(add(resultLength, 0x1f), w) } 1 {} {\\n                    mstore(add(result, o), mload(add(subject, o)))\\n                    o := add(o, w) // `sub(o, 0x20)`.\\n                    if iszero(o) { break }\\n                }\\n                // Zeroize the slot after the string.\\n                mstore(add(add(result, 0x20), resultLength), 0)\\n                // Allocate memory for the length and the bytes,\\n                // rounded up to a multiple of 32.\\n                mstore(0x40, add(result, and(add(resultLength, 0x3f), w)))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the string.\\n    /// `start` is a byte offset.\\n    function slice(string memory subject, uint256 start)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        result = slice(subject, start, uint256(int256(-1)));\\n    }\\n\\n    /// @dev Returns all the indices of `search` in `subject`.\\n    /// The indices are byte offsets.\\n    function indicesOf(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (uint256[] memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            let searchLength := mload(search)\\n\\n            if iszero(gt(searchLength, subjectLength)) {\\n                subject := add(subject, 0x20)\\n                search := add(search, 0x20)\\n                result := add(mload(0x40), 0x20)\\n\\n                let subjectStart := subject\\n                let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)\\n                let h := 0\\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\\n                let s := mload(search)\\n                for {} 1 {} {\\n                    let t := mload(subject)\\n                    // Whether the first `searchLength % 32` bytes of\\n                    // `subject` and `search` matches.\\n                    if iszero(shr(m, xor(t, s))) {\\n                        if h {\\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\\n                                subject := add(subject, 1)\\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\\n                                continue\\n                            }\\n                        }\\n                        // Append to `result`.\\n                        mstore(result, sub(subject, subjectStart))\\n                        result := add(result, 0x20)\\n                        // Advance `subject` by `searchLength`.\\n                        subject := add(subject, searchLength)\\n                        if searchLength {\\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\\n                            continue\\n                        }\\n                    }\\n                    subject := add(subject, 1)\\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\\n                }\\n                let resultEnd := result\\n                // Assign `result` to the free memory pointer.\\n                result := mload(0x40)\\n                // Store the length of `result`.\\n                mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))\\n                // Allocate memory for result.\\n                // We allocate one more word, so this array can be recycled for {split}.\\n                mstore(0x40, add(resultEnd, 0x20))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a arrays of strings based on the `delimiter` inside of the `subject` string.\\n    function split(string memory subject, string memory delimiter)\\n        internal\\n        pure\\n        returns (string[] memory result)\\n    {\\n        uint256[] memory indices = indicesOf(subject, delimiter);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let w := not(0x1f)\\n            let indexPtr := add(indices, 0x20)\\n            let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))\\n            mstore(add(indicesEnd, w), mload(subject))\\n            mstore(indices, add(mload(indices), 1))\\n            let prevIndex := 0\\n            for {} 1 {} {\\n                let index := mload(indexPtr)\\n                mstore(indexPtr, 0x60)\\n                if iszero(eq(index, prevIndex)) {\\n                    let element := mload(0x40)\\n                    let elementLength := sub(index, prevIndex)\\n                    mstore(element, elementLength)\\n                    // Copy the `subject` one word at a time, backwards.\\n                    for { let o := and(add(elementLength, 0x1f), w) } 1 {} {\\n                        mstore(add(element, o), mload(add(add(subject, prevIndex), o)))\\n                        o := add(o, w) // `sub(o, 0x20)`.\\n                        if iszero(o) { break }\\n                    }\\n                    // Zeroize the slot after the string.\\n                    mstore(add(add(element, 0x20), elementLength), 0)\\n                    // Allocate memory for the length and the bytes,\\n                    // rounded up to a multiple of 32.\\n                    mstore(0x40, add(element, and(add(elementLength, 0x3f), w)))\\n                    // Store the `element` into the array.\\n                    mstore(indexPtr, element)\\n                }\\n                prevIndex := add(index, mload(delimiter))\\n                indexPtr := add(indexPtr, 0x20)\\n                if iszero(lt(indexPtr, indicesEnd)) { break }\\n            }\\n            result := indices\\n            if iszero(mload(delimiter)) {\\n                result := add(indices, 0x20)\\n                mstore(result, sub(mload(indices), 2))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a concatenated string of `a` and `b`.\\n    /// Cheaper than `string.concat()` and does not de-align the free memory pointer.\\n    function concat(string memory a, string memory b)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let w := not(0x1f)\\n            result := mload(0x40)\\n            let aLength := mload(a)\\n            // Copy `a` one word at a time, backwards.\\n            for { let o := and(add(aLength, 0x20), w) } 1 {} {\\n                mstore(add(result, o), mload(add(a, o)))\\n                o := add(o, w) // `sub(o, 0x20)`.\\n                if iszero(o) { break }\\n            }\\n            let bLength := mload(b)\\n            let output := add(result, aLength)\\n            // Copy `b` one word at a time, backwards.\\n            for { let o := and(add(bLength, 0x20), w) } 1 {} {\\n                mstore(add(output, o), mload(add(b, o)))\\n                o := add(o, w) // `sub(o, 0x20)`.\\n                if iszero(o) { break }\\n            }\\n            let totalLength := add(aLength, bLength)\\n            let last := add(add(result, 0x20), totalLength)\\n            // Zeroize the slot after the string.\\n            mstore(last, 0)\\n            // Stores the length.\\n            mstore(result, totalLength)\\n            // Allocate memory for the length and the bytes,\\n            // rounded up to a multiple of 32.\\n            mstore(0x40, and(add(last, 0x1f), w))\\n        }\\n    }\\n\\n    /// @dev Returns a copy of the string in either lowercase or UPPERCASE.\\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\\n    function toCase(string memory subject, bool toUpper)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let length := mload(subject)\\n            if length {\\n                result := add(mload(0x40), 0x20)\\n                subject := add(subject, 1)\\n                let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)\\n                let w := not(0)\\n                for { let o := length } 1 {} {\\n                    o := add(o, w)\\n                    let b := and(0xff, mload(add(subject, o)))\\n                    mstore8(add(result, o), xor(b, and(shr(b, flags), 0x20)))\\n                    if iszero(o) { break }\\n                }\\n                result := mload(0x40)\\n                mstore(result, length) // Store the length.\\n                let last := add(add(result, 0x20), length)\\n                mstore(last, 0) // Zeroize the slot after the string.\\n                mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a string from a small bytes32 string.\\n    /// `s` must be null-terminated, or behavior will be undefined.\\n    function fromSmallString(bytes32 s) internal pure returns (string memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            let n := 0\\n            for {} byte(n, s) { n := add(n, 1) } {} // Scan for '\\\\0'.\\n            mstore(result, n)\\n            let o := add(result, 0x20)\\n            mstore(o, s)\\n            mstore(add(o, n), 0)\\n            mstore(0x40, add(result, 0x40))\\n        }\\n    }\\n\\n    /// @dev Returns the small string, with all bytes after the first null byte zeroized.\\n    function normalizeSmallString(bytes32 s) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {} byte(result, s) { result := add(result, 1) } {} // Scan for '\\\\0'.\\n            mstore(0x00, s)\\n            mstore(result, 0x00)\\n            result := mload(0x00)\\n        }\\n    }\\n\\n    /// @dev Returns the string as a normalized null-terminated small string.\\n    function toSmallString(string memory s) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(s)\\n            if iszero(lt(result, 33)) {\\n                mstore(0x00, 0xec92f9a3) // `TooBigForSmallString()`.\\n                revert(0x1c, 0x04)\\n            }\\n            result := shl(shl(3, sub(32, result)), mload(add(s, result)))\\n        }\\n    }\\n\\n    /// @dev Returns a lowercased copy of the string.\\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\\n    function lower(string memory subject) internal pure returns (string memory result) {\\n        result = toCase(subject, false);\\n    }\\n\\n    /// @dev Returns an UPPERCASED copy of the string.\\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\\n    function upper(string memory subject) internal pure returns (string memory result) {\\n        result = toCase(subject, true);\\n    }\\n\\n    /// @dev Escapes the string to be used within HTML tags.\\n    function escapeHTML(string memory s) internal pure returns (string memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let end := add(s, mload(s))\\n            result := add(mload(0x40), 0x20)\\n            // Store the bytes of the packed offsets and strides into the scratch space.\\n            // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.\\n            mstore(0x1f, 0x900094)\\n            mstore(0x08, 0xc0000000a6ab)\\n            // Store \\\"&quot;&amp;&#39;&lt;&gt;\\\" into the scratch space.\\n            mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))\\n            for {} iszero(eq(s, end)) {} {\\n                s := add(s, 1)\\n                let c := and(mload(s), 0xff)\\n                // Not in `[\\\"\\\\\\\"\\\",\\\"'\\\",\\\"&\\\",\\\"<\\\",\\\">\\\"]`.\\n                if iszero(and(shl(c, 1), 0x500000c400000000)) {\\n                    mstore8(result, c)\\n                    result := add(result, 1)\\n                    continue\\n                }\\n                let t := shr(248, mload(c))\\n                mstore(result, mload(and(t, 0x1f)))\\n                result := add(result, shr(5, t))\\n            }\\n            let last := result\\n            mstore(last, 0) // Zeroize the slot after the string.\\n            result := mload(0x40)\\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\\n    /// If `addDoubleQuotes` is true, the result will be enclosed in double-quotes.\\n    function escapeJSON(string memory s, bool addDoubleQuotes)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let end := add(s, mload(s))\\n            result := add(mload(0x40), 0x20)\\n            if addDoubleQuotes {\\n                mstore8(result, 34)\\n                result := add(1, result)\\n            }\\n            // Store \\\"\\\\\\\\u0000\\\" in scratch space.\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            // Also, store `{0x08:\\\"b\\\", 0x09:\\\"t\\\", 0x0a:\\\"n\\\", 0x0c:\\\"f\\\", 0x0d:\\\"r\\\"}`.\\n            // into the scratch space.\\n            mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)\\n            // Bitmask for detecting `[\\\"\\\\\\\"\\\",\\\"\\\\\\\\\\\"]`.\\n            let e := or(shl(0x22, 1), shl(0x5c, 1))\\n            for {} iszero(eq(s, end)) {} {\\n                s := add(s, 1)\\n                let c := and(mload(s), 0xff)\\n                if iszero(lt(c, 0x20)) {\\n                    if iszero(and(shl(c, 1), e)) {\\n                        // Not in `[\\\"\\\\\\\"\\\",\\\"\\\\\\\\\\\"]`.\\n                        mstore8(result, c)\\n                        result := add(result, 1)\\n                        continue\\n                    }\\n                    mstore8(result, 0x5c) // \\\"\\\\\\\\\\\".\\n                    mstore8(add(result, 1), c)\\n                    result := add(result, 2)\\n                    continue\\n                }\\n                if iszero(and(shl(c, 1), 0x3700)) {\\n                    // Not in `[\\\"\\\\b\\\",\\\"\\\\t\\\",\\\"\\\\n\\\",\\\"\\\\f\\\",\\\"\\\\d\\\"]`.\\n                    mstore8(0x1d, mload(shr(4, c))) // Hex value.\\n                    mstore8(0x1e, mload(and(c, 15))) // Hex value.\\n                    mstore(result, mload(0x19)) // \\\"\\\\\\\\u00XX\\\".\\n                    result := add(result, 6)\\n                    continue\\n                }\\n                mstore8(result, 0x5c) // \\\"\\\\\\\\\\\".\\n                mstore8(add(result, 1), mload(add(c, 8)))\\n                result := add(result, 2)\\n            }\\n            if addDoubleQuotes {\\n                mstore8(result, 34)\\n                result := add(1, result)\\n            }\\n            let last := result\\n            mstore(last, 0) // Zeroize the slot after the string.\\n            result := mload(0x40)\\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\\n    function escapeJSON(string memory s) internal pure returns (string memory result) {\\n        result = escapeJSON(s, false);\\n    }\\n\\n    /// @dev Returns whether `a` equals `b`.\\n    function eq(string memory a, string memory b) internal pure returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))\\n        }\\n    }\\n\\n    /// @dev Returns whether `a` equals `b`, where `b` is a null-terminated small string.\\n    function eqs(string memory a, bytes32 b) internal pure returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // These should be evaluated on compile time, as far as possible.\\n            let m := not(shl(7, div(not(iszero(b)), 255))) // `0x7f7f ...`.\\n            let x := not(or(m, or(b, add(m, and(b, m)))))\\n            let r := shl(7, iszero(iszero(shr(128, x))))\\n            r := or(r, shl(6, iszero(iszero(shr(64, shr(r, x))))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\\n            // forgefmt: disable-next-item\\n            result := gt(eq(mload(a), add(iszero(x), xor(31, shr(3, r)))),\\n                xor(shr(add(8, r), b), shr(add(8, r), mload(add(a, 0x20)))))\\n        }\\n    }\\n\\n    /// @dev Packs a single string with its length into a single word.\\n    /// Returns `bytes32(0)` if the length is zero or greater than 31.\\n    function packOne(string memory a) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We don't need to zero right pad the string,\\n            // since this is our own custom non-standard packing scheme.\\n            result :=\\n                mul(\\n                    // Load the length and the bytes.\\n                    mload(add(a, 0x1f)),\\n                    // `length != 0 && length < 32`. Abuses underflow.\\n                    // Assumes that the length is valid and within the block gas limit.\\n                    lt(sub(mload(a), 1), 0x1f)\\n                )\\n        }\\n    }\\n\\n    /// @dev Unpacks a string packed using {packOne}.\\n    /// Returns the empty string if `packed` is `bytes32(0)`.\\n    /// If `packed` is not an output of {packOne}, the output behavior is undefined.\\n    function unpackOne(bytes32 packed) internal pure returns (string memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Grab the free memory pointer.\\n            result := mload(0x40)\\n            // Allocate 2 words (1 for the length, 1 for the bytes).\\n            mstore(0x40, add(result, 0x40))\\n            // Zeroize the length slot.\\n            mstore(result, 0)\\n            // Store the length and bytes.\\n            mstore(add(result, 0x1f), packed)\\n            // Right pad with zeroes.\\n            mstore(add(add(result, 0x20), mload(result)), 0)\\n        }\\n    }\\n\\n    /// @dev Packs two strings with their lengths into a single word.\\n    /// Returns `bytes32(0)` if combined length is zero or greater than 30.\\n    function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let aLength := mload(a)\\n            // We don't need to zero right pad the strings,\\n            // since this is our own custom non-standard packing scheme.\\n            result :=\\n                mul(\\n                    // Load the length and the bytes of `a` and `b`.\\n                    or(\\n                        shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))),\\n                        mload(sub(add(b, 0x1e), aLength))\\n                    ),\\n                    // `totalLength != 0 && totalLength < 31`. Abuses underflow.\\n                    // Assumes that the lengths are valid and within the block gas limit.\\n                    lt(sub(add(aLength, mload(b)), 1), 0x1e)\\n                )\\n        }\\n    }\\n\\n    /// @dev Unpacks strings packed using {packTwo}.\\n    /// Returns the empty strings if `packed` is `bytes32(0)`.\\n    /// If `packed` is not an output of {packTwo}, the output behavior is undefined.\\n    function unpackTwo(bytes32 packed)\\n        internal\\n        pure\\n        returns (string memory resultA, string memory resultB)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Grab the free memory pointer.\\n            resultA := mload(0x40)\\n            resultB := add(resultA, 0x40)\\n            // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.\\n            mstore(0x40, add(resultB, 0x40))\\n            // Zeroize the length slots.\\n            mstore(resultA, 0)\\n            mstore(resultB, 0)\\n            // Store the lengths and bytes.\\n            mstore(add(resultA, 0x1f), packed)\\n            mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))\\n            // Right pad with zeroes.\\n            mstore(add(add(resultA, 0x20), mload(resultA)), 0)\\n            mstore(add(add(resultB, 0x20), mload(resultB)), 0)\\n        }\\n    }\\n\\n    /// @dev Directly returns `a` without copying.\\n    function directReturn(string memory a) internal pure {\\n        assembly {\\n            // Assumes that the string does not start from the scratch space.\\n            let retStart := sub(a, 0x20)\\n            let retSize := add(mload(a), 0x40)\\n            // Right pad with zeroes. Just in case the string is produced\\n            // by a method that doesn't zero right pad.\\n            mstore(add(retStart, retSize), 0)\\n            // Store the return offset.\\n            mstore(retStart, 0x20)\\n            // End the transaction, returning the string.\\n            return(retStart, retSize)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf9089e94e05f506f21357bc513c166d58f4d6a02d589741c72e8a7722cefeda2\",\"license\":\"MIT\"},\"solidity-rlp/contracts/RLPReader.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * @author Hamdi Allam hamdi.allam97@gmail.com\\n * Please reach out with any questions or concerns\\n */\\npragma solidity >=0.5.10 <0.9.0;\\n\\nlibrary RLPReader {\\n    uint8 constant STRING_SHORT_START = 0x80;\\n    uint8 constant STRING_LONG_START = 0xb8;\\n    uint8 constant LIST_SHORT_START = 0xc0;\\n    uint8 constant LIST_LONG_START = 0xf8;\\n    uint8 constant WORD_SIZE = 32;\\n\\n    struct RLPItem {\\n        uint256 len;\\n        uint256 memPtr;\\n    }\\n\\n    struct Iterator {\\n        RLPItem item; // Item that's being iterated over.\\n        uint256 nextPtr; // Position of the next item in the list.\\n    }\\n\\n    /*\\n     * @dev Returns the next element in the iteration. Reverts if it has not next element.\\n     * @param self The iterator.\\n     * @return The next element in the iteration.\\n     */\\n    function next(Iterator memory self) internal pure returns (RLPItem memory) {\\n        require(hasNext(self));\\n\\n        uint256 ptr = self.nextPtr;\\n        uint256 itemLength = _itemLength(ptr);\\n        self.nextPtr = ptr + itemLength;\\n\\n        return RLPItem(itemLength, ptr);\\n    }\\n\\n    /*\\n     * @dev Returns true if the iteration has more elements.\\n     * @param self The iterator.\\n     * @return true if the iteration has more elements.\\n     */\\n    function hasNext(Iterator memory self) internal pure returns (bool) {\\n        RLPItem memory item = self.item;\\n        return self.nextPtr < item.memPtr + item.len;\\n    }\\n\\n    /*\\n     * @param item RLP encoded bytes\\n     */\\n    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\\n        uint256 memPtr;\\n        assembly {\\n            memPtr := add(item, 0x20)\\n        }\\n\\n        return RLPItem(item.length, memPtr);\\n    }\\n\\n    /*\\n     * @dev Create an iterator. Reverts if item is not a list.\\n     * @param self The RLP item.\\n     * @return An 'Iterator' over the item.\\n     */\\n    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {\\n        require(isList(self));\\n\\n        uint256 ptr = self.memPtr + _payloadOffset(self.memPtr);\\n        return Iterator(self, ptr);\\n    }\\n\\n    /*\\n     * @param the RLP item.\\n     */\\n    function rlpLen(RLPItem memory item) internal pure returns (uint256) {\\n        return item.len;\\n    }\\n\\n    /*\\n     * @param the RLP item.\\n     * @return (memPtr, len) pair: location of the item's payload in memory.\\n     */\\n    function payloadLocation(RLPItem memory item) internal pure returns (uint256, uint256) {\\n        uint256 offset = _payloadOffset(item.memPtr);\\n        uint256 memPtr = item.memPtr + offset;\\n        uint256 len = item.len - offset; // data length\\n        return (memPtr, len);\\n    }\\n\\n    /*\\n     * @param the RLP item.\\n     */\\n    function payloadLen(RLPItem memory item) internal pure returns (uint256) {\\n        (, uint256 len) = payloadLocation(item);\\n        return len;\\n    }\\n\\n    /*\\n     * @param the RLP item containing the encoded list.\\n     */\\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {\\n        require(isList(item));\\n\\n        uint256 items = numItems(item);\\n        RLPItem[] memory result = new RLPItem[](items);\\n\\n        uint256 memPtr = item.memPtr + _payloadOffset(item.memPtr);\\n        uint256 dataLen;\\n        for (uint256 i = 0; i < items; i++) {\\n            dataLen = _itemLength(memPtr);\\n            result[i] = RLPItem(dataLen, memPtr);\\n            memPtr = memPtr + dataLen;\\n        }\\n\\n        return result;\\n    }\\n\\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\\n    function isList(RLPItem memory item) internal pure returns (bool) {\\n        if (item.len == 0) return false;\\n\\n        uint8 byte0;\\n        uint256 memPtr = item.memPtr;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 < LIST_SHORT_START) return false;\\n        return true;\\n    }\\n\\n    /*\\n     * @dev A cheaper version of keccak256(toRlpBytes(item)) that avoids copying memory.\\n     * @return keccak256 hash of RLP encoded bytes.\\n     */\\n    function rlpBytesKeccak256(RLPItem memory item) internal pure returns (bytes32) {\\n        uint256 ptr = item.memPtr;\\n        uint256 len = item.len;\\n        bytes32 result;\\n        assembly {\\n            result := keccak256(ptr, len)\\n        }\\n        return result;\\n    }\\n\\n    /*\\n     * @dev A cheaper version of keccak256(toBytes(item)) that avoids copying memory.\\n     * @return keccak256 hash of the item payload.\\n     */\\n    function payloadKeccak256(RLPItem memory item) internal pure returns (bytes32) {\\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\\n        bytes32 result;\\n        assembly {\\n            result := keccak256(memPtr, len)\\n        }\\n        return result;\\n    }\\n\\n    /** RLPItem conversions into data types **/\\n\\n    // @returns raw rlp encoding in bytes\\n    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {\\n        bytes memory result = new bytes(item.len);\\n        if (result.length == 0) return result;\\n\\n        uint256 ptr;\\n        assembly {\\n            ptr := add(0x20, result)\\n        }\\n\\n        copy(item.memPtr, ptr, item.len);\\n        return result;\\n    }\\n\\n    // any non-zero byte except \\\"0x80\\\" is considered true\\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\\n        require(item.len == 1);\\n        uint256 result;\\n        uint256 memPtr = item.memPtr;\\n        assembly {\\n            result := byte(0, mload(memPtr))\\n        }\\n\\n        // SEE Github Issue #5.\\n        // Summary: Most commonly used RLP libraries (i.e Geth) will encode\\n        // \\\"0\\\" as \\\"0x80\\\" instead of as \\\"0\\\". We handle this edge case explicitly\\n        // here.\\n        if (result == 0 || result == STRING_SHORT_START) {\\n            return false;\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    function toAddress(RLPItem memory item) internal pure returns (address) {\\n        // 1 byte for the length prefix\\n        require(item.len == 21);\\n\\n        return address(uint160(toUint(item)));\\n    }\\n\\n    function toUint(RLPItem memory item) internal pure returns (uint256) {\\n        require(item.len > 0 && item.len <= 33);\\n\\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\\n\\n        uint256 result;\\n        assembly {\\n            result := mload(memPtr)\\n\\n            // shift to the correct location if neccesary\\n            if lt(len, 32) {\\n                result := div(result, exp(256, sub(32, len)))\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    // enforces 32 byte length\\n    function toUintStrict(RLPItem memory item) internal pure returns (uint256) {\\n        // one byte prefix\\n        require(item.len == 33);\\n\\n        uint256 result;\\n        uint256 memPtr = item.memPtr + 1;\\n        assembly {\\n            result := mload(memPtr)\\n        }\\n\\n        return result;\\n    }\\n\\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\\n        require(item.len > 0);\\n\\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\\n        bytes memory result = new bytes(len);\\n\\n        uint256 destPtr;\\n        assembly {\\n            destPtr := add(0x20, result)\\n        }\\n\\n        copy(memPtr, destPtr, len);\\n        return result;\\n    }\\n\\n    /*\\n     * Private Helpers\\n     */\\n\\n    // @return number of payload items inside an encoded list.\\n    function numItems(RLPItem memory item) private pure returns (uint256) {\\n        if (item.len == 0) return 0;\\n\\n        uint256 count = 0;\\n        uint256 currPtr = item.memPtr + _payloadOffset(item.memPtr);\\n        uint256 endPtr = item.memPtr + item.len;\\n        while (currPtr < endPtr) {\\n            currPtr = currPtr + _itemLength(currPtr); // skip over an item\\n            count++;\\n        }\\n\\n        return count;\\n    }\\n\\n    // @return entire rlp item byte length\\n    function _itemLength(uint256 memPtr) private pure returns (uint256) {\\n        uint256 itemLen;\\n        uint256 byte0;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 < STRING_SHORT_START) {\\n            itemLen = 1;\\n        } else if (byte0 < STRING_LONG_START) {\\n            itemLen = byte0 - STRING_SHORT_START + 1;\\n        } else if (byte0 < LIST_SHORT_START) {\\n            assembly {\\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\\n                memPtr := add(memPtr, 1) // skip over the first byte\\n\\n                /* 32 byte word size */\\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\\n                itemLen := add(dataLen, add(byteLen, 1))\\n            }\\n        } else if (byte0 < LIST_LONG_START) {\\n            itemLen = byte0 - LIST_SHORT_START + 1;\\n        } else {\\n            assembly {\\n                let byteLen := sub(byte0, 0xf7)\\n                memPtr := add(memPtr, 1)\\n\\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\\n                itemLen := add(dataLen, add(byteLen, 1))\\n            }\\n        }\\n\\n        return itemLen;\\n    }\\n\\n    // @return number of bytes until the data\\n    function _payloadOffset(uint256 memPtr) private pure returns (uint256) {\\n        uint256 byte0;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 < STRING_SHORT_START) {\\n            return 0;\\n        } else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START)) {\\n            return 1;\\n        } else if (byte0 < LIST_SHORT_START) {\\n            // being explicit\\n            return byte0 - (STRING_LONG_START - 1) + 1;\\n        } else {\\n            return byte0 - (LIST_LONG_START - 1) + 1;\\n        }\\n    }\\n\\n    /*\\n     * @param src Pointer to source\\n     * @param dest Pointer to destination\\n     * @param len Amount of memory to copy from the source\\n     */\\n    function copy(uint256 src, uint256 dest, uint256 len) private pure {\\n        if (len == 0) return;\\n\\n        // copy as many word sizes as possible\\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n\\n            src += WORD_SIZE;\\n            dest += WORD_SIZE;\\n        }\\n\\n        if (len > 0) {\\n            // left over bytes. Mask is used to remove unwanted bytes from the word\\n            uint256 mask = 256**(WORD_SIZE - len) - 1;\\n            assembly {\\n                let srcpart := and(mload(src), not(mask)) // zero out src\\n                let destpart := and(mload(dest), mask) // retrieve the bytes\\n                mstore(dest, or(destpart, srcpart))\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x3a44f2de3c752fa4f926f3fd4cad8338dab742484150c0d7d2f785409ed8db4d\",\"license\":\"Apache-2.0\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b506158a080620000216000396000f3fe60806040526004361061010d5760003560e01c8063b72a654011610095578063d86cd69a11610064578063d86cd69a14610383578063e0a388fb146103ae578063e2411625146103d9578063ea42418b14610402578063f77c47911461042d5761010e565b8063b72a6540146102db578063cf1b037c14610306578063d3596e7f1461032f578063d40ec0661461035a5761010e565b806350723553116100dc57806350723553146101e057806357e3c1b51461021d5780637e48532c1461025a578063847b8150146102855780639829ba42146102b05761010e565b80630de8cb93146101105780631d148b8d1461014d57806323b17abc1461018a5780632e0f2625146101b55761010e565b5b005b34801561011c57600080fd5b5061013760048036038101906101329190613b6c565b610458565b6040516101449190613c8b565b60405180910390f35b34801561015957600080fd5b50610174600480360381019061016f9190613d4e565b61053f565b6040516101819190613c8b565b60405180910390f35b34801561019657600080fd5b5061019f6106b0565b6040516101ac9190613dec565b60405180910390f35b3480156101c157600080fd5b506101ca6106cc565b6040516101d79190613e2a565b60405180910390f35b3480156101ec57600080fd5b5061020760048036038101906102029190613e45565b6106d1565b6040516102149190613e9d565b60405180910390f35b34801561022957600080fd5b50610244600480360381019061023f9190613f16565b61075d565b6040516102519190613c8b565b60405180910390f35b34801561026657600080fd5b5061026f610923565b60405161027c9190613c8b565b60405180910390f35b34801561029157600080fd5b5061029a610a60565b6040516102a79190613dec565b60405180910390f35b3480156102bc57600080fd5b506102c5610a7c565b6040516102d29190613dec565b60405180910390f35b3480156102e757600080fd5b506102f0610ab5565b6040516102fd9190613dec565b60405180910390f35b34801561031257600080fd5b5061032d60048036038101906103289190613f16565b610ad1565b005b34801561033b57600080fd5b50610344610ba6565b6040516103519190613f90565b60405180910390f35b34801561036657600080fd5b50610381600480360381019061037c9190613fab565b610bb9565b005b34801561038f57600080fd5b50610398610bf6565b6040516103a59190613dec565b60405180910390f35b3480156103ba57600080fd5b506103c3610c2f565b6040516103d09190613e9d565b60405180910390f35b3480156103e557600080fd5b5061040060048036038101906103fb9190614033565b610c35565b005b34801561040e57600080fd5b50610417610d0b565b6040516104249190614082565b60405180910390f35b34801561043957600080fd5b50610442610d31565b60405161044f9190614082565b60405180910390f35b60606104a0610465610d57565b6040518060400160405280601081526020017f4e6f7420636f6e666964656e7469616c00000000000000000000000000000000815250610e1f565b60006104ab876106d1565b90506104bb878288888888610e65565b63d40ec06660e01b87826040516024016104d692919061409d565b604051602081830303815290604052907bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff838183161783525050505091505095945050505050565b6060600061054c83610e9e565b60405160200161055c91906141c7565b60405160208183030381529060405290506105756138ba565b6040518060400160405280600481526020017f504f5354000000000000000000000000000000000000000000000000000000008152508160200181905250818160600181905250600167ffffffffffffffff8111156105d7576105d6613993565b5b60405190808252806020026020018201604052801561060a57816020015b60608152602001906001900390816105f55790505b5081604001819052506040518060400160405280601e81526020017f436f6e74656e742d547970653a206170706c69636174696f6e2f6a736f6e00008152508160400151600081518110610661576106606141f4565b5b602002602001018190525060008160800190151590811515815250506040518060600160405280602b815260200161581d602b913981600001819052506106a781610ec4565b92505050919050565b6040518060600160405280602381526020016158486023913981565b600481565b6000806106dd83610f7d565b905060006106ea82611122565b9050600061073e6107396040518060400160405280600781526020017f22707269636522000000000000000000000000000000000000000000000000008152508461114e90919063ffffffff16565b6111d1565b905061075361074c826111f3565b60046112c0565b9350505050919050565b60606107a561076a610d57565b6040518060400160405280601081526020017f4e6f7420636f6e666964656e7469616c00000000000000000000000000000000815250610e1f565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16148061084f5750600073ffffffffffffffffffffffffffffffffffffffff16600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16145b61088e576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016108859061426f565b60405180910390fd5b600061089983611487565b90506108a48161053f565b5063cf1b037c60e01b836040516024016108be9190614082565b604051602081830303815290604052907bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff8381831617835250505050915050919050565b606061096b610930610d57565b6040518060400160405280601081526020017f4e6f7420636f6e666964656e7469616c00000000000000000000000000000000815250610e1f565b6109b860008054906101000a900460ff16156040518060400160405280601381526020017f416c726561647920696e697469616c697a656400000000000000000000000000815250610e1f565b60006109c46000611625565b905060006109d18261171c565b905060006109de83611788565b905063e241162560e01b81836040516024016109fb92919061428f565b604051602081830303815290604052907bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff8381831617835250505050935050505090565b6040518060600160405280602b815260200161581d602b913981565b6040518060400160405280601281526020017f6f7261636c653a76303a706b736563726574000000000000000000000000000081525081565b6040518060600160405280603b81526020016157e2603b913981565b600073ffffffffffffffffffffffffffffffffffffffff16600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1614610b62576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610b599061426f565b60405180910390fd5b80600260006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050565b600060019054906101000a900460801b81565b7ff61f2fd6ab65716facd3516c91d806d98dffa9670f127beac522f8cacfd1d8df8282604051610bea92919061409d565b60405180910390a15050565b6040518060400160405280600681526020017f307834323638000000000000000000000000000000000000000000000000000081525081565b61426881565b610c8260008054906101000a900460ff16156040518060400160405280601381526020017f416c726561647920696e697469616c697a656400000000000000000000000000815250610e1f565b81600060016101000a8154816fffffffffffffffffffffffffffffffff021916908360801c021790555080600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060016000806101000a81548160ff0219169083151502179055505050565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6000806000634201000073ffffffffffffffffffffffffffffffffffffffff16604051610d83906142e9565b600060405180830381855afa9150503d8060008114610dbe576040519150601f19603f3d011682016040523d82523d6000602084013e610dc3565b606091505b509150915081610e10576342010000816040517f75fff467000000000000000000000000000000000000000000000000000000008152600401610e079291906142fe565b60405180910390fd5b80516020820151935050505090565b81610e6157806040517f0c25cd98000000000000000000000000000000000000000000000000000000008152600401610e589190613dec565b60405180910390fd5b5050565b6000610e7387878787611964565b90508115610e8a57610e858184611b2e565b610e95565b610e938161053f565b505b50505050505050565b6060610ea982611b45565b90506002815101613078825260028203915080825250919050565b6060600080634320000273ffffffffffffffffffffffffffffffffffffffff1684604051602001610ef5919061451e565b604051602081830303815290604052604051610f119190614571565b600060405180830381855afa9150503d8060008114610f4c576040519150601f19603f3d011682016040523d82523d6000602084013e610f51565b606091505b5091509150610f608282610e1f565b80806020019051810190610f7491906145f8565b92505050919050565b60606000600167ffffffffffffffff811115610f9c57610f9b613993565b5b604051908082528060200260200182016040528015610fcf57816020015b6060815260200190600190039081610fba5790505b5090506040518060400160405280601e81526020017f436f6e74656e742d547970653a206170706c69636174696f6e2f6a736f6e00008152508160008151811061101c5761101b6141f4565b5b602002602001018190525060006040518060a001604052806040518060600160405280603b81526020016157e2603b91398660405160200161105f929190614641565b60405160208183030381529060405281526020016040518060400160405280600381526020017f47455400000000000000000000000000000000000000000000000000000000008152508152602001838152602001600067ffffffffffffffff8111156110cf576110ce613993565b5b6040519080825280601f01601f1916602001820160405280156111015781602001600182028036833780820191505090505b50815260200160001515815250905061111981610ec4565b92505050919050565b61112a6138eb565b80604052600061114361113c84611bb3565b60ff611bbd565b905080915050919050565b6111566138eb565b806040526060905061116783612481565b156111cb57600082805190602001209050600061118385612498565b9050600060058251901b90505b600081146111c757808201519550602081039050826111ae876124ba565b80519060200120036111c2578593506111c7565b611190565b5050505b92915050565b606060006111e86111e1846124ec565b6000611bbd565b905080915050919050565b60606000829050600281511161123e576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611235906146b1565b60405180910390fd5b60006002825161124e9190614700565b905060008167ffffffffffffffff81111561126c5761126b613993565b5b6040519080825280601f01601f19166020018201604052801561129e5781602001600182028036833780820191505090505b5090506021830160208201845182518252848452505050809350505050919050565b600080839050600080600090505b825181101561133c57602e60f81b8382815181106112ef576112ee6141f4565b5b602001015160f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916036113295780915061133c565b808061133490614734565b9150506112ce565b5060008060006001905060008490505b60008111156113cb57816030876001846113669190614700565b81518110611377576113766141f4565b5b602001015160f81c60f81b60f81c61138f919061477c565b60ff1661139c91906147b0565b846113a7919061480a565b9350600a826113b691906147b0565b915080806113c390614860565b91505061134c565b506001905060008760ff16856113e1919061480a565b90505b8481111561145657816030878381518110611402576114016141f4565b5b602001015160f81c60f81b60f81c61141a919061477c565b60ff1661142791906147b0565b83611432919061480a565b9250600a8261144191906147b0565b9150808061144e90614860565b9150506113e4565b508187600a61146591906149bc565b8461147091906147b0565b61147a919061480a565b9550505050505092915050565b606060006040518061014001604052808473ffffffffffffffffffffffffffffffffffffffff168152602001620186a0815260200164174876e800815260200160008152602001600081526020016040516024016040516020818303038152906040527f1aa3a008000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff8381831617835250505050815260200161426881526020017f111111111111111111111111111111111111111111111111111111111111111181526020017f11111111111111111111111111111111111111111111111111111111111111118152602001601b67ffffffffffffffff16815250905060006115cd826124f6565b905060006115d96127a7565b905061161b826040518060400160405280600681526020017f307834323638000000000000000000000000000000000000000000000000000081525083612802565b9350505050919050565b6060600080635320000373ffffffffffffffffffffffffffffffffffffffff16846040516020016116569190614a7e565b6040516020818303038152906040526040516116729190614571565b600060405180830381855afa9150503d80600081146116ad576040519150601f19603f3d011682016040523d82523d6000602084013e6116b2565b606091505b5091509150816116ff576353200003816040517f75fff4670000000000000000000000000000000000000000000000000000000081526004016116f69291906142fe565b60405180910390fd5b808060200190518101906117139190614b09565b92505050919050565b60008060405160200161172e90614b9e565b60405160208183030381529060405280519060200120905060006117738260405160200161175c9190614be9565b6040516020818303038152906040526000866128ff565b905061177f8282612a0d565b92505050919050565b600080600367ffffffffffffffff8111156117a6576117a5613993565b5b6040519080825280602002602001820160405280156117d45781602001602082028036833780820191505090505b50905030816000815181106117ec576117eb6141f4565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff168152505063420300018160018151811061183f5761183e6141f4565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff1681525050634202000181600281518110611892576118916141f4565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250506000611910600083846040518060400160405280601281526020017f6f7261636c653a76303a706b7365637265740000000000000000000000000000815250612a7c565b905061195681600001516040518060400160405280601281526020017f6f7261636c653a76303a706b736563726574000000000000000000000000000081525086612b82565b806000015192505050919050565b60606000604051806101400160405280600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001620186a081526020018481526020016000815260200185815260200187876040516024016119e192919061409d565b6040516020818303038152906040527f4a432a46000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff8381831617835250505050815260200161426881526020017f111111111111111111111111111111111111111111111111111111111111111181526020017f11111111111111111111111111111111111111111111111111111111111111118152602001601b67ffffffffffffffff1681525090506000611ad3826124f6565b90506000611adf6127a7565b9050611b21826040518060400160405280600681526020017f307834323638000000000000000000000000000000000000000000000000000081525083612802565b9350505050949350505050565b611b3782612c65565b611b418282612d50565b5050565b60608151600260405101915080810182526f30313233343536373839616263646566600f52602082018184015b808514611ba057600185019450600f855116516001830153600f855160041c16518253600282019150611b72565b6000825260208201604052505050919050565b6000819050919050565b60006123c9565b63101827966000526004601cfd5b6000815160001a9050919050565b60008190505b600115611c10576001640100002600611bfe83611bd2565b1c1615611c1157600181019050611be6565b5b92915050565b600063ffffffff84113d3d3e83831b8263ffffffff851b19161790509392505050565b600081831c63ffffffff16905092915050565b60006040519050611c728486036078611c6d602086018803605888611c17565b611c17565b925085831781526020810160405295945050505050565b600080611c9a846018600051611c17565b611ca48787611be0565b9150868210611cb35750611e06565b611cbc82611bd2565b600115611df75760228103611cf05782611cd889858589612048565b9350611ce860048583868a611c4d565b945050611df7565b605b8103611d0d57611d0488848488611e0f565b93509350611df7565b607b8103611d2a57611d2188848488611ee7565b93509350611df7565b6001611ff9602d1b821c1615611d4f57611d4688848488612157565b93509350611df7565b876004840111611db25782835160e01c63747275658103611d8757600485019450611d7e60058684878b611c4d565b95505050611df7565b636e756c6c8103611daf57600485019450611da660068684878b611c4d565b95505050611df7565b50505b876005840111611dee5782835160d81c6466616c73658103611deb57600585019450611de260058684878b611c4d565b95505050611df7565b50505b611df6611bc4565b5b50611e028783611be0565b9150505b94509492505050565b60008060006001860191505b600115611eb957868210611e3257611e31611bc4565b5b82611e5557611e418783611be0565b9150605d611e4e83611bd2565b0315611eb9575b611e6187838587611c89565b925092508215611eaa57611e7b8160988551604017611c17565b8352600181019050611e8c82611bd2565b605d8103611e9a5750611eb9565b602c8103611ea85750611eae565b505b8691505b600182019150611e1b565b600182019150611ecb83603887611c17565b9450611edb600183888888611c4d565b92505094509492505050565b6000806001850190505b600115611fda57858110611f0857611f07611bc4565b5b81611f2b57611f178682611be0565b9050607d611f2482611bd2565b0315611fda575b611f358682611be0565b905080611f4487838587612048565b611f4e8882611be0565b9250603a611f5b84611bd2565b03611fc957611f6f88600185018688611c89565b935093508315611fc857611f9b6020860183036098611f9685850360b88951608017611c17565b611c17565b8452611fa683611bd2565b607d8103611fb657505050611fda565b602c8103611fc657505050611fcf565b505b5b87925050505b600181019050611ef1565b600181019050611fec82603886611c17565b9350611ffc600282878787611c4d565b915094509492505050565b6001667e0000007e03ff603061201e858501611bd2565b031c1661202e5761202d611bc4565b5b60058214612044576120436001830182612007565b5b5050565b600084841061205a57612059611bc4565b5b6001840190505b6001156120f35761207181611bd2565b6022810361207f57506120f3565b605c811461209357600182019150506120ee565b61209f60018301611bd2565b905060016a0510110400000000002001602283031c16156120c657600282019150506120ee565b607581036120e5576120d9600283612007565b600682019150506120ee565b859150506120f3565b612061565b84811061210357612102611bc4565b5b600181019050949350505050565b60008190505b60011561213d57600a603061212b83611bd2565b03101561213d57600181019050612117565b8082148416156121505761214f611bc4565b5b9392505050565b600080849050602d61216882611bd2565b03612174576001810190505b600a603061218183611bd2565b03106121905761218f611bc4565b5b61219981611bd2565b600182019150603081146121b6576121b360008884612111565b91505b602e6121c183611bd2565b036121d8576121d560018860018501612111565b91505b815160658160001a60201703612207576122046001896001860162010001600e8660011a031a01612111565b92505b612215600384898989611c4d565b9350505094509492505050565b600060405190508282019150601f1980601f8601165b600115612252578084015181840152818101905080612238575b50848252600085602084010152846040830101604052509392505050565b60006060905081516002816007161161235c57821581151761235c5760208116156122a7576122a0603882611c3a565b915061235c565b6040519150602082016122bb603883611c3a565b5b80156122f05780825280516122d2601882611c3a565b6122de87601884611c17565b835280925060208401935050506122bc565b50601f1983820381018060051c85528260405261230f85603886611c17565b93508360201786526040811061235857602085018186015b60011561235557815181518352808252848201915060208301925081831061234f5750612355565b50612327565b50505b5050505b50919050565b600060609050815180158315171561237a57506123c1565b6123848482611c3a565b91508086166123bf5761239860d882611c3a565b6123ac6123a58784611c3a565b8483612222565b92506123b9838684611c17565b87178452505b505b949350505050565b81600081146124425760018114612458576003811461246e576020840184518101808214612427576123fa81611bd2565b6022825361240e8760d8602260f81b611c17565b60005261241e828460008a611c89565b93509450808253505b8315818310171561243b5761243a611bc4565b5b505061247a565b61245160106078605887612362565b915061247a565b612467600860b8609887612362565b915061247a565b61247784612270565b91505b5092915050565b6000600260ff166007836000015116149050919050565b606060006124af6124a8846124ec565b6003611bbd565b905080915050919050565b606060006080836000015116146124e75760006124e06124d9846124ec565b6001611bbd565b9050809150505b919050565b6000819050919050565b60606000600967ffffffffffffffff81111561251557612514613993565b5b60405190808252806020026020018201604052801561254857816020015b60608152602001906001900390816125335790505b5090506125588360800151612eb6565b8160008151811061256c5761256b6141f4565b5b60200260200101819052506125848360400151612eb6565b81600181518110612598576125976141f4565b5b60200260200101819052506125b08360200151612eb6565b816002815181106125c4576125c36141f4565b5b6020026020010181905250600073ffffffffffffffffffffffffffffffffffffffff16836000015173ffffffffffffffffffffffffffffffffffffffff16036126435761261f60405180602001604052806000815250612ed0565b81600381518110612633576126326141f4565b5b6020026020010181905250612670565b6126508360000151612f4e565b81600381518110612664576126636141f4565b5b60200260200101819052505b61267d8360600151612eb6565b81600481518110612691576126906141f4565b5b60200260200101819052506126a98360a00151612ed0565b816005815181106126bd576126bc6141f4565b5b60200260200101819052506126e083610120015167ffffffffffffffff16612eb6565b816006815181106126f4576126f36141f4565b5b602002602001018190525061272b8360e001516040516020016127179190614be9565b604051602081830303815290604052612ed0565b8160078151811061273f5761273e6141f4565b5b60200260200101819052506127778361010001516040516020016127639190614be9565b604051602081830303815290604052612ed0565b8160088151811061278b5761278a6141f4565b5b602002602001018190525061279f81612f7f565b915050919050565b606060006127f9600060019054906101000a900460801b6040518060400160405280601281526020017f6f7261636c653a76303a706b7365637265740000000000000000000000000000815250612fc3565b90508091505090565b6060600080634010000173ffffffffffffffffffffffffffffffffffffffff1686868660405160200161283793929190614c04565b6040516020818303038152906040526040516128539190614571565b600060405180830381855afa9150503d806000811461288e576040519150601f19603f3d011682016040523d82523d6000602084013e612893565b606091505b5091509150816128e0576340100001816040517f75fff4670000000000000000000000000000000000000000000000000000000081526004016128d79291906142fe565b60405180910390fd5b808060200190518101906128f491906145f8565b925050509392505050565b6060612909610d57565b61291257600080fd5b600080634010000373ffffffffffffffffffffffffffffffffffffffff1686868660405160200161294593929190614c50565b6040516020818303038152906040526040516129619190614571565b600060405180830381855afa9150503d806000811461299c576040519150601f19603f3d011682016040523d82523d6000602084013e6129a1565b606091505b5091509150816129ee576340100003816040517f75fff4670000000000000000000000000000000000000000000000000000000081526004016129e59291906142fe565b60405180910390fd5b80806020019051810190612a0291906145f8565b925050509392505050565b600080600080612a1c856130aa565b92509250925060018682858560405160008152602001604052604051612a459493929190614ca4565b6020604051602081039080840390855afa158015612a67573d6000803e3d6000fd5b50505060206040510351935050505092915050565b612a846138fe565b600080634203000073ffffffffffffffffffffffffffffffffffffffff1687878787604051602001612ab99493929190614db6565b604051602081830303815290604052604051612ad59190614571565b600060405180830381855afa9150503d8060008114612b10576040519150601f19603f3d011682016040523d82523d6000602084013e612b15565b606091505b509150915081612b62576342030000816040517f75fff467000000000000000000000000000000000000000000000000000000008152600401612b599291906142fe565b60405180910390fd5b80806020019051810190612b769190615015565b92505050949350505050565b600080634202000073ffffffffffffffffffffffffffffffffffffffff16858585604051602001612bb59392919061505e565b604051602081830303815290604052604051612bd19190614571565b600060405180830381855afa9150503d8060008114612c0c576040519150601f19603f3d011682016040523d82523d6000602084013e612c11565b606091505b509150915081612c5e576342020000816040517f75fff467000000000000000000000000000000000000000000000000000000008152600401612c559291906142fe565b60405180910390fd5b5050505050565b6000612c7082610e9e565b604051602001612c80919061513b565b6040516020818303038152906040529050600080634210000073ffffffffffffffffffffffffffffffffffffffff1683604051602001612cc09190613c8b565b604051602081830303815290604052604051612cdc9190614571565b600060405180830381855afa9150503d8060008114612d17576040519150601f19603f3d011682016040523d82523d6000602084013e612d1c565b606091505b5091509150612d4a8282604051602001612d3691906151b4565b604051602081830303815290604052610e1f565b50505050565b6000600167ffffffffffffffff811115612d6d57612d6c613993565b5b604051908082528060200260200182016040528015612da057816020015b6060815260200190600190039081612d8b5790505b5090508281600081518110612db857612db76141f4565b5b60200260200101819052506000612dd9828467ffffffffffffffff1661312e565b9050600080634300000173ffffffffffffffffffffffffffffffffffffffff166040518060600160405280602381526020016158486023913984604051602001612e24929190615222565b604051602081830303815290604052604051612e409190614571565b600060405180830381855afa9150503d8060008114612e7b576040519150601f19603f3d011682016040523d82523d6000602084013e612e80565b606091505b5091509150612eae8282604051602001612e9a91906152b8565b604051602081830303815290604052610e1f565b505050505050565b6060612ec9612ec48361324d565b612ed0565b9050919050565b60608060018351148015612f085750608083600081518110612ef557612ef46141f4565b5b602001015160f81c60f81b60f81c60ff16105b15612f1557829050612f45565b612f21835160806133d0565b83604051602001612f339291906152da565b60405160208183030381529060405290505b80915050919050565b6060612f7882604051602001612f649190615346565b604051602081830303815290604052612ed0565b9050919050565b60606000612f8c8361361c565b9050612f9a815160c06133d0565b81604051602001612fac9291906152da565b604051602081830303815290604052915050919050565b6060600080634202000173ffffffffffffffffffffffffffffffffffffffff168585604051602001612ff6929190615361565b6040516020818303038152906040526040516130129190614571565b600060405180830381855afa9150503d806000811461304d576040519150601f19603f3d011682016040523d82523d6000602084013e613052565b606091505b50915091508161309f576342020001816040517f75fff4670000000000000000000000000000000000000000000000000000000081526004016130969291906142fe565b60405180910390fd5b809250505092915050565b600080600060418451146130f3576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016130ea906153dd565b60405180910390fd5b6020840151925060408401519150606084015160001a9050601b8160ff16101561312757601b8161312491906153fd565b90505b9193909250565b6060600061313b836137ae565b60405160200161314b91906154cc565b604051602081830303815290604052905060005b8451811015613220578161318c86838151811061317f5761317e6141f4565b5b6020026020010151610e9e565b60405160200161319d929190615545565b6040516020818303038152906040529150600185516131bc9190614700565b8110156131ea57816040516020016131d491906155cb565b604051602081830303815290604052915061320d565b816040516020016131fb9190615639565b60405160208183030381529060405291505b808061321890614734565b91505061315f565b508060405160200161323291906156a7565b60405160208183030381529060405290508091505092915050565b606060008260405160200161326291906156ea565b604051602081830303815290604052905060005b60208110156132dc57600060f81b828281518110613297576132966141f4565b5b602001015160f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916036132dc5780806132d490614734565b915050613276565b60008160206132eb9190614700565b67ffffffffffffffff81111561330457613303613993565b5b6040519080825280601f01601f1916602001820160405280156133365781602001600182028036833780820191505090505b50905060005b81518110156133c45783838061335190614734565b945081518110613364576133636141f4565b5b602001015160f81c60f81b828281518110613382576133816141f4565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a90535080806133bc90614734565b91505061333c565b50809350505050919050565b606080603884101561348357600167ffffffffffffffff8111156133f7576133f6613993565b5b6040519080825280601f01601f1916602001820160405280156134295781602001600182028036833780820191505090505b509050828461343891906153fd565b60f81b8160008151811061344f5761344e6141f4565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a905350613612565b600080600190505b600081876134999190615734565b146134c15781806134a990614734565b925050610100816134ba91906147b0565b905061348b565b6001826134ce919061480a565b67ffffffffffffffff8111156134e7576134e6613993565b5b6040519080825280601f01601f1916602001820160405280156135195781602001600182028036833780820191505090505b5092506037858361352a91906153fd565b61353491906153fd565b60f81b8360008151811061354b5761354a6141f4565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a905350600190505b81811161360f5761010081836135959190614700565b6101006135a29190615765565b876135ad9190615734565b6135b791906157b0565b60f81b8382815181106135cd576135cc6141f4565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a905350808061360790614734565b91505061357f565b50505b8091505092915050565b6060600082510361367c57600067ffffffffffffffff81111561364257613641613993565b5b6040519080825280601f01601f1916602001820160405280156136745781602001600182028036833780820191505090505b5090506137a9565b600080600090505b83518110156136c9578381815181106136a05761369f6141f4565b5b602002602001015151826136b4919061480a565b915080806136c190614734565b915050613684565b60008267ffffffffffffffff8111156136e5576136e4613993565b5b6040519080825280601f01601f1916602001820160405280156137175781602001600182028036833780820191505090505b5090506000602082019050600092505b85518310156137a1576000868481518110613745576137446141f4565b5b602002602001015190506000602082019050613763838284516137d4565b878581518110613776576137756141f4565b5b6020026020010151518361378a919061480a565b92505050828061379990614734565b935050613727565b819450505050505b919050565b60606137b98261384a565b90506002815101613078825260028203915080825250919050565b6000839050600083905060008390505b6020811061382257815183526020836137fd919061480a565b925060208261380c919061480a565b915060208161381b9190614700565b90506137e4565b60006001826020036101000a0390508019835116818551168181178652505050505050505050565b606060806040510190506020810160405260008152806f30313233343536373839616263646566600f52600119835b6001156138a5578184019350600f8116516001850153600f8160041c165184538060081c905080613879575b50828203602084039350808452505050919050565b6040518060a00160405280606081526020016060815260200160608152602001606081526020016000151581525090565b6040518060200160405280600081525090565b6040518060c0016040528060006fffffffffffffffffffffffffffffffff1916815260200160006fffffffffffffffffffffffffffffffff19168152602001600067ffffffffffffffff1681526020016060815260200160608152602001606081525090565b6000604051905090565b600080fd5b600080fd5b600080fd5b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6139cb82613982565b810181811067ffffffffffffffff821117156139ea576139e9613993565b5b80604052505050565b60006139fd613964565b9050613a0982826139c2565b919050565b600067ffffffffffffffff821115613a2957613a28613993565b5b613a3282613982565b9050602081019050919050565b82818337600083830152505050565b6000613a61613a5c84613a0e565b6139f3565b905082815260208101848484011115613a7d57613a7c61397d565b5b613a88848285613a3f565b509392505050565b600082601f830112613aa557613aa4613978565b5b8135613ab5848260208601613a4e565b91505092915050565b6000819050919050565b613ad181613abe565b8114613adc57600080fd5b50565b600081359050613aee81613ac8565b92915050565b600067ffffffffffffffff82169050919050565b613b1181613af4565b8114613b1c57600080fd5b50565b600081359050613b2e81613b08565b92915050565b60008115159050919050565b613b4981613b34565b8114613b5457600080fd5b50565b600081359050613b6681613b40565b92915050565b600080600080600060a08688031215613b8857613b8761396e565b5b600086013567ffffffffffffffff811115613ba657613ba5613973565b5b613bb288828901613a90565b9550506020613bc388828901613adf565b9450506040613bd488828901613adf565b9350506060613be588828901613b1f565b9250506080613bf688828901613b57565b9150509295509295909350565b600081519050919050565b600082825260208201905092915050565b60005b83811015613c3d578082015181840152602081019050613c22565b83811115613c4c576000848401525b50505050565b6000613c5d82613c03565b613c678185613c0e565b9350613c77818560208601613c1f565b613c8081613982565b840191505092915050565b60006020820190508181036000830152613ca58184613c52565b905092915050565b600067ffffffffffffffff821115613cc857613cc7613993565b5b613cd182613982565b9050602081019050919050565b6000613cf1613cec84613cad565b6139f3565b905082815260208101848484011115613d0d57613d0c61397d565b5b613d18848285613a3f565b509392505050565b600082601f830112613d3557613d34613978565b5b8135613d45848260208601613cde565b91505092915050565b600060208284031215613d6457613d6361396e565b5b600082013567ffffffffffffffff811115613d8257613d81613973565b5b613d8e84828501613d20565b91505092915050565b600081519050919050565b600082825260208201905092915050565b6000613dbe82613d97565b613dc88185613da2565b9350613dd8818560208601613c1f565b613de181613982565b840191505092915050565b60006020820190508181036000830152613e068184613db3565b905092915050565b600060ff82169050919050565b613e2481613e0e565b82525050565b6000602082019050613e3f6000830184613e1b565b92915050565b600060208284031215613e5b57613e5a61396e565b5b600082013567ffffffffffffffff811115613e7957613e78613973565b5b613e8584828501613a90565b91505092915050565b613e9781613abe565b82525050565b6000602082019050613eb26000830184613e8e565b92915050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000613ee382613eb8565b9050919050565b613ef381613ed8565b8114613efe57600080fd5b50565b600081359050613f1081613eea565b92915050565b600060208284031215613f2c57613f2b61396e565b5b6000613f3a84828501613f01565b91505092915050565b60007fffffffffffffffffffffffffffffffff0000000000000000000000000000000082169050919050565b6000613f7a82613f43565b9050919050565b613f8a81613f6f565b82525050565b6000602082019050613fa56000830184613f81565b92915050565b60008060408385031215613fc257613fc161396e565b5b600083013567ffffffffffffffff811115613fe057613fdf613973565b5b613fec85828601613a90565b9250506020613ffd85828601613adf565b9150509250929050565b61401081613f43565b811461401b57600080fd5b50565b60008135905061402d81614007565b92915050565b6000806040838503121561404a5761404961396e565b5b60006140588582860161401e565b925050602061406985828601613f01565b9150509250929050565b61407c81613ed8565b82525050565b60006020820190506140976000830184614073565b92915050565b600060408201905081810360008301526140b78185613db3565b90506140c66020830184613e8e565b9392505050565b600081905092915050565b7f7b226a736f6e727063223a22322e30222c226d6574686f64223a226574685f7360008201527f656e645261775472616e73616374696f6e222c22706172616d73223a5b220000602082015250565b6000614134603e836140cd565b915061413f826140d8565b603e82019050919050565b600061415582613d97565b61415f81856140cd565b935061416f818560208601613c1f565b80840191505092915050565b7f225d2c226964223a317d00000000000000000000000000000000000000000000600082015250565b60006141b1600a836140cd565b91506141bc8261417b565b600a82019050919050565b60006141d282614127565b91506141de828461414a565b91506141e9826141a4565b915081905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b7f416c726561647920726567697374657265640000000000000000000000000000600082015250565b6000614259601283613da2565b915061426482614223565b602082019050919050565b600060208201905081810360008301526142888161424c565b9050919050565b60006040820190506142a46000830185613f81565b6142b16020830184614073565b9392505050565b600081905092915050565b50565b60006142d36000836142b8565b91506142de826142c3565b600082019050919050565b60006142f4826142c6565b9150819050919050565b60006040820190506143136000830185614073565b81810360208301526143258184613c52565b90509392505050565b600082825260208201905092915050565b600061434a82613d97565b614354818561432e565b9350614364818560208601613c1f565b61436d81613982565b840191505092915050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b60006143b0838361433f565b905092915050565b6000602082019050919050565b60006143d082614378565b6143da8185614383565b9350836020820285016143ec85614394565b8060005b85811015614428578484038952815161440985826143a4565b9450614414836143b8565b925060208a019950506001810190506143f0565b50829750879550505050505092915050565b600082825260208201905092915050565b600061445682613c03565b614460818561443a565b9350614470818560208601613c1f565b61447981613982565b840191505092915050565b61448d81613b34565b82525050565b600060a08301600083015184820360008601526144b0828261433f565b915050602083015184820360208601526144ca828261433f565b915050604083015184820360408601526144e482826143c5565b915050606083015184820360608601526144fe828261444b565b91505060808301516145136080860182614484565b508091505092915050565b600060208201905081810360008301526145388184614493565b905092915050565b600061454b82613c03565b61455581856142b8565b9350614565818560208601613c1f565b80840191505092915050565b600061457d8284614540565b915081905092915050565b600061459b61459684613cad565b6139f3565b9050828152602081018484840111156145b7576145b661397d565b5b6145c2848285613c1f565b509392505050565b600082601f8301126145df576145de613978565b5b81516145ef848260208601614588565b91505092915050565b60006020828403121561460e5761460d61396e565b5b600082015167ffffffffffffffff81111561462c5761462b613973565b5b614638848285016145ca565b91505092915050565b600061464d828561414a565b9150614659828461414a565b91508190509392505050565b7f496e70757420746f6f2073686f72740000000000000000000000000000000000600082015250565b600061469b600f83613da2565b91506146a682614665565b602082019050919050565b600060208201905081810360008301526146ca8161468e565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600061470b82613abe565b915061471683613abe565b925082821015614729576147286146d1565b5b828203905092915050565b600061473f82613abe565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203614771576147706146d1565b5b600182019050919050565b600061478782613e0e565b915061479283613e0e565b9250828210156147a5576147a46146d1565b5b828203905092915050565b60006147bb82613abe565b91506147c683613abe565b9250817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff04831182151516156147ff576147fe6146d1565b5b828202905092915050565b600061481582613abe565b915061482083613abe565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff03821115614855576148546146d1565b5b828201905092915050565b600061486b82613abe565b91506000820361487e5761487d6146d1565b5b600182039050919050565b60008160011c9050919050565b6000808291508390505b60018511156148e0578086048111156148bc576148bb6146d1565b5b60018516156148cb5780820291505b80810290506148d985614889565b94506148a0565b94509492505050565b6000826148f957600190506149b5565b8161490757600090506149b5565b816001811461491d576002811461492757614956565b60019150506149b5565b60ff841115614939576149386146d1565b5b8360020a9150848211156149505761494f6146d1565b5b506149b5565b5060208310610133831016604e8410600b841016171561498b5782820a905083811115614986576149856146d1565b5b6149b5565b6149988484846001614896565b925090508184048111156149af576149ae6146d1565b5b81810290505b9392505050565b60006149c782613abe565b91506149d283613e0e565b92506149ff7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff84846148e9565b905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b60028110614a4757614a46614a07565b5b50565b6000819050614a5882614a36565b919050565b6000614a6882614a4a565b9050919050565b614a7881614a5d565b82525050565b6000602082019050614a936000830184614a6f565b92915050565b6000614aac614aa784613a0e565b6139f3565b905082815260208101848484011115614ac857614ac761397d565b5b614ad3848285613c1f565b509392505050565b600082601f830112614af057614aef613978565b5b8151614b00848260208601614a99565b91505092915050565b600060208284031215614b1f57614b1e61396e565b5b600082015167ffffffffffffffff811115614b3d57614b3c613973565b5b614b4984828501614adb565b91505092915050565b7f796f000000000000000000000000000000000000000000000000000000000000600082015250565b6000614b88600283613da2565b9150614b9382614b52565b602082019050919050565b60006020820190508181036000830152614bb781614b7b565b9050919050565b6000819050919050565b6000819050919050565b614be3614bde82614bbe565b614bc8565b82525050565b6000614bf58284614bd2565b60208201915081905092915050565b60006060820190508181036000830152614c1e8186613c52565b90508181036020830152614c328185613db3565b90508181036040830152614c468184613db3565b9050949350505050565b60006060820190508181036000830152614c6a8186613c52565b9050614c796020830185614a6f565b8181036040830152614c8b8184613db3565b9050949350505050565b614c9e81614bbe565b82525050565b6000608082019050614cb96000830187614c95565b614cc66020830186613e1b565b614cd36040830185614c95565b614ce06060830184614c95565b95945050505050565b614cf281613af4565b82525050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b614d2d81613ed8565b82525050565b6000614d3f8383614d24565b60208301905092915050565b6000602082019050919050565b6000614d6382614cf8565b614d6d8185614d03565b9350614d7883614d14565b8060005b83811015614da9578151614d908882614d33565b9750614d9b83614d4b565b925050600181019050614d7c565b5085935050505092915050565b6000608082019050614dcb6000830187614ce9565b8181036020830152614ddd8186614d58565b90508181036040830152614df18185614d58565b90508181036060830152614e058184613db3565b905095945050505050565b600080fd5b600080fd5b600081519050614e2981614007565b92915050565b600081519050614e3e81613b08565b92915050565b600067ffffffffffffffff821115614e5f57614e5e613993565b5b602082029050602081019050919050565b600080fd5b600081519050614e8481613eea565b92915050565b6000614e9d614e9884614e44565b6139f3565b90508083825260208201905060208402830185811115614ec057614ebf614e70565b5b835b81811015614ee95780614ed58882614e75565b845260208401935050602081019050614ec2565b5050509392505050565b600082601f830112614f0857614f07613978565b5b8151614f18848260208601614e8a565b91505092915050565b600060c08284031215614f3757614f36614e10565b5b614f4160c06139f3565b90506000614f5184828501614e1a565b6000830152506020614f6584828501614e1a565b6020830152506040614f7984828501614e2f565b604083015250606082015167ffffffffffffffff811115614f9d57614f9c614e15565b5b614fa984828501614ef3565b606083015250608082015167ffffffffffffffff811115614fcd57614fcc614e15565b5b614fd984828501614ef3565b60808301525060a082015167ffffffffffffffff811115614ffd57614ffc614e15565b5b61500984828501614adb565b60a08301525092915050565b60006020828403121561502b5761502a61396e565b5b600082015167ffffffffffffffff81111561504957615048613973565b5b61505584828501614f21565b91505092915050565b60006060820190506150736000830186613f81565b81810360208301526150858185613db3565b905081810360408301526150998184613c52565b9050949350505050565b7f7b22747873223a205b2200000000000000000000000000000000000000000000600082015250565b60006150d9600a836140cd565b91506150e4826150a3565b600a82019050919050565b7f225d7d0000000000000000000000000000000000000000000000000000000000600082015250565b60006151256003836140cd565b9150615130826150ef565b600382019050919050565b6000615146826150cc565b9150615152828461414a565b915061515d82615118565b915081905092915050565b7f42756e646c6553696d756c6174696f6e4661696c65643a200000000000000000600082015250565b600061519e6018836140cd565b91506151a982615168565b601882019050919050565b60006151bf82615191565b91506151cb828461414a565b915081905092915050565b7f6574685f73656e6442756e646c65000000000000000000000000000000000000600082015250565b600061520c600e83613da2565b9150615217826151d6565b602082019050919050565b6000606082019050818103600083015261523c8185613db3565b9050818103602083015261524f816151ff565b905081810360408301526152638184613c52565b90509392505050565b7f42756e646c655375626d697373696f6e4661696c65643a200000000000000000600082015250565b60006152a26018836140cd565b91506152ad8261526c565b601882019050919050565b60006152c382615295565b91506152cf828461414a565b915081905092915050565b60006152e68285614540565b91506152f28284614540565b91508190509392505050565b60008160601b9050919050565b6000615316826152fe565b9050919050565b60006153288261530b565b9050919050565b61534061533b82613ed8565b61531d565b82525050565b6000615352828461532f565b60148201915081905092915050565b60006040820190506153766000830185613f81565b81810360208301526153888184613db3565b90509392505050565b7f696e76616c6964207369676e6174757265206c656e6774680000000000000000600082015250565b60006153c7601883613da2565b91506153d282615391565b602082019050919050565b600060208201905081810360008301526153f6816153ba565b9050919050565b600061540882613e0e565b915061541383613e0e565b92508260ff03821115615429576154286146d1565b5b828201905092915050565b7f7b22626c6f636b4e756d626572223a2022000000000000000000000000000000600082015250565b600061546a6011836140cd565b915061547582615434565b601182019050919050565b7f222c2022747873223a205b000000000000000000000000000000000000000000600082015250565b60006154b6600b836140cd565b91506154c182615480565b600b82019050919050565b60006154d78261545d565b91506154e3828461414a565b91506154ee826154a9565b915081905092915050565b7f2200000000000000000000000000000000000000000000000000000000000000600082015250565b600061552f6001836140cd565b915061553a826154f9565b600182019050919050565b60006155518285614540565b915061555c82615522565b9150615568828461414a565b915061557382615522565b91508190509392505050565b7f2c00000000000000000000000000000000000000000000000000000000000000600082015250565b60006155b56001836140cd565b91506155c08261557f565b600182019050919050565b60006155d78284614540565b91506155e2826155a8565b915081905092915050565b7f5d00000000000000000000000000000000000000000000000000000000000000600082015250565b60006156236001836140cd565b915061562e826155ed565b600182019050919050565b60006156458284614540565b915061565082615616565b915081905092915050565b7f7d00000000000000000000000000000000000000000000000000000000000000600082015250565b60006156916001836140cd565b915061569c8261565b565b600182019050919050565b60006156b38284614540565b91506156be82615684565b915081905092915050565b6000819050919050565b6156e46156df82613abe565b6156c9565b82525050565b60006156f682846156d3565b60208201915081905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b600061573f82613abe565b915061574a83613abe565b92508261575a57615759615705565b5b828204905092915050565b600061577082613abe565b915061577b83613abe565b92506157a87fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff84846148e9565b905092915050565b60006157bb82613abe565b91506157c683613abe565b9250826157d6576157d5615705565b5b82820690509291505056fe68747470733a2f2f646174612d6170692e62696e616e63652e766973696f6e2f6170692f76332f7469636b65722f70726963653f73796d626f6c3d68747470733a2f2f657468657265756d2d686f6c65736b792d7270632e7075626c69636e6f64652e636f6d68747470733a2f2f72656c61792d686f6c65736b792e666c617368626f74732e6e6574a264697066735822122001989053d785728702041973c309603302ba37c34baef4aeac40a77ea3add0bc64736f6c634300080d0033",
  "deployedBytecode": "0x60806040526004361061010d5760003560e01c8063b72a654011610095578063d86cd69a11610064578063d86cd69a14610383578063e0a388fb146103ae578063e2411625146103d9578063ea42418b14610402578063f77c47911461042d5761010e565b8063b72a6540146102db578063cf1b037c14610306578063d3596e7f1461032f578063d40ec0661461035a5761010e565b806350723553116100dc57806350723553146101e057806357e3c1b51461021d5780637e48532c1461025a578063847b8150146102855780639829ba42146102b05761010e565b80630de8cb93146101105780631d148b8d1461014d57806323b17abc1461018a5780632e0f2625146101b55761010e565b5b005b34801561011c57600080fd5b5061013760048036038101906101329190613b6c565b610458565b6040516101449190613c8b565b60405180910390f35b34801561015957600080fd5b50610174600480360381019061016f9190613d4e565b61053f565b6040516101819190613c8b565b60405180910390f35b34801561019657600080fd5b5061019f6106b0565b6040516101ac9190613dec565b60405180910390f35b3480156101c157600080fd5b506101ca6106cc565b6040516101d79190613e2a565b60405180910390f35b3480156101ec57600080fd5b5061020760048036038101906102029190613e45565b6106d1565b6040516102149190613e9d565b60405180910390f35b34801561022957600080fd5b50610244600480360381019061023f9190613f16565b61075d565b6040516102519190613c8b565b60405180910390f35b34801561026657600080fd5b5061026f610923565b60405161027c9190613c8b565b60405180910390f35b34801561029157600080fd5b5061029a610a60565b6040516102a79190613dec565b60405180910390f35b3480156102bc57600080fd5b506102c5610a7c565b6040516102d29190613dec565b60405180910390f35b3480156102e757600080fd5b506102f0610ab5565b6040516102fd9190613dec565b60405180910390f35b34801561031257600080fd5b5061032d60048036038101906103289190613f16565b610ad1565b005b34801561033b57600080fd5b50610344610ba6565b6040516103519190613f90565b60405180910390f35b34801561036657600080fd5b50610381600480360381019061037c9190613fab565b610bb9565b005b34801561038f57600080fd5b50610398610bf6565b6040516103a59190613dec565b60405180910390f35b3480156103ba57600080fd5b506103c3610c2f565b6040516103d09190613e9d565b60405180910390f35b3480156103e557600080fd5b5061040060048036038101906103fb9190614033565b610c35565b005b34801561040e57600080fd5b50610417610d0b565b6040516104249190614082565b60405180910390f35b34801561043957600080fd5b50610442610d31565b60405161044f9190614082565b60405180910390f35b60606104a0610465610d57565b6040518060400160405280601081526020017f4e6f7420636f6e666964656e7469616c00000000000000000000000000000000815250610e1f565b60006104ab876106d1565b90506104bb878288888888610e65565b63d40ec06660e01b87826040516024016104d692919061409d565b604051602081830303815290604052907bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff838183161783525050505091505095945050505050565b6060600061054c83610e9e565b60405160200161055c91906141c7565b60405160208183030381529060405290506105756138ba565b6040518060400160405280600481526020017f504f5354000000000000000000000000000000000000000000000000000000008152508160200181905250818160600181905250600167ffffffffffffffff8111156105d7576105d6613993565b5b60405190808252806020026020018201604052801561060a57816020015b60608152602001906001900390816105f55790505b5081604001819052506040518060400160405280601e81526020017f436f6e74656e742d547970653a206170706c69636174696f6e2f6a736f6e00008152508160400151600081518110610661576106606141f4565b5b602002602001018190525060008160800190151590811515815250506040518060600160405280602b815260200161581d602b913981600001819052506106a781610ec4565b92505050919050565b6040518060600160405280602381526020016158486023913981565b600481565b6000806106dd83610f7d565b905060006106ea82611122565b9050600061073e6107396040518060400160405280600781526020017f22707269636522000000000000000000000000000000000000000000000000008152508461114e90919063ffffffff16565b6111d1565b905061075361074c826111f3565b60046112c0565b9350505050919050565b60606107a561076a610d57565b6040518060400160405280601081526020017f4e6f7420636f6e666964656e7469616c00000000000000000000000000000000815250610e1f565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16148061084f5750600073ffffffffffffffffffffffffffffffffffffffff16600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16145b61088e576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016108859061426f565b60405180910390fd5b600061089983611487565b90506108a48161053f565b5063cf1b037c60e01b836040516024016108be9190614082565b604051602081830303815290604052907bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff8381831617835250505050915050919050565b606061096b610930610d57565b6040518060400160405280601081526020017f4e6f7420636f6e666964656e7469616c00000000000000000000000000000000815250610e1f565b6109b860008054906101000a900460ff16156040518060400160405280601381526020017f416c726561647920696e697469616c697a656400000000000000000000000000815250610e1f565b60006109c46000611625565b905060006109d18261171c565b905060006109de83611788565b905063e241162560e01b81836040516024016109fb92919061428f565b604051602081830303815290604052907bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff8381831617835250505050935050505090565b6040518060600160405280602b815260200161581d602b913981565b6040518060400160405280601281526020017f6f7261636c653a76303a706b736563726574000000000000000000000000000081525081565b6040518060600160405280603b81526020016157e2603b913981565b600073ffffffffffffffffffffffffffffffffffffffff16600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1614610b62576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610b599061426f565b60405180910390fd5b80600260006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050565b600060019054906101000a900460801b81565b7ff61f2fd6ab65716facd3516c91d806d98dffa9670f127beac522f8cacfd1d8df8282604051610bea92919061409d565b60405180910390a15050565b6040518060400160405280600681526020017f307834323638000000000000000000000000000000000000000000000000000081525081565b61426881565b610c8260008054906101000a900460ff16156040518060400160405280601381526020017f416c726561647920696e697469616c697a656400000000000000000000000000815250610e1f565b81600060016101000a8154816fffffffffffffffffffffffffffffffff021916908360801c021790555080600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060016000806101000a81548160ff0219169083151502179055505050565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6000806000634201000073ffffffffffffffffffffffffffffffffffffffff16604051610d83906142e9565b600060405180830381855afa9150503d8060008114610dbe576040519150601f19603f3d011682016040523d82523d6000602084013e610dc3565b606091505b509150915081610e10576342010000816040517f75fff467000000000000000000000000000000000000000000000000000000008152600401610e079291906142fe565b60405180910390fd5b80516020820151935050505090565b81610e6157806040517f0c25cd98000000000000000000000000000000000000000000000000000000008152600401610e589190613dec565b60405180910390fd5b5050565b6000610e7387878787611964565b90508115610e8a57610e858184611b2e565b610e95565b610e938161053f565b505b50505050505050565b6060610ea982611b45565b90506002815101613078825260028203915080825250919050565b6060600080634320000273ffffffffffffffffffffffffffffffffffffffff1684604051602001610ef5919061451e565b604051602081830303815290604052604051610f119190614571565b600060405180830381855afa9150503d8060008114610f4c576040519150601f19603f3d011682016040523d82523d6000602084013e610f51565b606091505b5091509150610f608282610e1f565b80806020019051810190610f7491906145f8565b92505050919050565b60606000600167ffffffffffffffff811115610f9c57610f9b613993565b5b604051908082528060200260200182016040528015610fcf57816020015b6060815260200190600190039081610fba5790505b5090506040518060400160405280601e81526020017f436f6e74656e742d547970653a206170706c69636174696f6e2f6a736f6e00008152508160008151811061101c5761101b6141f4565b5b602002602001018190525060006040518060a001604052806040518060600160405280603b81526020016157e2603b91398660405160200161105f929190614641565b60405160208183030381529060405281526020016040518060400160405280600381526020017f47455400000000000000000000000000000000000000000000000000000000008152508152602001838152602001600067ffffffffffffffff8111156110cf576110ce613993565b5b6040519080825280601f01601f1916602001820160405280156111015781602001600182028036833780820191505090505b50815260200160001515815250905061111981610ec4565b92505050919050565b61112a6138eb565b80604052600061114361113c84611bb3565b60ff611bbd565b905080915050919050565b6111566138eb565b806040526060905061116783612481565b156111cb57600082805190602001209050600061118385612498565b9050600060058251901b90505b600081146111c757808201519550602081039050826111ae876124ba565b80519060200120036111c2578593506111c7565b611190565b5050505b92915050565b606060006111e86111e1846124ec565b6000611bbd565b905080915050919050565b60606000829050600281511161123e576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611235906146b1565b60405180910390fd5b60006002825161124e9190614700565b905060008167ffffffffffffffff81111561126c5761126b613993565b5b6040519080825280601f01601f19166020018201604052801561129e5781602001600182028036833780820191505090505b5090506021830160208201845182518252848452505050809350505050919050565b600080839050600080600090505b825181101561133c57602e60f81b8382815181106112ef576112ee6141f4565b5b602001015160f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916036113295780915061133c565b808061133490614734565b9150506112ce565b5060008060006001905060008490505b60008111156113cb57816030876001846113669190614700565b81518110611377576113766141f4565b5b602001015160f81c60f81b60f81c61138f919061477c565b60ff1661139c91906147b0565b846113a7919061480a565b9350600a826113b691906147b0565b915080806113c390614860565b91505061134c565b506001905060008760ff16856113e1919061480a565b90505b8481111561145657816030878381518110611402576114016141f4565b5b602001015160f81c60f81b60f81c61141a919061477c565b60ff1661142791906147b0565b83611432919061480a565b9250600a8261144191906147b0565b9150808061144e90614860565b9150506113e4565b508187600a61146591906149bc565b8461147091906147b0565b61147a919061480a565b9550505050505092915050565b606060006040518061014001604052808473ffffffffffffffffffffffffffffffffffffffff168152602001620186a0815260200164174876e800815260200160008152602001600081526020016040516024016040516020818303038152906040527f1aa3a008000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff8381831617835250505050815260200161426881526020017f111111111111111111111111111111111111111111111111111111111111111181526020017f11111111111111111111111111111111111111111111111111111111111111118152602001601b67ffffffffffffffff16815250905060006115cd826124f6565b905060006115d96127a7565b905061161b826040518060400160405280600681526020017f307834323638000000000000000000000000000000000000000000000000000081525083612802565b9350505050919050565b6060600080635320000373ffffffffffffffffffffffffffffffffffffffff16846040516020016116569190614a7e565b6040516020818303038152906040526040516116729190614571565b600060405180830381855afa9150503d80600081146116ad576040519150601f19603f3d011682016040523d82523d6000602084013e6116b2565b606091505b5091509150816116ff576353200003816040517f75fff4670000000000000000000000000000000000000000000000000000000081526004016116f69291906142fe565b60405180910390fd5b808060200190518101906117139190614b09565b92505050919050565b60008060405160200161172e90614b9e565b60405160208183030381529060405280519060200120905060006117738260405160200161175c9190614be9565b6040516020818303038152906040526000866128ff565b905061177f8282612a0d565b92505050919050565b600080600367ffffffffffffffff8111156117a6576117a5613993565b5b6040519080825280602002602001820160405280156117d45781602001602082028036833780820191505090505b50905030816000815181106117ec576117eb6141f4565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff168152505063420300018160018151811061183f5761183e6141f4565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff1681525050634202000181600281518110611892576118916141f4565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250506000611910600083846040518060400160405280601281526020017f6f7261636c653a76303a706b7365637265740000000000000000000000000000815250612a7c565b905061195681600001516040518060400160405280601281526020017f6f7261636c653a76303a706b736563726574000000000000000000000000000081525086612b82565b806000015192505050919050565b60606000604051806101400160405280600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001620186a081526020018481526020016000815260200185815260200187876040516024016119e192919061409d565b6040516020818303038152906040527f4a432a46000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff8381831617835250505050815260200161426881526020017f111111111111111111111111111111111111111111111111111111111111111181526020017f11111111111111111111111111111111111111111111111111111111111111118152602001601b67ffffffffffffffff1681525090506000611ad3826124f6565b90506000611adf6127a7565b9050611b21826040518060400160405280600681526020017f307834323638000000000000000000000000000000000000000000000000000081525083612802565b9350505050949350505050565b611b3782612c65565b611b418282612d50565b5050565b60608151600260405101915080810182526f30313233343536373839616263646566600f52602082018184015b808514611ba057600185019450600f855116516001830153600f855160041c16518253600282019150611b72565b6000825260208201604052505050919050565b6000819050919050565b60006123c9565b63101827966000526004601cfd5b6000815160001a9050919050565b60008190505b600115611c10576001640100002600611bfe83611bd2565b1c1615611c1157600181019050611be6565b5b92915050565b600063ffffffff84113d3d3e83831b8263ffffffff851b19161790509392505050565b600081831c63ffffffff16905092915050565b60006040519050611c728486036078611c6d602086018803605888611c17565b611c17565b925085831781526020810160405295945050505050565b600080611c9a846018600051611c17565b611ca48787611be0565b9150868210611cb35750611e06565b611cbc82611bd2565b600115611df75760228103611cf05782611cd889858589612048565b9350611ce860048583868a611c4d565b945050611df7565b605b8103611d0d57611d0488848488611e0f565b93509350611df7565b607b8103611d2a57611d2188848488611ee7565b93509350611df7565b6001611ff9602d1b821c1615611d4f57611d4688848488612157565b93509350611df7565b876004840111611db25782835160e01c63747275658103611d8757600485019450611d7e60058684878b611c4d565b95505050611df7565b636e756c6c8103611daf57600485019450611da660068684878b611c4d565b95505050611df7565b50505b876005840111611dee5782835160d81c6466616c73658103611deb57600585019450611de260058684878b611c4d565b95505050611df7565b50505b611df6611bc4565b5b50611e028783611be0565b9150505b94509492505050565b60008060006001860191505b600115611eb957868210611e3257611e31611bc4565b5b82611e5557611e418783611be0565b9150605d611e4e83611bd2565b0315611eb9575b611e6187838587611c89565b925092508215611eaa57611e7b8160988551604017611c17565b8352600181019050611e8c82611bd2565b605d8103611e9a5750611eb9565b602c8103611ea85750611eae565b505b8691505b600182019150611e1b565b600182019150611ecb83603887611c17565b9450611edb600183888888611c4d565b92505094509492505050565b6000806001850190505b600115611fda57858110611f0857611f07611bc4565b5b81611f2b57611f178682611be0565b9050607d611f2482611bd2565b0315611fda575b611f358682611be0565b905080611f4487838587612048565b611f4e8882611be0565b9250603a611f5b84611bd2565b03611fc957611f6f88600185018688611c89565b935093508315611fc857611f9b6020860183036098611f9685850360b88951608017611c17565b611c17565b8452611fa683611bd2565b607d8103611fb657505050611fda565b602c8103611fc657505050611fcf565b505b5b87925050505b600181019050611ef1565b600181019050611fec82603886611c17565b9350611ffc600282878787611c4d565b915094509492505050565b6001667e0000007e03ff603061201e858501611bd2565b031c1661202e5761202d611bc4565b5b60058214612044576120436001830182612007565b5b5050565b600084841061205a57612059611bc4565b5b6001840190505b6001156120f35761207181611bd2565b6022810361207f57506120f3565b605c811461209357600182019150506120ee565b61209f60018301611bd2565b905060016a0510110400000000002001602283031c16156120c657600282019150506120ee565b607581036120e5576120d9600283612007565b600682019150506120ee565b859150506120f3565b612061565b84811061210357612102611bc4565b5b600181019050949350505050565b60008190505b60011561213d57600a603061212b83611bd2565b03101561213d57600181019050612117565b8082148416156121505761214f611bc4565b5b9392505050565b600080849050602d61216882611bd2565b03612174576001810190505b600a603061218183611bd2565b03106121905761218f611bc4565b5b61219981611bd2565b600182019150603081146121b6576121b360008884612111565b91505b602e6121c183611bd2565b036121d8576121d560018860018501612111565b91505b815160658160001a60201703612207576122046001896001860162010001600e8660011a031a01612111565b92505b612215600384898989611c4d565b9350505094509492505050565b600060405190508282019150601f1980601f8601165b600115612252578084015181840152818101905080612238575b50848252600085602084010152846040830101604052509392505050565b60006060905081516002816007161161235c57821581151761235c5760208116156122a7576122a0603882611c3a565b915061235c565b6040519150602082016122bb603883611c3a565b5b80156122f05780825280516122d2601882611c3a565b6122de87601884611c17565b835280925060208401935050506122bc565b50601f1983820381018060051c85528260405261230f85603886611c17565b93508360201786526040811061235857602085018186015b60011561235557815181518352808252848201915060208301925081831061234f5750612355565b50612327565b50505b5050505b50919050565b600060609050815180158315171561237a57506123c1565b6123848482611c3a565b91508086166123bf5761239860d882611c3a565b6123ac6123a58784611c3a565b8483612222565b92506123b9838684611c17565b87178452505b505b949350505050565b81600081146124425760018114612458576003811461246e576020840184518101808214612427576123fa81611bd2565b6022825361240e8760d8602260f81b611c17565b60005261241e828460008a611c89565b93509450808253505b8315818310171561243b5761243a611bc4565b5b505061247a565b61245160106078605887612362565b915061247a565b612467600860b8609887612362565b915061247a565b61247784612270565b91505b5092915050565b6000600260ff166007836000015116149050919050565b606060006124af6124a8846124ec565b6003611bbd565b905080915050919050565b606060006080836000015116146124e75760006124e06124d9846124ec565b6001611bbd565b9050809150505b919050565b6000819050919050565b60606000600967ffffffffffffffff81111561251557612514613993565b5b60405190808252806020026020018201604052801561254857816020015b60608152602001906001900390816125335790505b5090506125588360800151612eb6565b8160008151811061256c5761256b6141f4565b5b60200260200101819052506125848360400151612eb6565b81600181518110612598576125976141f4565b5b60200260200101819052506125b08360200151612eb6565b816002815181106125c4576125c36141f4565b5b6020026020010181905250600073ffffffffffffffffffffffffffffffffffffffff16836000015173ffffffffffffffffffffffffffffffffffffffff16036126435761261f60405180602001604052806000815250612ed0565b81600381518110612633576126326141f4565b5b6020026020010181905250612670565b6126508360000151612f4e565b81600381518110612664576126636141f4565b5b60200260200101819052505b61267d8360600151612eb6565b81600481518110612691576126906141f4565b5b60200260200101819052506126a98360a00151612ed0565b816005815181106126bd576126bc6141f4565b5b60200260200101819052506126e083610120015167ffffffffffffffff16612eb6565b816006815181106126f4576126f36141f4565b5b602002602001018190525061272b8360e001516040516020016127179190614be9565b604051602081830303815290604052612ed0565b8160078151811061273f5761273e6141f4565b5b60200260200101819052506127778361010001516040516020016127639190614be9565b604051602081830303815290604052612ed0565b8160088151811061278b5761278a6141f4565b5b602002602001018190525061279f81612f7f565b915050919050565b606060006127f9600060019054906101000a900460801b6040518060400160405280601281526020017f6f7261636c653a76303a706b7365637265740000000000000000000000000000815250612fc3565b90508091505090565b6060600080634010000173ffffffffffffffffffffffffffffffffffffffff1686868660405160200161283793929190614c04565b6040516020818303038152906040526040516128539190614571565b600060405180830381855afa9150503d806000811461288e576040519150601f19603f3d011682016040523d82523d6000602084013e612893565b606091505b5091509150816128e0576340100001816040517f75fff4670000000000000000000000000000000000000000000000000000000081526004016128d79291906142fe565b60405180910390fd5b808060200190518101906128f491906145f8565b925050509392505050565b6060612909610d57565b61291257600080fd5b600080634010000373ffffffffffffffffffffffffffffffffffffffff1686868660405160200161294593929190614c50565b6040516020818303038152906040526040516129619190614571565b600060405180830381855afa9150503d806000811461299c576040519150601f19603f3d011682016040523d82523d6000602084013e6129a1565b606091505b5091509150816129ee576340100003816040517f75fff4670000000000000000000000000000000000000000000000000000000081526004016129e59291906142fe565b60405180910390fd5b80806020019051810190612a0291906145f8565b925050509392505050565b600080600080612a1c856130aa565b92509250925060018682858560405160008152602001604052604051612a459493929190614ca4565b6020604051602081039080840390855afa158015612a67573d6000803e3d6000fd5b50505060206040510351935050505092915050565b612a846138fe565b600080634203000073ffffffffffffffffffffffffffffffffffffffff1687878787604051602001612ab99493929190614db6565b604051602081830303815290604052604051612ad59190614571565b600060405180830381855afa9150503d8060008114612b10576040519150601f19603f3d011682016040523d82523d6000602084013e612b15565b606091505b509150915081612b62576342030000816040517f75fff467000000000000000000000000000000000000000000000000000000008152600401612b599291906142fe565b60405180910390fd5b80806020019051810190612b769190615015565b92505050949350505050565b600080634202000073ffffffffffffffffffffffffffffffffffffffff16858585604051602001612bb59392919061505e565b604051602081830303815290604052604051612bd19190614571565b600060405180830381855afa9150503d8060008114612c0c576040519150601f19603f3d011682016040523d82523d6000602084013e612c11565b606091505b509150915081612c5e576342020000816040517f75fff467000000000000000000000000000000000000000000000000000000008152600401612c559291906142fe565b60405180910390fd5b5050505050565b6000612c7082610e9e565b604051602001612c80919061513b565b6040516020818303038152906040529050600080634210000073ffffffffffffffffffffffffffffffffffffffff1683604051602001612cc09190613c8b565b604051602081830303815290604052604051612cdc9190614571565b600060405180830381855afa9150503d8060008114612d17576040519150601f19603f3d011682016040523d82523d6000602084013e612d1c565b606091505b5091509150612d4a8282604051602001612d3691906151b4565b604051602081830303815290604052610e1f565b50505050565b6000600167ffffffffffffffff811115612d6d57612d6c613993565b5b604051908082528060200260200182016040528015612da057816020015b6060815260200190600190039081612d8b5790505b5090508281600081518110612db857612db76141f4565b5b60200260200101819052506000612dd9828467ffffffffffffffff1661312e565b9050600080634300000173ffffffffffffffffffffffffffffffffffffffff166040518060600160405280602381526020016158486023913984604051602001612e24929190615222565b604051602081830303815290604052604051612e409190614571565b600060405180830381855afa9150503d8060008114612e7b576040519150601f19603f3d011682016040523d82523d6000602084013e612e80565b606091505b5091509150612eae8282604051602001612e9a91906152b8565b604051602081830303815290604052610e1f565b505050505050565b6060612ec9612ec48361324d565b612ed0565b9050919050565b60608060018351148015612f085750608083600081518110612ef557612ef46141f4565b5b602001015160f81c60f81b60f81c60ff16105b15612f1557829050612f45565b612f21835160806133d0565b83604051602001612f339291906152da565b60405160208183030381529060405290505b80915050919050565b6060612f7882604051602001612f649190615346565b604051602081830303815290604052612ed0565b9050919050565b60606000612f8c8361361c565b9050612f9a815160c06133d0565b81604051602001612fac9291906152da565b604051602081830303815290604052915050919050565b6060600080634202000173ffffffffffffffffffffffffffffffffffffffff168585604051602001612ff6929190615361565b6040516020818303038152906040526040516130129190614571565b600060405180830381855afa9150503d806000811461304d576040519150601f19603f3d011682016040523d82523d6000602084013e613052565b606091505b50915091508161309f576342020001816040517f75fff4670000000000000000000000000000000000000000000000000000000081526004016130969291906142fe565b60405180910390fd5b809250505092915050565b600080600060418451146130f3576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016130ea906153dd565b60405180910390fd5b6020840151925060408401519150606084015160001a9050601b8160ff16101561312757601b8161312491906153fd565b90505b9193909250565b6060600061313b836137ae565b60405160200161314b91906154cc565b604051602081830303815290604052905060005b8451811015613220578161318c86838151811061317f5761317e6141f4565b5b6020026020010151610e9e565b60405160200161319d929190615545565b6040516020818303038152906040529150600185516131bc9190614700565b8110156131ea57816040516020016131d491906155cb565b604051602081830303815290604052915061320d565b816040516020016131fb9190615639565b60405160208183030381529060405291505b808061321890614734565b91505061315f565b508060405160200161323291906156a7565b60405160208183030381529060405290508091505092915050565b606060008260405160200161326291906156ea565b604051602081830303815290604052905060005b60208110156132dc57600060f81b828281518110613297576132966141f4565b5b602001015160f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916036132dc5780806132d490614734565b915050613276565b60008160206132eb9190614700565b67ffffffffffffffff81111561330457613303613993565b5b6040519080825280601f01601f1916602001820160405280156133365781602001600182028036833780820191505090505b50905060005b81518110156133c45783838061335190614734565b945081518110613364576133636141f4565b5b602001015160f81c60f81b828281518110613382576133816141f4565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a90535080806133bc90614734565b91505061333c565b50809350505050919050565b606080603884101561348357600167ffffffffffffffff8111156133f7576133f6613993565b5b6040519080825280601f01601f1916602001820160405280156134295781602001600182028036833780820191505090505b509050828461343891906153fd565b60f81b8160008151811061344f5761344e6141f4565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a905350613612565b600080600190505b600081876134999190615734565b146134c15781806134a990614734565b925050610100816134ba91906147b0565b905061348b565b6001826134ce919061480a565b67ffffffffffffffff8111156134e7576134e6613993565b5b6040519080825280601f01601f1916602001820160405280156135195781602001600182028036833780820191505090505b5092506037858361352a91906153fd565b61353491906153fd565b60f81b8360008151811061354b5761354a6141f4565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a905350600190505b81811161360f5761010081836135959190614700565b6101006135a29190615765565b876135ad9190615734565b6135b791906157b0565b60f81b8382815181106135cd576135cc6141f4565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a905350808061360790614734565b91505061357f565b50505b8091505092915050565b6060600082510361367c57600067ffffffffffffffff81111561364257613641613993565b5b6040519080825280601f01601f1916602001820160405280156136745781602001600182028036833780820191505090505b5090506137a9565b600080600090505b83518110156136c9578381815181106136a05761369f6141f4565b5b602002602001015151826136b4919061480a565b915080806136c190614734565b915050613684565b60008267ffffffffffffffff8111156136e5576136e4613993565b5b6040519080825280601f01601f1916602001820160405280156137175781602001600182028036833780820191505090505b5090506000602082019050600092505b85518310156137a1576000868481518110613745576137446141f4565b5b602002602001015190506000602082019050613763838284516137d4565b878581518110613776576137756141f4565b5b6020026020010151518361378a919061480a565b92505050828061379990614734565b935050613727565b819450505050505b919050565b60606137b98261384a565b90506002815101613078825260028203915080825250919050565b6000839050600083905060008390505b6020811061382257815183526020836137fd919061480a565b925060208261380c919061480a565b915060208161381b9190614700565b90506137e4565b60006001826020036101000a0390508019835116818551168181178652505050505050505050565b606060806040510190506020810160405260008152806f30313233343536373839616263646566600f52600119835b6001156138a5578184019350600f8116516001850153600f8160041c165184538060081c905080613879575b50828203602084039350808452505050919050565b6040518060a00160405280606081526020016060815260200160608152602001606081526020016000151581525090565b6040518060200160405280600081525090565b6040518060c0016040528060006fffffffffffffffffffffffffffffffff1916815260200160006fffffffffffffffffffffffffffffffff19168152602001600067ffffffffffffffff1681526020016060815260200160608152602001606081525090565b6000604051905090565b600080fd5b600080fd5b600080fd5b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6139cb82613982565b810181811067ffffffffffffffff821117156139ea576139e9613993565b5b80604052505050565b60006139fd613964565b9050613a0982826139c2565b919050565b600067ffffffffffffffff821115613a2957613a28613993565b5b613a3282613982565b9050602081019050919050565b82818337600083830152505050565b6000613a61613a5c84613a0e565b6139f3565b905082815260208101848484011115613a7d57613a7c61397d565b5b613a88848285613a3f565b509392505050565b600082601f830112613aa557613aa4613978565b5b8135613ab5848260208601613a4e565b91505092915050565b6000819050919050565b613ad181613abe565b8114613adc57600080fd5b50565b600081359050613aee81613ac8565b92915050565b600067ffffffffffffffff82169050919050565b613b1181613af4565b8114613b1c57600080fd5b50565b600081359050613b2e81613b08565b92915050565b60008115159050919050565b613b4981613b34565b8114613b5457600080fd5b50565b600081359050613b6681613b40565b92915050565b600080600080600060a08688031215613b8857613b8761396e565b5b600086013567ffffffffffffffff811115613ba657613ba5613973565b5b613bb288828901613a90565b9550506020613bc388828901613adf565b9450506040613bd488828901613adf565b9350506060613be588828901613b1f565b9250506080613bf688828901613b57565b9150509295509295909350565b600081519050919050565b600082825260208201905092915050565b60005b83811015613c3d578082015181840152602081019050613c22565b83811115613c4c576000848401525b50505050565b6000613c5d82613c03565b613c678185613c0e565b9350613c77818560208601613c1f565b613c8081613982565b840191505092915050565b60006020820190508181036000830152613ca58184613c52565b905092915050565b600067ffffffffffffffff821115613cc857613cc7613993565b5b613cd182613982565b9050602081019050919050565b6000613cf1613cec84613cad565b6139f3565b905082815260208101848484011115613d0d57613d0c61397d565b5b613d18848285613a3f565b509392505050565b600082601f830112613d3557613d34613978565b5b8135613d45848260208601613cde565b91505092915050565b600060208284031215613d6457613d6361396e565b5b600082013567ffffffffffffffff811115613d8257613d81613973565b5b613d8e84828501613d20565b91505092915050565b600081519050919050565b600082825260208201905092915050565b6000613dbe82613d97565b613dc88185613da2565b9350613dd8818560208601613c1f565b613de181613982565b840191505092915050565b60006020820190508181036000830152613e068184613db3565b905092915050565b600060ff82169050919050565b613e2481613e0e565b82525050565b6000602082019050613e3f6000830184613e1b565b92915050565b600060208284031215613e5b57613e5a61396e565b5b600082013567ffffffffffffffff811115613e7957613e78613973565b5b613e8584828501613a90565b91505092915050565b613e9781613abe565b82525050565b6000602082019050613eb26000830184613e8e565b92915050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000613ee382613eb8565b9050919050565b613ef381613ed8565b8114613efe57600080fd5b50565b600081359050613f1081613eea565b92915050565b600060208284031215613f2c57613f2b61396e565b5b6000613f3a84828501613f01565b91505092915050565b60007fffffffffffffffffffffffffffffffff0000000000000000000000000000000082169050919050565b6000613f7a82613f43565b9050919050565b613f8a81613f6f565b82525050565b6000602082019050613fa56000830184613f81565b92915050565b60008060408385031215613fc257613fc161396e565b5b600083013567ffffffffffffffff811115613fe057613fdf613973565b5b613fec85828601613a90565b9250506020613ffd85828601613adf565b9150509250929050565b61401081613f43565b811461401b57600080fd5b50565b60008135905061402d81614007565b92915050565b6000806040838503121561404a5761404961396e565b5b60006140588582860161401e565b925050602061406985828601613f01565b9150509250929050565b61407c81613ed8565b82525050565b60006020820190506140976000830184614073565b92915050565b600060408201905081810360008301526140b78185613db3565b90506140c66020830184613e8e565b9392505050565b600081905092915050565b7f7b226a736f6e727063223a22322e30222c226d6574686f64223a226574685f7360008201527f656e645261775472616e73616374696f6e222c22706172616d73223a5b220000602082015250565b6000614134603e836140cd565b915061413f826140d8565b603e82019050919050565b600061415582613d97565b61415f81856140cd565b935061416f818560208601613c1f565b80840191505092915050565b7f225d2c226964223a317d00000000000000000000000000000000000000000000600082015250565b60006141b1600a836140cd565b91506141bc8261417b565b600a82019050919050565b60006141d282614127565b91506141de828461414a565b91506141e9826141a4565b915081905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b7f416c726561647920726567697374657265640000000000000000000000000000600082015250565b6000614259601283613da2565b915061426482614223565b602082019050919050565b600060208201905081810360008301526142888161424c565b9050919050565b60006040820190506142a46000830185613f81565b6142b16020830184614073565b9392505050565b600081905092915050565b50565b60006142d36000836142b8565b91506142de826142c3565b600082019050919050565b60006142f4826142c6565b9150819050919050565b60006040820190506143136000830185614073565b81810360208301526143258184613c52565b90509392505050565b600082825260208201905092915050565b600061434a82613d97565b614354818561432e565b9350614364818560208601613c1f565b61436d81613982565b840191505092915050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b60006143b0838361433f565b905092915050565b6000602082019050919050565b60006143d082614378565b6143da8185614383565b9350836020820285016143ec85614394565b8060005b85811015614428578484038952815161440985826143a4565b9450614414836143b8565b925060208a019950506001810190506143f0565b50829750879550505050505092915050565b600082825260208201905092915050565b600061445682613c03565b614460818561443a565b9350614470818560208601613c1f565b61447981613982565b840191505092915050565b61448d81613b34565b82525050565b600060a08301600083015184820360008601526144b0828261433f565b915050602083015184820360208601526144ca828261433f565b915050604083015184820360408601526144e482826143c5565b915050606083015184820360608601526144fe828261444b565b91505060808301516145136080860182614484565b508091505092915050565b600060208201905081810360008301526145388184614493565b905092915050565b600061454b82613c03565b61455581856142b8565b9350614565818560208601613c1f565b80840191505092915050565b600061457d8284614540565b915081905092915050565b600061459b61459684613cad565b6139f3565b9050828152602081018484840111156145b7576145b661397d565b5b6145c2848285613c1f565b509392505050565b600082601f8301126145df576145de613978565b5b81516145ef848260208601614588565b91505092915050565b60006020828403121561460e5761460d61396e565b5b600082015167ffffffffffffffff81111561462c5761462b613973565b5b614638848285016145ca565b91505092915050565b600061464d828561414a565b9150614659828461414a565b91508190509392505050565b7f496e70757420746f6f2073686f72740000000000000000000000000000000000600082015250565b600061469b600f83613da2565b91506146a682614665565b602082019050919050565b600060208201905081810360008301526146ca8161468e565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600061470b82613abe565b915061471683613abe565b925082821015614729576147286146d1565b5b828203905092915050565b600061473f82613abe565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203614771576147706146d1565b5b600182019050919050565b600061478782613e0e565b915061479283613e0e565b9250828210156147a5576147a46146d1565b5b828203905092915050565b60006147bb82613abe565b91506147c683613abe565b9250817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff04831182151516156147ff576147fe6146d1565b5b828202905092915050565b600061481582613abe565b915061482083613abe565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff03821115614855576148546146d1565b5b828201905092915050565b600061486b82613abe565b91506000820361487e5761487d6146d1565b5b600182039050919050565b60008160011c9050919050565b6000808291508390505b60018511156148e0578086048111156148bc576148bb6146d1565b5b60018516156148cb5780820291505b80810290506148d985614889565b94506148a0565b94509492505050565b6000826148f957600190506149b5565b8161490757600090506149b5565b816001811461491d576002811461492757614956565b60019150506149b5565b60ff841115614939576149386146d1565b5b8360020a9150848211156149505761494f6146d1565b5b506149b5565b5060208310610133831016604e8410600b841016171561498b5782820a905083811115614986576149856146d1565b5b6149b5565b6149988484846001614896565b925090508184048111156149af576149ae6146d1565b5b81810290505b9392505050565b60006149c782613abe565b91506149d283613e0e565b92506149ff7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff84846148e9565b905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b60028110614a4757614a46614a07565b5b50565b6000819050614a5882614a36565b919050565b6000614a6882614a4a565b9050919050565b614a7881614a5d565b82525050565b6000602082019050614a936000830184614a6f565b92915050565b6000614aac614aa784613a0e565b6139f3565b905082815260208101848484011115614ac857614ac761397d565b5b614ad3848285613c1f565b509392505050565b600082601f830112614af057614aef613978565b5b8151614b00848260208601614a99565b91505092915050565b600060208284031215614b1f57614b1e61396e565b5b600082015167ffffffffffffffff811115614b3d57614b3c613973565b5b614b4984828501614adb565b91505092915050565b7f796f000000000000000000000000000000000000000000000000000000000000600082015250565b6000614b88600283613da2565b9150614b9382614b52565b602082019050919050565b60006020820190508181036000830152614bb781614b7b565b9050919050565b6000819050919050565b6000819050919050565b614be3614bde82614bbe565b614bc8565b82525050565b6000614bf58284614bd2565b60208201915081905092915050565b60006060820190508181036000830152614c1e8186613c52565b90508181036020830152614c328185613db3565b90508181036040830152614c468184613db3565b9050949350505050565b60006060820190508181036000830152614c6a8186613c52565b9050614c796020830185614a6f565b8181036040830152614c8b8184613db3565b9050949350505050565b614c9e81614bbe565b82525050565b6000608082019050614cb96000830187614c95565b614cc66020830186613e1b565b614cd36040830185614c95565b614ce06060830184614c95565b95945050505050565b614cf281613af4565b82525050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b614d2d81613ed8565b82525050565b6000614d3f8383614d24565b60208301905092915050565b6000602082019050919050565b6000614d6382614cf8565b614d6d8185614d03565b9350614d7883614d14565b8060005b83811015614da9578151614d908882614d33565b9750614d9b83614d4b565b925050600181019050614d7c565b5085935050505092915050565b6000608082019050614dcb6000830187614ce9565b8181036020830152614ddd8186614d58565b90508181036040830152614df18185614d58565b90508181036060830152614e058184613db3565b905095945050505050565b600080fd5b600080fd5b600081519050614e2981614007565b92915050565b600081519050614e3e81613b08565b92915050565b600067ffffffffffffffff821115614e5f57614e5e613993565b5b602082029050602081019050919050565b600080fd5b600081519050614e8481613eea565b92915050565b6000614e9d614e9884614e44565b6139f3565b90508083825260208201905060208402830185811115614ec057614ebf614e70565b5b835b81811015614ee95780614ed58882614e75565b845260208401935050602081019050614ec2565b5050509392505050565b600082601f830112614f0857614f07613978565b5b8151614f18848260208601614e8a565b91505092915050565b600060c08284031215614f3757614f36614e10565b5b614f4160c06139f3565b90506000614f5184828501614e1a565b6000830152506020614f6584828501614e1a565b6020830152506040614f7984828501614e2f565b604083015250606082015167ffffffffffffffff811115614f9d57614f9c614e15565b5b614fa984828501614ef3565b606083015250608082015167ffffffffffffffff811115614fcd57614fcc614e15565b5b614fd984828501614ef3565b60808301525060a082015167ffffffffffffffff811115614ffd57614ffc614e15565b5b61500984828501614adb565b60a08301525092915050565b60006020828403121561502b5761502a61396e565b5b600082015167ffffffffffffffff81111561504957615048613973565b5b61505584828501614f21565b91505092915050565b60006060820190506150736000830186613f81565b81810360208301526150858185613db3565b905081810360408301526150998184613c52565b9050949350505050565b7f7b22747873223a205b2200000000000000000000000000000000000000000000600082015250565b60006150d9600a836140cd565b91506150e4826150a3565b600a82019050919050565b7f225d7d0000000000000000000000000000000000000000000000000000000000600082015250565b60006151256003836140cd565b9150615130826150ef565b600382019050919050565b6000615146826150cc565b9150615152828461414a565b915061515d82615118565b915081905092915050565b7f42756e646c6553696d756c6174696f6e4661696c65643a200000000000000000600082015250565b600061519e6018836140cd565b91506151a982615168565b601882019050919050565b60006151bf82615191565b91506151cb828461414a565b915081905092915050565b7f6574685f73656e6442756e646c65000000000000000000000000000000000000600082015250565b600061520c600e83613da2565b9150615217826151d6565b602082019050919050565b6000606082019050818103600083015261523c8185613db3565b9050818103602083015261524f816151ff565b905081810360408301526152638184613c52565b90509392505050565b7f42756e646c655375626d697373696f6e4661696c65643a200000000000000000600082015250565b60006152a26018836140cd565b91506152ad8261526c565b601882019050919050565b60006152c382615295565b91506152cf828461414a565b915081905092915050565b60006152e68285614540565b91506152f28284614540565b91508190509392505050565b60008160601b9050919050565b6000615316826152fe565b9050919050565b60006153288261530b565b9050919050565b61534061533b82613ed8565b61531d565b82525050565b6000615352828461532f565b60148201915081905092915050565b60006040820190506153766000830185613f81565b81810360208301526153888184613db3565b90509392505050565b7f696e76616c6964207369676e6174757265206c656e6774680000000000000000600082015250565b60006153c7601883613da2565b91506153d282615391565b602082019050919050565b600060208201905081810360008301526153f6816153ba565b9050919050565b600061540882613e0e565b915061541383613e0e565b92508260ff03821115615429576154286146d1565b5b828201905092915050565b7f7b22626c6f636b4e756d626572223a2022000000000000000000000000000000600082015250565b600061546a6011836140cd565b915061547582615434565b601182019050919050565b7f222c2022747873223a205b000000000000000000000000000000000000000000600082015250565b60006154b6600b836140cd565b91506154c182615480565b600b82019050919050565b60006154d78261545d565b91506154e3828461414a565b91506154ee826154a9565b915081905092915050565b7f2200000000000000000000000000000000000000000000000000000000000000600082015250565b600061552f6001836140cd565b915061553a826154f9565b600182019050919050565b60006155518285614540565b915061555c82615522565b9150615568828461414a565b915061557382615522565b91508190509392505050565b7f2c00000000000000000000000000000000000000000000000000000000000000600082015250565b60006155b56001836140cd565b91506155c08261557f565b600182019050919050565b60006155d78284614540565b91506155e2826155a8565b915081905092915050565b7f5d00000000000000000000000000000000000000000000000000000000000000600082015250565b60006156236001836140cd565b915061562e826155ed565b600182019050919050565b60006156458284614540565b915061565082615616565b915081905092915050565b7f7d00000000000000000000000000000000000000000000000000000000000000600082015250565b60006156916001836140cd565b915061569c8261565b565b600182019050919050565b60006156b38284614540565b91506156be82615684565b915081905092915050565b6000819050919050565b6156e46156df82613abe565b6156c9565b82525050565b60006156f682846156d3565b60208201915081905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b600061573f82613abe565b915061574a83613abe565b92508261575a57615759615705565b5b828204905092915050565b600061577082613abe565b915061577b83613abe565b92506157a87fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff84846148e9565b905092915050565b60006157bb82613abe565b91506157c683613abe565b9250826157d6576157d5615705565b5b82820690509291505056fe68747470733a2f2f646174612d6170692e62696e616e63652e766973696f6e2f6170692f76332f7469636b65722f70726963653f73796d626f6c3d68747470733a2f2f657468657265756d2d686f6c65736b792d7270632e7075626c69636e6f64652e636f6d68747470733a2f2f72656c61792d686f6c65736b792e666c617368626f74732e6e6574a264697066735822122001989053d785728702041973c309603302ba37c34baef4aeac40a77ea3add0bc64736f6c634300080d0033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 3596,
        "contract": "contracts/oracle/BinanceOracle.sol:BinanceOracle",
        "label": "isInitialized",
        "offset": 0,
        "slot": "0",
        "type": "t_bool"
      },
      {
        "astId": 3599,
        "contract": "contracts/oracle/BinanceOracle.sol:BinanceOracle",
        "label": "pkBidId",
        "offset": 1,
        "slot": "0",
        "type": "t_userDefinedValueType(DataId)858"
      },
      {
        "astId": 3601,
        "contract": "contracts/oracle/BinanceOracle.sol:BinanceOracle",
        "label": "controller",
        "offset": 0,
        "slot": "1",
        "type": "t_address"
      },
      {
        "astId": 3603,
        "contract": "contracts/oracle/BinanceOracle.sol:BinanceOracle",
        "label": "settlementContract",
        "offset": 0,
        "slot": "2",
        "type": "t_address"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_userDefinedValueType(DataId)858": {
        "encoding": "inplace",
        "label": "Suave.DataId",
        "numberOfBytes": "16"
      }
    }
  }
}