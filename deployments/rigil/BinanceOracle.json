{
  "address": "0x13Ad2bEF187622839CdB1f86A62226434190DA69",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "name": "PeekerReverted",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "message",
          "type": "string"
        }
      ],
      "name": "SuaveError",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "message",
          "type": "string"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "SuaveErrorWithData",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "string",
          "name": "ticker",
          "type": "string"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "price",
          "type": "uint256"
        }
      ],
      "name": "PriceSubmission",
      "type": "event"
    },
    {
      "stateMutability": "payable",
      "type": "fallback"
    },
    {
      "inputs": [],
      "name": "DECIMALS",
      "outputs": [
        {
          "internalType": "uint8",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "GOERLI_BUNDLE_ENDPOINT",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "GOERLI_CHAINID",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "GOERLI_CHAINID_STR",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "INFURA_GOERLI_RPC",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "S_NAMESPACE",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "URL_PARTIAL",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "confidentialConstructor",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "Suave.DataId",
          "name": "_pkBidId",
          "type": "bytes16"
        },
        {
          "internalType": "address",
          "name": "pkAddress",
          "type": "address"
        }
      ],
      "name": "confidentialConstructorCallback",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "controller",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "pkBidId",
      "outputs": [
        {
          "internalType": "Suave.DataId",
          "name": "",
          "type": "bytes16"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "ticker",
          "type": "string"
        },
        {
          "internalType": "uint256",
          "name": "nonce",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "gasPrice",
          "type": "uint256"
        },
        {
          "internalType": "uint64",
          "name": "settlementBlockNum",
          "type": "uint64"
        }
      ],
      "name": "queryAndSubmit",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "ticker",
          "type": "string"
        },
        {
          "internalType": "uint256",
          "name": "price",
          "type": "uint256"
        }
      ],
      "name": "queryAndSubmitCallback",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "ticker",
          "type": "string"
        }
      ],
      "name": "queryLatestPrice",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "price",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_settlementContract",
          "type": "address"
        }
      ],
      "name": "registerCallback",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_settlementContract",
          "type": "address"
        }
      ],
      "name": "registerSettlementContract",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "txSigned",
          "type": "bytes"
        }
      ],
      "name": "sendRawTx",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "settlementContract",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x31f9179d16b944cb0beb205fa11b67d1f148111ca0141d082c1fa01a0c058466",
  "receipt": {
    "to": null,
    "from": "0x16f2Aa8dF055b6e672b93Ded41FecCCabAB565B0",
    "contractAddress": "0x13Ad2bEF187622839CdB1f86A62226434190DA69",
    "transactionIndex": 0,
    "gasUsed": "4406875",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x4d1f32bb309d1ede045bfdf08564b090867ad1b21bc312b6a0ced54848facb6d",
    "transactionHash": "0x31f9179d16b944cb0beb205fa11b67d1f148111ca0141d082c1fa01a0c058466",
    "logs": [],
    "blockNumber": 2331128,
    "cumulativeGasUsed": "4406875",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "f3002e1c8db8b22e6d171da1d3b2b4ff",
  "metadata": "{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"PeekerReverted\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"SuaveError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SuaveErrorWithData\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"ticker\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"PriceSubmission\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"DECIMALS\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GOERLI_BUNDLE_ENDPOINT\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GOERLI_CHAINID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GOERLI_CHAINID_STR\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INFURA_GOERLI_RPC\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"S_NAMESPACE\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"URL_PARTIAL\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"confidentialConstructor\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"Suave.DataId\",\"name\":\"_pkBidId\",\"type\":\"bytes16\"},{\"internalType\":\"address\",\"name\":\"pkAddress\",\"type\":\"address\"}],\"name\":\"confidentialConstructorCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pkBidId\",\"outputs\":[{\"internalType\":\"Suave.DataId\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"ticker\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"settlementBlockNum\",\"type\":\"uint64\"}],\"name\":\"queryAndSubmit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"ticker\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"queryAndSubmitCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"ticker\",\"type\":\"string\"}],\"name\":\"queryLatestPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_settlementContract\",\"type\":\"address\"}],\"name\":\"registerCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_settlementContract\",\"type\":\"address\"}],\"name\":\"registerSettlementContract\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"txSigned\",\"type\":\"bytes\"}],\"name\":\"sendRawTx\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"settlementContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/oracle/BinanceOracle.sol\":\"BinanceOracle\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/blockad/lib/SuaveContract.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// Author: Miha Lotric (halo3mic)\\n\\npragma solidity ^0.8.8;\\n\\nimport { Suave } from \\\"../../standard_peekers/bids.sol\\\";\\n\\n\\nabstract contract SuaveContract {\\n\\terror SuaveError(string message);\\n\\terror SuaveErrorWithData(string message, bytes data);\\n\\n\\tmodifier onlyConfidential() {\\n\\t\\tcrequire(Suave.isConfidential(), \\\"Not confidential\\\");\\n\\t\\t_;\\n\\t}\\n\\n\\tfunction simulateBundleSafe(bytes memory bundle, bool doRevert) internal view returns (bool valid, uint64 egp) {\\n\\t\\t(bool success, bytes memory d) = Suave.SIMULATE_BUNDLE.staticcall{ gas: 20_000 }(abi.encode(bundle));\\n\\t\\tcrequire(!doRevert || success, string(d));\\n\\t\\tif (success) {\\n\\t\\t\\treturn (true, abi.decode(d, (uint64)));\\n\\t\\t}\\n\\t}\\n\\n\\tfunction crequire(bool condition, string memory message) internal pure {\\n\\t\\tif (!condition) {\\n\\t\\t\\trevert SuaveError(message);\\n\\t\\t}\\n\\t}\\n}\\n\",\"keccak256\":\"0x64eb01469afe18f29050571acd52ee35faca1da2c00a87e01d5ea0fdbcdf4bec\",\"license\":\"MIT\"},\"contracts/libraries/Bundle.sol\":{\"content\":\"// Source: https://github.com/flashbots/suave-std/blob/main/src/protocols/Bundle.sol\\n\\n\\n// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\nimport \\\"./Suave.sol\\\";\\nimport \\\"solady/src/utils/LibString.sol\\\";\\n\\n// https://docs.flashbots.net/flashbots-auction/advanced/rpc-endpoint#eth_sendbundle\\nlibrary Bundle {\\n    struct BundleObj {\\n        uint64 blockNumber;\\n        uint64 minTimestamp;\\n        uint64 maxTimestamp;\\n        bytes[] txns;\\n    }\\n\\n    function sendBundle(string memory url, BundleObj memory bundle) internal view returns (bytes memory) {\\n        Suave.HttpRequest memory request = encodeBundle(bundle);\\n        request.url = url;\\n        return Suave.doHTTPRequest(request);\\n    }\\n\\n    function encodeBundle(BundleObj memory args) internal pure returns (Suave.HttpRequest memory) {\\n        require(args.txns.length > 0, \\\"Bundle: no txns\\\");\\n\\n        bytes memory params =\\n            abi.encodePacked('{\\\"blockNumber\\\": \\\"', LibString.toHexString(args.blockNumber), '\\\", \\\"txs\\\": [');\\n        for (uint256 i = 0; i < args.txns.length; i++) {\\n            params = abi.encodePacked(params, '\\\"', LibString.toHexString(args.txns[i]), '\\\"');\\n            if (i < args.txns.length - 1) {\\n                params = abi.encodePacked(params, \\\",\\\");\\n            } else {\\n                params = abi.encodePacked(params, \\\"]\\\");\\n            }\\n        }\\n        if (args.minTimestamp > 0) {\\n            params = abi.encodePacked(params, ', \\\"minTimestamp\\\": ', LibString.toString(args.minTimestamp));\\n        }\\n        if (args.maxTimestamp > 0) {\\n            params = abi.encodePacked(params, ', \\\"maxTimestamp\\\": ', LibString.toString(args.maxTimestamp));\\n        }\\n        params = abi.encodePacked(params, ', \\\"maxTimestamp\\\": ', LibString.toString(args.maxTimestamp));\\n        params = abi.encodePacked(params, \\\"}\\\");\\n\\n        bytes memory body =\\n            abi.encodePacked('{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"method\\\":\\\"eth_sendBundle\\\",\\\"params\\\":[', params, '],\\\"id\\\":1}');\\n\\n        Suave.HttpRequest memory request;\\n        request.method = \\\"POST\\\";\\n        request.body = body;\\n        request.headers = new string[](1);\\n        request.headers[0] = \\\"Content-Type: application/json\\\";\\n        request.withFlashbotsSignature = true;\\n\\n        return request;\\n    }\\n}\",\"keccak256\":\"0xf5cf91af6fe20a45a901fa5187886f7ebfaf30dc6f7f83471fa697ed93acc684\",\"license\":\"Unlicense\"},\"contracts/libraries/RLPWriter.sol\":{\"content\":\"// Source: https://github.com/flashbots/suave-std/blob/main/src/utils/RLPWriter.sol\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @custom:attribution https://github.com/bakaoh/solidity-rlp-encode\\n * @title RLPWriter\\n * @author RLPWriter is a library for encoding Solidity types to RLP bytes. Adapted from Bakaoh's\\n *         RLPEncode library (https://github.com/bakaoh/solidity-rlp-encode) with minor\\n *         modifications to improve legibility.\\n */\\nlibrary RLPWriter {\\n    /**\\n     * @notice RLP encodes a byte string.\\n     *\\n     * @param _in The byte string to encode.\\n     *\\n     * @return The RLP encoded string in bytes.\\n     */\\n    function writeBytes(bytes memory _in) internal pure returns (bytes memory) {\\n        bytes memory encoded;\\n\\n        if (_in.length == 1 && uint8(_in[0]) < 128) {\\n            encoded = _in;\\n        } else {\\n            encoded = abi.encodePacked(_writeLength(_in.length, 128), _in);\\n        }\\n\\n        return encoded;\\n    }\\n\\n    /**\\n     * @notice RLP encodes a list of RLP encoded byte byte strings.\\n     *\\n     * @param _in The list of RLP encoded byte strings.\\n     *\\n     * @return The RLP encoded list of items in bytes.\\n     */\\n    function writeList(bytes[] memory _in) internal pure returns (bytes memory) {\\n        bytes memory list = _flatten(_in);\\n        return abi.encodePacked(_writeLength(list.length, 192), list);\\n    }\\n\\n    /**\\n     * @notice RLP encodes a string.\\n     *\\n     * @param _in The string to encode.\\n     *\\n     * @return The RLP encoded string in bytes.\\n     */\\n    function writeString(string memory _in) internal pure returns (bytes memory) {\\n        return writeBytes(bytes(_in));\\n    }\\n\\n    /**\\n     * @notice RLP encodes an address.\\n     *\\n     * @param _in The address to encode.\\n     *\\n     * @return The RLP encoded address in bytes.\\n     */\\n    function writeAddress(address _in) internal pure returns (bytes memory) {\\n        return writeBytes(abi.encodePacked(_in));\\n    }\\n\\n    /**\\n     * @notice RLP encodes a uint.\\n     *\\n     * @param _in The uint256 to encode.\\n     *\\n     * @return The RLP encoded uint256 in bytes.\\n     */\\n    function writeUint(uint256 _in) internal pure returns (bytes memory) {\\n        return writeBytes(_toBinary(_in));\\n    }\\n\\n    /**\\n     * @notice RLP encodes a bool.\\n     *\\n     * @param _in The bool to encode.\\n     *\\n     * @return The RLP encoded bool in bytes.\\n     */\\n    function writeBool(bool _in) internal pure returns (bytes memory) {\\n        bytes memory encoded = new bytes(1);\\n        encoded[0] = (_in ? bytes1(0x01) : bytes1(0x80));\\n        return encoded;\\n    }\\n\\n    /**\\n     * @notice Encode the first byte and then the `len` in binary form if `length` is more than 55.\\n     *\\n     * @param _len    The length of the string or the payload.\\n     * @param _offset 128 if item is string, 192 if item is list.\\n     *\\n     * @return RLP encoded bytes.\\n     */\\n    function _writeLength(uint256 _len, uint256 _offset) private pure returns (bytes memory) {\\n        bytes memory encoded;\\n\\n        if (_len < 56) {\\n            encoded = new bytes(1);\\n            encoded[0] = bytes1(uint8(_len) + uint8(_offset));\\n        } else {\\n            uint256 lenLen;\\n            uint256 i = 1;\\n            while (_len / i != 0) {\\n                lenLen++;\\n                i *= 256;\\n            }\\n\\n            encoded = new bytes(lenLen + 1);\\n            encoded[0] = bytes1(uint8(lenLen) + uint8(_offset) + 55);\\n            for (i = 1; i <= lenLen; i++) {\\n                encoded[i] = bytes1(uint8((_len / (256 ** (lenLen - i))) % 256));\\n            }\\n        }\\n\\n        return encoded;\\n    }\\n\\n    /**\\n     * @notice Encode integer in big endian binary form with no leading zeroes.\\n     *\\n     * @param _x The integer to encode.\\n     *\\n     * @return RLP encoded bytes.\\n     */\\n    function _toBinary(uint256 _x) private pure returns (bytes memory) {\\n        bytes memory b = abi.encodePacked(_x);\\n\\n        uint256 i = 0;\\n        for (; i < 32; i++) {\\n            if (b[i] != 0) {\\n                break;\\n            }\\n        }\\n\\n        bytes memory res = new bytes(32 - i);\\n        for (uint256 j = 0; j < res.length; j++) {\\n            res[j] = b[i++];\\n        }\\n\\n        return res;\\n    }\\n\\n    /**\\n     * @custom:attribution https://github.com/Arachnid/solidity-stringutils\\n     * @notice Copies a piece of memory to another location.\\n     *\\n     * @param _dest Destination location.\\n     * @param _src  Source location.\\n     * @param _len  Length of memory to copy.\\n     */\\n    function _memcpy(uint256 _dest, uint256 _src, uint256 _len) private pure {\\n        uint256 dest = _dest;\\n        uint256 src = _src;\\n        uint256 len = _len;\\n\\n        for (; len >= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        uint256 mask;\\n        unchecked {\\n            mask = 256 ** (32 - len) - 1;\\n        }\\n        assembly {\\n            let srcpart := and(mload(src), not(mask))\\n            let destpart := and(mload(dest), mask)\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n    }\\n\\n    /**\\n     * @custom:attribution https://github.com/sammayo/solidity-rlp-encoder\\n     * @notice Flattens a list of byte strings into one byte string.\\n     *\\n     * @param _list List of byte strings to flatten.\\n     *\\n     * @return The flattened byte string.\\n     */\\n    function _flatten(bytes[] memory _list) private pure returns (bytes memory) {\\n        if (_list.length == 0) {\\n            return new bytes(0);\\n        }\\n\\n        uint256 len;\\n        uint256 i = 0;\\n        for (; i < _list.length; i++) {\\n            len += _list[i].length;\\n        }\\n\\n        bytes memory flattened = new bytes(len);\\n        uint256 flattenedPtr;\\n        assembly {\\n            flattenedPtr := add(flattened, 0x20)\\n        }\\n\\n        for (i = 0; i < _list.length; i++) {\\n            bytes memory item = _list[i];\\n\\n            uint256 listPtr;\\n            assembly {\\n                listPtr := add(item, 0x20)\\n            }\\n\\n            _memcpy(flattenedPtr, listPtr, item.length);\\n            flattenedPtr += _list[i].length;\\n        }\\n\\n        return flattened;\\n    }\\n}\",\"keccak256\":\"0x56651ebc297bf3681217d96f035f3f1fdd3027ae64f55087095182c90307f703\",\"license\":\"MIT\"},\"contracts/libraries/Suave.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.8;\\n\\nlibrary Suave {\\n    error PeekerReverted(address, bytes);\\n\\n    enum CryptoSignature {\\n        SECP256,\\n        BLS\\n    }\\n\\n    type DataId is bytes16;\\n\\n    struct BuildBlockArgs {\\n        uint64 slot;\\n        bytes proposerPubkey;\\n        bytes32 parent;\\n        uint64 timestamp;\\n        address feeRecipient;\\n        uint64 gasLimit;\\n        bytes32 random;\\n        Withdrawal[] withdrawals;\\n        bytes extra;\\n        bytes32 beaconRoot;\\n        bool fillPending;\\n    }\\n\\n    struct DataRecord {\\n        DataId id;\\n        DataId salt;\\n        uint64 decryptionCondition;\\n        address[] allowedPeekers;\\n        address[] allowedStores;\\n        string version;\\n    }\\n\\n    struct HttpRequest {\\n        string url;\\n        string method;\\n        string[] headers;\\n        bytes body;\\n        bool withFlashbotsSignature;\\n    }\\n\\n    struct SimulateTransactionResult {\\n        uint64 egp;\\n        SimulatedLog[] logs;\\n        bool success;\\n        string error;\\n    }\\n\\n    struct SimulatedLog {\\n        bytes data;\\n        address addr;\\n        bytes32[] topics;\\n    }\\n\\n    struct Withdrawal {\\n        uint64 index;\\n        uint64 validator;\\n        address Address;\\n        uint64 amount;\\n    }\\n\\n    address public constant ANYALLOWED = 0xC8df3686b4Afb2BB53e60EAe97EF043FE03Fb829;\\n\\n    address public constant IS_CONFIDENTIAL_ADDR = 0x0000000000000000000000000000000042010000;\\n\\n    address public constant BUILD_ETH_BLOCK = 0x0000000000000000000000000000000042100001;\\n\\n    address public constant CONFIDENTIAL_INPUTS = 0x0000000000000000000000000000000042010001;\\n\\n    address public constant CONFIDENTIAL_RETRIEVE = 0x0000000000000000000000000000000042020001;\\n\\n    address public constant CONFIDENTIAL_STORE = 0x0000000000000000000000000000000042020000;\\n\\n    address public constant DO_HTTPREQUEST = 0x0000000000000000000000000000000043200002;\\n\\n    address public constant ETHstaticcall = 0x0000000000000000000000000000000042100003;\\n\\n    address public constant EXTRACT_HINT = 0x0000000000000000000000000000000042100037;\\n\\n    address public constant FETCH_DATA_RECORDS = 0x0000000000000000000000000000000042030001;\\n\\n    address public constant FILL_MEV_SHARE_BUNDLE = 0x0000000000000000000000000000000043200001;\\n\\n    address public constant NEW_BUILDER = 0x0000000000000000000000000000000053200001;\\n\\n    address public constant NEW_DATA_RECORD = 0x0000000000000000000000000000000042030000;\\n\\n    address public constant PRIVATE_KEY_GEN = 0x0000000000000000000000000000000053200003;\\n\\n    address public constant SIGN_ETH_TRANSACTION = 0x0000000000000000000000000000000040100001;\\n\\n    address public constant SIGN_MESSAGE = 0x0000000000000000000000000000000040100003;\\n\\n    address public constant SIMULATE_BUNDLE = 0x0000000000000000000000000000000042100000;\\n\\n    address public constant SIMULATE_TRANSACTION = 0x0000000000000000000000000000000053200002;\\n\\n    address public constant SUBMIT_BUNDLE_JSON_RPC = 0x0000000000000000000000000000000043000001;\\n\\n    address public constant SUBMIT_ETH_BLOCK_TO_RELAY = 0x0000000000000000000000000000000042100002;\\n\\n    // Returns whether execution is off- or on-chain\\n    function isConfidential() internal view returns (bool b) {\\n        (bool success, bytes memory isConfidentialBytes) = IS_CONFIDENTIAL_ADDR.staticcall(\\\"\\\");\\n        if (!success) {\\n            revert PeekerReverted(IS_CONFIDENTIAL_ADDR, isConfidentialBytes);\\n        }\\n        assembly {\\n            // Load the length of data (first 32 bytes)\\n            let len := mload(isConfidentialBytes)\\n            // Load the data after 32 bytes, so add 0x20\\n            b := mload(add(isConfidentialBytes, 0x20))\\n        }\\n    }\\n\\n    function buildEthBlock(BuildBlockArgs memory blockArgs, DataId dataId, string memory namespace)\\n        internal\\n        view\\n        returns (bytes memory, bytes memory)\\n    {\\n        (bool success, bytes memory data) = BUILD_ETH_BLOCK.staticcall(abi.encode(blockArgs, dataId, namespace));\\n        if (!success) {\\n            revert PeekerReverted(BUILD_ETH_BLOCK, data);\\n        }\\n\\n        return abi.decode(data, (bytes, bytes));\\n    }\\n\\n    function confidentialInputs() internal view returns (bytes memory) {\\n        (bool success, bytes memory data) = CONFIDENTIAL_INPUTS.staticcall(abi.encode());\\n        if (!success) {\\n            revert PeekerReverted(CONFIDENTIAL_INPUTS, data);\\n        }\\n\\n        return data;\\n    }\\n\\n    function confidentialRetrieve(DataId dataId, string memory key) internal view returns (bytes memory) {\\n        (bool success, bytes memory data) = CONFIDENTIAL_RETRIEVE.staticcall(abi.encode(dataId, key));\\n        if (!success) {\\n            revert PeekerReverted(CONFIDENTIAL_RETRIEVE, data);\\n        }\\n\\n        return data;\\n    }\\n\\n    function confidentialStore(DataId dataId, string memory key, bytes memory value) internal view {\\n        (bool success, bytes memory data) = CONFIDENTIAL_STORE.staticcall(abi.encode(dataId, key, value));\\n        if (!success) {\\n            revert PeekerReverted(CONFIDENTIAL_STORE, data);\\n        }\\n    }\\n\\n    function doHTTPRequest(HttpRequest memory request) internal view returns (bytes memory) {\\n        (bool success, bytes memory data) = DO_HTTPREQUEST.staticcall(abi.encode(request));\\n        if (!success) {\\n            revert PeekerReverted(DO_HTTPREQUEST, data);\\n        }\\n\\n        return abi.decode(data, (bytes));\\n    }\\n\\n    function ethstaticcall(address contractAddr, bytes memory input1) internal view returns (bytes memory) {\\n        (bool success, bytes memory data) = ETHstaticcall.staticcall(abi.encode(contractAddr, input1));\\n        if (!success) {\\n            revert PeekerReverted(ETHstaticcall, data);\\n        }\\n\\n        return abi.decode(data, (bytes));\\n    }\\n\\n    function extractHint(bytes memory bundleData) internal view returns (bytes memory) {\\n        require(isConfidential());\\n        (bool success, bytes memory data) = EXTRACT_HINT.staticcall(abi.encode(bundleData));\\n        if (!success) {\\n            revert PeekerReverted(EXTRACT_HINT, data);\\n        }\\n\\n        return data;\\n    }\\n\\n    function fetchDataRecords(uint64 cond, string memory namespace) internal view returns (DataRecord[] memory) {\\n        (bool success, bytes memory data) = FETCH_DATA_RECORDS.staticcall(abi.encode(cond, namespace));\\n        if (!success) {\\n            revert PeekerReverted(FETCH_DATA_RECORDS, data);\\n        }\\n\\n        return abi.decode(data, (DataRecord[]));\\n    }\\n\\n    function fillMevShareBundle(DataId dataId) internal view returns (bytes memory) {\\n        require(isConfidential());\\n        (bool success, bytes memory data) = FILL_MEV_SHARE_BUNDLE.staticcall(abi.encode(dataId));\\n        if (!success) {\\n            revert PeekerReverted(FILL_MEV_SHARE_BUNDLE, data);\\n        }\\n\\n        return data;\\n    }\\n\\n    function newBuilder() internal view returns (string memory) {\\n        (bool success, bytes memory data) = NEW_BUILDER.staticcall(abi.encode());\\n        if (!success) {\\n            revert PeekerReverted(NEW_BUILDER, data);\\n        }\\n\\n        return abi.decode(data, (string));\\n    }\\n\\n    function newDataRecord(\\n        uint64 decryptionCondition,\\n        address[] memory allowedPeekers,\\n        address[] memory allowedStores,\\n        string memory dataType\\n    ) internal view returns (DataRecord memory) {\\n        (bool success, bytes memory data) =\\n            NEW_DATA_RECORD.staticcall(abi.encode(decryptionCondition, allowedPeekers, allowedStores, dataType));\\n        if (!success) {\\n            revert PeekerReverted(NEW_DATA_RECORD, data);\\n        }\\n\\n        return abi.decode(data, (DataRecord));\\n    }\\n\\n    function privateKeyGen(CryptoSignature crypto) internal view returns (string memory) {\\n        (bool success, bytes memory data) = PRIVATE_KEY_GEN.staticcall(abi.encode(crypto));\\n        if (!success) {\\n            revert PeekerReverted(PRIVATE_KEY_GEN, data);\\n        }\\n\\n        return abi.decode(data, (string));\\n    }\\n\\n    function signEthTransaction(bytes memory txn, string memory chainId, string memory signingKey)\\n        internal\\n        view\\n        returns (bytes memory)\\n    {\\n        (bool success, bytes memory data) = SIGN_ETH_TRANSACTION.staticcall(abi.encode(txn, chainId, signingKey));\\n        if (!success) {\\n            revert PeekerReverted(SIGN_ETH_TRANSACTION, data);\\n        }\\n\\n        return abi.decode(data, (bytes));\\n    }\\n\\n    function signMessage(bytes memory digest, CryptoSignature crypto, string memory signingKey)\\n        internal\\n        view\\n        returns (bytes memory)\\n    {\\n        require(isConfidential());\\n        (bool success, bytes memory data) = SIGN_MESSAGE.staticcall(abi.encode(digest, crypto, signingKey));\\n        if (!success) {\\n            revert PeekerReverted(SIGN_MESSAGE, data);\\n        }\\n\\n        return abi.decode(data, (bytes));\\n    }\\n\\n    function simulateBundle(bytes memory bundleData) internal view returns (uint64) {\\n        (bool success, bytes memory data) = SIMULATE_BUNDLE.staticcall(abi.encode(bundleData));\\n        if (!success) {\\n            revert PeekerReverted(SIMULATE_BUNDLE, data);\\n        }\\n\\n        return abi.decode(data, (uint64));\\n    }\\n\\n    function simulateTransaction(string memory sessionid, bytes memory txn)\\n        internal\\n        view\\n        returns (SimulateTransactionResult memory)\\n    {\\n        (bool success, bytes memory data) = SIMULATE_TRANSACTION.staticcall(abi.encode(sessionid, txn));\\n        if (!success) {\\n            revert PeekerReverted(SIMULATE_TRANSACTION, data);\\n        }\\n\\n        return abi.decode(data, (SimulateTransactionResult));\\n    }\\n\\n    function submitBundleJsonRPC(string memory url, string memory method, bytes memory params)\\n        internal\\n        view\\n        returns (bytes memory)\\n    {\\n        require(isConfidential());\\n        (bool success, bytes memory data) = SUBMIT_BUNDLE_JSON_RPC.staticcall(abi.encode(url, method, params));\\n        if (!success) {\\n            revert PeekerReverted(SUBMIT_BUNDLE_JSON_RPC, data);\\n        }\\n\\n        return data;\\n    }\\n\\n    function submitEthBlockToRelay(string memory relayUrl, bytes memory builderBid) internal view returns (bytes memory) {\\n        require(isConfidential());\\n        (bool success, bytes memory data) = SUBMIT_ETH_BLOCK_TO_RELAY.staticcall(abi.encode(relayUrl, builderBid));\\n        if (!success) {\\n            revert PeekerReverted(SUBMIT_ETH_BLOCK_TO_RELAY, data);\\n        }\\n\\n        return data;\\n    }\\n}\\n\",\"keccak256\":\"0xba5616842f1a7157233b135a3d1fb50fec7e00bea8e6acbc2e959271bd273fcd\",\"license\":\"UNLICENSED\"},\"contracts/libraries/Transactions.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\nimport \\\"./RLPWriter.sol\\\";\\nimport \\\"./Suave.sol\\\";\\nimport \\\"solidity-rlp/contracts/RLPReader.sol\\\";\\n\\nlibrary Transactions {\\n    using RLPReader for RLPReader.RLPItem;\\n    using RLPReader for RLPReader.Iterator;\\n    using RLPReader for bytes;\\n\\n    struct EIP155 {\\n        address to;\\n        uint256 gas;\\n        uint256 gasPrice;\\n        uint256 value;\\n        uint256 nonce;\\n        bytes data;\\n        uint256 chainId;\\n        bytes32 r;\\n        bytes32 s;\\n        uint64 v;\\n    }\\n\\n    struct EIP155Request {\\n        address to;\\n        uint256 gas;\\n        uint256 gasPrice;\\n        uint256 value;\\n        uint256 nonce;\\n        bytes data;\\n        uint256 chainId;\\n    }\\n\\n    struct EIP1559 {\\n        address to;\\n        uint64 gas;\\n        uint64 maxFeePerGas;\\n        uint64 maxPriorityFeePerGas;\\n        uint64 value;\\n        uint64 nonce;\\n        bytes data;\\n        uint64 chainId;\\n        bytes accessList;\\n        bytes32 r;\\n        bytes32 s;\\n        uint64 v;\\n    }\\n\\n    struct EIP1559Request {\\n        address to;\\n        uint64 gas;\\n        uint64 maxFeePerGas;\\n        uint64 maxPriorityFeePerGas;\\n        uint64 value;\\n        uint64 nonce;\\n        bytes data;\\n        uint64 chainId;\\n        bytes accessList;\\n    }\\n\\n    function encodeRLP(EIP155 memory txStruct) internal pure returns (bytes memory) {\\n        bytes[] memory items = new bytes[](9);\\n\\n        items[0] = RLPWriter.writeUint(txStruct.nonce);\\n        items[1] = RLPWriter.writeUint(txStruct.gasPrice);\\n        items[2] = RLPWriter.writeUint(txStruct.gas);\\n\\n        if (txStruct.to == address(0)) {\\n            items[3] = RLPWriter.writeBytes(bytes(\\\"\\\"));\\n        } else {\\n            items[3] = RLPWriter.writeAddress(txStruct.to);\\n        }\\n        items[4] = RLPWriter.writeUint(txStruct.value);\\n        items[5] = RLPWriter.writeBytes(txStruct.data);\\n        items[6] = RLPWriter.writeUint(uint256(txStruct.v));\\n        items[7] = RLPWriter.writeBytes(abi.encodePacked(txStruct.r));\\n        items[8] = RLPWriter.writeBytes(abi.encodePacked(txStruct.s));\\n\\n        return RLPWriter.writeList(items);\\n    }\\n\\n    function encodeRLP(EIP155Request memory txStruct) internal pure returns (bytes memory) {\\n        bytes[] memory items = new bytes[](9);\\n\\n        items[0] = RLPWriter.writeUint(txStruct.nonce);\\n        items[1] = RLPWriter.writeUint(txStruct.gasPrice);\\n        items[2] = RLPWriter.writeUint(txStruct.gas);\\n\\n        if (txStruct.to == address(0)) {\\n            items[3] = RLPWriter.writeBytes(bytes(\\\"\\\"));\\n        } else {\\n            items[3] = RLPWriter.writeAddress(txStruct.to);\\n        }\\n        items[4] = RLPWriter.writeUint(txStruct.value);\\n        items[5] = RLPWriter.writeBytes(txStruct.data);\\n        items[6] = RLPWriter.writeUint(txStruct.chainId);\\n        items[7] = RLPWriter.writeBytes(\\\"\\\");\\n        items[8] = RLPWriter.writeBytes(\\\"\\\");\\n\\n        return RLPWriter.writeList(items);\\n    }\\n\\n    function encodeRLP(EIP1559 memory txStruct) internal pure returns (bytes memory) {\\n        bytes[] memory items = new bytes[](12);\\n\\n        items[0] = RLPWriter.writeUint(txStruct.chainId);\\n        items[1] = RLPWriter.writeUint(txStruct.nonce);\\n        items[2] = RLPWriter.writeUint(txStruct.maxPriorityFeePerGas);\\n        items[3] = RLPWriter.writeUint(txStruct.maxFeePerGas);\\n        items[4] = RLPWriter.writeUint(txStruct.gas);\\n\\n        if (txStruct.to == address(0)) {\\n            items[5] = RLPWriter.writeBytes(bytes(\\\"\\\"));\\n        } else {\\n            items[5] = RLPWriter.writeAddress(txStruct.to);\\n        }\\n\\n        items[6] = RLPWriter.writeUint(txStruct.value);\\n        items[7] = RLPWriter.writeBytes(txStruct.data);\\n\\n        if (txStruct.accessList.length == 0) {\\n            items[8] = hex\\\"c0\\\"; // Empty list encoding\\n        } else {\\n            items[8] = RLPWriter.writeBytes(txStruct.accessList);\\n        }\\n\\n        items[9] = RLPWriter.writeUint(uint256(txStruct.v));\\n        items[10] = RLPWriter.writeBytes(abi.encodePacked(txStruct.r));\\n        items[11] = RLPWriter.writeBytes(abi.encodePacked(txStruct.s));\\n\\n        bytes memory rlpTxn = RLPWriter.writeList(items);\\n\\n        bytes memory txn = new bytes(1 + rlpTxn.length);\\n        txn[0] = 0x02;\\n\\n        for (uint256 i = 0; i < rlpTxn.length; ++i) {\\n            txn[i + 1] = rlpTxn[i];\\n        }\\n\\n        return txn;\\n    }\\n\\n    function encodeRLP(EIP1559Request memory txStruct) internal pure returns (bytes memory) {\\n        bytes[] memory items = new bytes[](9);\\n\\n        items[0] = RLPWriter.writeUint(txStruct.chainId);\\n        items[1] = RLPWriter.writeUint(txStruct.nonce);\\n        items[2] = RLPWriter.writeUint(txStruct.maxPriorityFeePerGas);\\n        items[3] = RLPWriter.writeUint(txStruct.maxFeePerGas);\\n        items[4] = RLPWriter.writeUint(txStruct.gas);\\n\\n        if (txStruct.to == address(0)) {\\n            items[5] = RLPWriter.writeBytes(bytes(\\\"\\\"));\\n        } else {\\n            items[5] = RLPWriter.writeAddress(txStruct.to);\\n        }\\n\\n        items[6] = RLPWriter.writeUint(txStruct.value);\\n        items[7] = RLPWriter.writeBytes(txStruct.data);\\n\\n        if (txStruct.accessList.length == 0) {\\n            items[8] = hex\\\"c0\\\"; // Empty list encoding\\n        } else {\\n            items[8] = RLPWriter.writeBytes(txStruct.accessList);\\n        }\\n\\n        bytes memory rlpTxn = RLPWriter.writeList(items);\\n\\n        bytes memory txn = new bytes(1 + rlpTxn.length);\\n        txn[0] = 0x02;\\n\\n        for (uint256 i = 0; i < rlpTxn.length; ++i) {\\n            txn[i + 1] = rlpTxn[i];\\n        }\\n\\n        return txn;\\n    }\\n\\n    function decodeRLP_EIP155(bytes memory rlp) internal pure returns (EIP155 memory) {\\n        EIP155 memory txStruct;\\n\\n        RLPReader.RLPItem[] memory ls = rlp.toRlpItem().toList();\\n        require(ls.length == 9, \\\"invalid transaction\\\");\\n\\n        txStruct.nonce = uint64(ls[0].toUint());\\n        txStruct.gasPrice = uint64(ls[1].toUint());\\n        txStruct.gas = uint64(ls[2].toUint());\\n\\n        if (ls[3].toRlpBytes().length == 1) {\\n            txStruct.to = address(0);\\n        } else {\\n            txStruct.to = ls[3].toAddress();\\n        }\\n\\n        txStruct.value = uint64(ls[4].toUint());\\n        txStruct.data = ls[5].toBytes();\\n        txStruct.v = uint64(ls[6].toUint());\\n        txStruct.r = bytesToBytes32(ls[7].toBytes());\\n        txStruct.s = bytesToBytes32(ls[8].toBytes());\\n\\n        return txStruct;\\n    }\\n\\n    function decodeRLP_EIP155Request(bytes memory rlp) internal pure returns (EIP155Request memory) {\\n        EIP155Request memory txStruct;\\n\\n        RLPReader.RLPItem[] memory ls = rlp.toRlpItem().toList();\\n        require(ls.length == 9, \\\"invalid transaction\\\");\\n\\n        txStruct.nonce = ls[0].toUint();\\n        txStruct.gasPrice = ls[1].toUint();\\n        txStruct.gas = ls[2].toUint();\\n\\n        if (ls[3].toRlpBytes().length == 1) {\\n            txStruct.to = address(0);\\n        } else {\\n            txStruct.to = ls[3].toAddress();\\n        }\\n\\n        txStruct.value = ls[4].toUint();\\n        txStruct.data = ls[5].toBytes();\\n        txStruct.chainId = uint64(ls[6].toUint());\\n\\n        return txStruct;\\n    }\\n\\n    function decodeRLP_EIP1559(bytes memory rlp) internal pure returns (EIP1559 memory) {\\n        EIP1559 memory txStruct;\\n\\n        bytes memory rlpWithoutPrefix = new bytes(rlp.length - 1);\\n\\n        for (uint256 i = 0; i < rlp.length - 1; ++i) {\\n            rlpWithoutPrefix[i] = rlp[i + 1];\\n        }\\n\\n        RLPReader.RLPItem[] memory ls = rlpWithoutPrefix.toRlpItem().toList();\\n        require(ls.length == 12, \\\"invalid transaction\\\");\\n\\n        txStruct.chainId = uint64(ls[0].toUint());\\n        txStruct.nonce = uint64(ls[1].toUint());\\n        txStruct.maxPriorityFeePerGas = uint64(ls[2].toUint());\\n        txStruct.maxFeePerGas = uint64(ls[3].toUint());\\n        txStruct.gas = uint64(ls[4].toUint());\\n\\n        if (ls[5].toRlpBytes().length == 1) {\\n            txStruct.to = address(0);\\n        } else {\\n            txStruct.to = ls[5].toAddress();\\n        }\\n\\n        txStruct.value = uint64(ls[6].toUint());\\n        txStruct.data = ls[7].toBytes();\\n        txStruct.accessList = ls[8].toBytes();\\n        txStruct.v = uint64(ls[9].toUint());\\n        txStruct.r = bytesToBytes32(ls[10].toBytes());\\n        txStruct.s = bytesToBytes32(ls[11].toBytes());\\n\\n        return txStruct;\\n    }\\n\\n    function decodeRLP_EIP1559Request(bytes memory rlp) internal pure returns (EIP1559Request memory) {\\n        EIP1559Request memory txStruct;\\n\\n        bytes memory rlpWithoutPrefix = new bytes(rlp.length - 1);\\n\\n        for (uint256 i = 0; i < rlp.length - 1; ++i) {\\n            rlpWithoutPrefix[i] = rlp[i + 1];\\n        }\\n\\n        RLPReader.RLPItem[] memory ls = rlpWithoutPrefix.toRlpItem().toList();\\n        require(ls.length == 8, \\\"invalid transaction\\\");\\n\\n        txStruct.chainId = uint64(ls[0].toUint());\\n        txStruct.nonce = uint64(ls[1].toUint());\\n        txStruct.maxPriorityFeePerGas = uint64(ls[2].toUint());\\n        txStruct.maxFeePerGas = uint64(ls[3].toUint());\\n        txStruct.gas = uint64(ls[4].toUint());\\n\\n        if (ls[5].toRlpBytes().length == 1) {\\n            txStruct.to = address(0);\\n        } else {\\n            txStruct.to = ls[5].toAddress();\\n        }\\n\\n        txStruct.value = uint64(ls[6].toUint());\\n        txStruct.data = ls[7].toBytes();\\n\\n        return txStruct;\\n    }\\n\\n    function bytesToBytes32(bytes memory inBytes) internal pure returns (bytes32 out) {\\n        require(inBytes.length == 32, \\\"bytesToBytes32: invalid input length\\\");\\n        assembly {\\n            out := mload(add(inBytes, 32))\\n        }\\n    }\\n\\n    function signTxn(Transactions.EIP1559Request memory request, string memory signingKey)\\n        internal\\n        view\\n        returns (Transactions.EIP1559 memory response)\\n    {\\n        bytes memory rlp = Transactions.encodeRLP(request);\\n        bytes memory hash = abi.encodePacked(keccak256(rlp));\\n        bytes memory signature = Suave.signMessage(hash, Suave.CryptoSignature.SECP256, signingKey);\\n        (uint8 v, bytes32 r, bytes32 s) = decodeSignature(signature);\\n\\n        response.to = request.to;\\n        response.gas = request.gas;\\n        response.maxFeePerGas = request.maxFeePerGas;\\n        response.maxPriorityFeePerGas = request.maxPriorityFeePerGas;\\n        response.value = request.value;\\n        response.nonce = request.nonce;\\n        response.data = request.data;\\n        response.chainId = request.chainId;\\n        response.accessList = request.accessList;\\n        response.v = v;\\n        response.r = r;\\n        response.s = s;\\n\\n        return response;\\n    }\\n\\n    function signTxn(Transactions.EIP155Request memory request, string memory signingKey)\\n        internal\\n        view\\n        returns (Transactions.EIP155 memory response)\\n    {\\n        bytes memory rlp = Transactions.encodeRLP(request);\\n        bytes memory hash = abi.encodePacked(keccak256(rlp));\\n        bytes memory signature = Suave.signMessage(hash, Suave.CryptoSignature.SECP256, signingKey);\\n\\n        // TODO: check overflow\\n        uint64 chainIdMul = uint64(request.chainId) * 2;\\n        (uint8 v, bytes32 r, bytes32 s) = decodeSignature(signature);\\n\\n        uint64 v64 = uint64(v) + 35;\\n        v64 += chainIdMul;\\n\\n        response.to = request.to;\\n        response.gas = request.gas;\\n        response.gasPrice = request.gasPrice;\\n        response.value = request.value;\\n        response.nonce = request.nonce;\\n        response.data = request.data;\\n        response.chainId = request.chainId;\\n        response.v = v64;\\n        response.r = r;\\n        response.s = s;\\n\\n        return response;\\n    }\\n\\n    function decodeSignature(bytes memory signature) public pure returns (uint8 v, bytes32 r, bytes32 s) {\\n        assembly {\\n            r := mload(add(signature, 0x20))\\n            s := mload(add(signature, 0x40))\\n            v := byte(0, mload(add(signature, 0x60)))\\n        }\\n    }\\n}\",\"keccak256\":\"0xf38128cc64664516ee19211e45c79832aff166734a462670d715a05a41b59148\",\"license\":\"Unlicense\"},\"contracts/oracle/BinanceOracle.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// Author: Miha Lotric (halo3mic)\\n\\npragma solidity ^0.8.13;\\n\\nimport { AnyBundleContract, Suave } from \\\"../standard_peekers/bids.sol\\\";\\nimport { SuaveContract } from \\\"../blockad/lib/SuaveContract.sol\\\";\\nimport { floatToInt, trimStrEdges, getAddressForPk } from  \\\"./lib/Utils.sol\\\";\\nimport \\\"../../node_modules/solady/src/utils/JSONParserLib.sol\\\";\\nimport \\\"../libraries/Transactions.sol\\\";\\nimport \\\"../libraries/Bundle.sol\\\";\\nimport \\\"solady/src/utils/LibString.sol\\\";\\n\\n\\ncontract BinanceOracle is SuaveContract {\\n    using JSONParserLib for *;\\n\\n    uint public constant GOERLI_CHAINID = 5;\\n    string public constant GOERLI_CHAINID_STR = \\\"0x5\\\";\\n    uint8 public constant DECIMALS = 4;\\n    string public constant S_NAMESPACE = \\\"oracle:v0:pksecret\\\";\\n    string public constant INFURA_GOERLI_RPC = \\\"https://goerli.infura.io/v3/9aa3d95b3bc440fa88ea12eaa4456161\\\"; // Change when settlement node API is exposed\\n    string public constant URL_PARTIAL = \\\"https://data-api.binance.vision/api/v3/ticker/price?symbol=\\\";\\n    string public constant GOERLI_BUNDLE_ENDPOINT = \\\"https://relay-goerli.flashbots.net\\\";\\n    \\n    bool isInitialized;\\n    Suave.DataId public pkBidId;\\n    address public controller;\\n    address public settlementContract;\\n\\n    event PriceSubmission(string ticker, uint price);\\n\\n    // \\u26d3\\ufe0f EVM Methods\\n\\n    function confidentialConstructorCallback(\\n        Suave.DataId _pkBidId, \\n        address pkAddress\\n    ) public {\\n        crequire(!isInitialized, \\\"Already initialized\\\");\\n        pkBidId = _pkBidId;\\n        controller = pkAddress;\\n        isInitialized = true;\\n    }\\n\\n    function registerCallback(address _settlementContract) public {\\n        require(_settlementContract == settlementContract || settlementContract == address(0), \\\"Already registered\\\");\\n        settlementContract = _settlementContract;\\n    }\\n\\n    // ! Warning: This method is not restricted and emitted events should not be relied upon\\n    function queryAndSubmitCallback(string memory ticker, uint price) public {\\n        emit PriceSubmission(ticker, price);\\n    }\\n\\n    fallback() external payable {\\n        // Needed to accept MEVM calls with no callbacks\\n    }\\n\\n    // \\ud83e\\udd10 MEVM Methods\\n\\n    function confidentialConstructor() external view onlyConfidential returns (bytes memory) {\\n        crequire(!isInitialized, \\\"Already initialized\\\");\\n\\n        string memory pk = Suave.privateKeyGen(Suave.CryptoSignature.SECP256);\\n        address pkAddress = getAddressForPk(pk);\\n\\t\\tSuave.DataId bidId = storePK(bytes(pk));\\n\\n        return abi.encodeWithSelector(\\n            this.confidentialConstructorCallback.selector, \\n            bidId, \\n            pkAddress\\n        );\\n    }\\n\\n    function registerSettlementContract(address _settlementContract) external view onlyConfidential() returns (bytes memory) {\\n        require(settlementContract == address(0), \\\"Already registered\\\");\\n        bytes memory signedTx = createRegisterTx(_settlementContract);\\n        sendRawTx(signedTx);\\n        return abi.encodeWithSelector(this.registerCallback.selector, _settlementContract);\\n    }\\n\\n    function queryAndSubmit(\\n        string memory ticker, \\n        uint nonce,\\n        uint gasPrice,\\n        uint64 settlementBlockNum\\n    ) external view onlyConfidential returns (uint) {\\n        uint price = queryLatestPrice(ticker);\\n        submitPriceUpdate(ticker, price, nonce, gasPrice, settlementBlockNum);\\n        return price;\\n    }\\n\\n    function queryLatestPrice(string memory ticker) public view returns (uint price) {\\n        bytes memory response = doBinanceQuery(ticker);\\n        JSONParserLib.Item memory parsedRes = string(response).parse();\\n        string memory priceStr = string(parsedRes.at('\\\"price\\\"').value());\\n        price = floatToInt(trimStrEdges(priceStr), DECIMALS);\\n    }\\n\\n    function submitPriceUpdate(\\n        string memory ticker,\\n        uint price, \\n        uint nonce,\\n        uint gasPrice,\\n        uint64 settlementBlockNum\\n    ) internal view {\\n        bytes memory signedTx = createPriceUpdateTx(ticker, price, nonce, gasPrice);\\n        // sendBundle(signedTx, settlementBlockNum);\\n        sendRawTx(signedTx);\\n    }\\n\\n    function createRegisterTx(address _settlementContract) internal view returns (bytes memory txSigned) {\\n        Transactions.EIP155 memory transaction = Transactions.EIP155({\\n            nonce: 0,\\n            gasPrice: 100 gwei,\\n            gas: 100_000,\\n            to: _settlementContract,\\n            value: 0,\\n            data: abi.encodeWithSignature(\\\"register()\\\"),\\n            chainId: GOERLI_CHAINID,\\n            v: 27,\\n            r: hex\\\"1111111111111111111111111111111111111111111111111111111111111111\\\",\\n            s: hex\\\"1111111111111111111111111111111111111111111111111111111111111111\\\"\\n        });\\n        bytes memory txRlp = Transactions.encodeRLP(transaction);\\n        string memory pk = retreivePK();\\n        txSigned = Suave.signEthTransaction(txRlp, GOERLI_CHAINID_STR, pk);\\n    }\\n\\n    function createPriceUpdateTx(string memory ticker, uint price, uint nonce, uint gasPrice) internal view returns (bytes memory txSigned)  {\\n        Transactions.EIP155 memory transaction = Transactions.EIP155({\\n            nonce: nonce,\\n            gasPrice: gasPrice,\\n            gas: 100_000,\\n            to: settlementContract,\\n            value: 0,\\n            data: abi.encodeWithSignature(\\\"updatePrice(string,uint256)\\\", ticker, price),\\n            chainId: GOERLI_CHAINID,\\n            v: 27,\\n            r: hex\\\"1111111111111111111111111111111111111111111111111111111111111111\\\",\\n            s: hex\\\"1111111111111111111111111111111111111111111111111111111111111111\\\"\\n        });\\n        bytes memory txRlp = Transactions.encodeRLP(transaction);\\n        string memory pk = retreivePK();\\n        txSigned = Suave.signEthTransaction(txRlp, GOERLI_CHAINID_STR, pk);\\n    }\\n\\n    function sendRawTx(bytes memory txSigned) public view returns (bytes memory) {\\n        bytes memory body =\\n            abi.encodePacked('{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"method\\\":\\\"eth_sendRawTransaction\\\",\\\"params\\\":[\\\"', LibString.toHexString(txSigned), '\\\"],\\\"id\\\":1}');\\n        Suave.HttpRequest memory request;\\n        request.method = \\\"POST\\\";\\n        request.body = body;\\n        request.headers = new string[](1);\\n        request.headers[0] = \\\"Content-Type: application/json\\\";\\n        request.withFlashbotsSignature = false;\\n        request.url = INFURA_GOERLI_RPC;\\n        return doHttpRequest(request);\\n    }\\n\\n    function sendBundle(bytes memory txSigned, uint64 settlementBlockNum) internal view {\\n        simulateTx(txSigned);\\n        sendTxViaBundle(txSigned, settlementBlockNum);\\n    }\\n\\n    function simulateTx(bytes memory signedTx) internal view {\\n        bytes memory bundle = abi.encodePacked('{\\\"txs\\\": [\\\"', LibString.toHexString(signedTx), '\\\"]}');\\n        (bool successSim, bytes memory data) = Suave.SIMULATE_BUNDLE.staticcall(abi.encode(bundle));\\n        crequire(successSim,  string(abi.encodePacked(\\\"BundleSimulationFailed: \\\", string(data))));\\n    }\\n\\n    function doBinanceQuery(string memory ticker) internal view returns (bytes memory) {\\n        string[] memory headers = new string[](1);\\n        headers[0] = \\\"Content-Type: application/json\\\";\\n        Suave.HttpRequest memory request = Suave.HttpRequest({\\n            url: string(abi.encodePacked(URL_PARTIAL, ticker)),\\n            method: 'GET',\\n            headers: headers,\\n            body: new bytes(0),\\n            withFlashbotsSignature: false\\n        });\\n        return doHttpRequest(request);\\n    }\\n\\n    function doHttpRequest(Suave.HttpRequest memory request) internal view returns (bytes memory) {\\n        (bool success, bytes memory data) = Suave.DO_HTTPREQUEST.staticcall(abi.encode(request));\\n        crequire(success, string(data));\\n        return abi.decode(data, (bytes));\\n    }\\n\\n    function sendTxViaBundle(bytes memory txSigned, uint64 settlementBlockNum) internal view {\\n        bytes[] memory txns = new bytes[](1);\\n        txns[0] = txSigned;\\n        bytes memory bundleReqParams = bundleRequestParams(txns, settlementBlockNum);\\n        (bool successReq, bytes memory dataReq) = Suave.SUBMIT_BUNDLE_JSON_RPC.staticcall(abi.encode(\\n            GOERLI_BUNDLE_ENDPOINT, \\n            \\\"eth_sendBundle\\\", \\n            bundleReqParams\\n        ));\\n        crequire(successReq, string(abi.encodePacked(\\\"BundleSubmissionFailed: \\\", string(dataReq))));\\n    }\\n\\n    function bundleRequestParams(bytes[] memory txns, uint blockNumber) internal pure returns (bytes memory) {\\n        bytes memory params =\\n            abi.encodePacked('{\\\"blockNumber\\\": \\\"', LibString.toHexString(blockNumber), '\\\", \\\"txs\\\": [');\\n        for (uint256 i = 0; i < txns.length; i++) {\\n            params = abi.encodePacked(params, '\\\"', LibString.toHexString(txns[i]), '\\\"');\\n            if (i < txns.length - 1) {\\n                params = abi.encodePacked(params, \\\",\\\");\\n            } else {\\n                params = abi.encodePacked(params, \\\"]\\\");\\n            }\\n        }\\n        params = abi.encodePacked(params, \\\"}\\\");\\n\\n        return params;\\n    }\\n\\n    function storePK(bytes memory pk) internal view returns (Suave.DataId) {\\n\\t\\taddress[] memory peekers = new address[](3);\\n\\t\\tpeekers[0] = address(this);\\n\\t\\tpeekers[1] = Suave.FETCH_DATA_RECORDS;\\n\\t\\tpeekers[2] = Suave.CONFIDENTIAL_RETRIEVE;\\n\\t\\tSuave.DataRecord memory secretBid = Suave.newDataRecord(0, peekers, peekers, S_NAMESPACE);\\n\\t\\tSuave.confidentialStore(secretBid.id, S_NAMESPACE, pk);\\n\\t\\treturn secretBid.id;\\n\\t}\\n\\n    function retreivePK() internal view returns (string memory) {\\n        bytes memory pkBytes =  Suave.confidentialRetrieve(pkBidId, S_NAMESPACE);\\n        return string(pkBytes);\\n    }\\n\\n}\",\"keccak256\":\"0x741c61cf9c61211b079642bd01a817a7def74cb0056469fd48cef2fd77979841\",\"license\":\"MIT\"},\"contracts/oracle/lib/Utils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// Author: Miha Lotric (halo3mic)\\n\\n// \\ud83d\\udea8 THIS IS UNTESTED DEMO CODE - DONT USE IN PRODUCTION \\ud83d\\udea8\\n\\n\\npragma solidity ^0.8.8;\\n\\nimport '../../libraries/Suave.sol';\\n\\n\\nfunction floatToInt(string memory floatString, uint8 decimals) pure returns (uint) {\\n    bytes memory stringBytes = bytes(floatString);\\n    uint dotPosition;\\n    \\n    // Find the position of the dot\\n    for (uint i = 0; i < stringBytes.length; i++) {\\n        if (stringBytes[i] == 0x2E) {\\n            dotPosition = i;\\n            break;\\n        }\\n    }\\n    \\n    uint integerPart = 0;\\n    uint decimalPart = 0;\\n    uint tenPower = 1;\\n    \\n    // Convert integer part\\n    for (uint i = dotPosition; i > 0; i--) {\\n        integerPart += (uint8(stringBytes[i - 1]) - 48) * tenPower;\\n        tenPower *= 10;\\n    }\\n    \\n    // Reset power of ten\\n    tenPower = 1;\\n    \\n    // Convert decimal part\\n    for (uint i = dotPosition+decimals; i > dotPosition; i--) {\\n        decimalPart += (uint8(stringBytes[i]) - 48) * tenPower;\\n        tenPower *= 10;\\n    }\\n    \\n    // Combine integer and decimal parts\\n    return integerPart * (10**decimals) + decimalPart;\\n}\\n\\nfunction trimStrEdges(string memory _input) pure returns (string memory) {\\n    bytes memory input = bytes(_input);\\n    require(input.length > 2, \\\"Input too short\\\");\\n\\n    uint newLength = input.length - 2;\\n    bytes memory result = new bytes(newLength);\\n\\n    assembly {\\n        let inputPtr := add(input, 0x21)\\n        let resultPtr := add(result, 0x20)\\n        let length := mload(input)\\n        mstore(resultPtr, mload(inputPtr))\\n        mstore(result, newLength)\\n    }\\n    return string(result);\\n}\\n\\nfunction getAddressForPk(string memory pk) view returns (address) {\\n    bytes32 digest = keccak256(abi.encode(\\\"yo\\\"));\\n    bytes memory sig = Suave.signMessage(abi.encodePacked(digest), Suave.CryptoSignature.SECP256, pk);\\n    return recoverSigner(digest, sig);\\n}\\n\\nfunction recoverSigner(bytes32 _ethSignedMessageHash, bytes memory _signature) pure returns (address) {\\n    (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);\\n    return ecrecover(_ethSignedMessageHash, v, r, s);\\n}\\n\\nfunction splitSignature(bytes memory sig) pure returns (bytes32 r, bytes32 s, uint8 v) {\\n    require(sig.length == 65, \\\"invalid signature length\\\");\\n    assembly {\\n        r := mload(add(sig, 32))\\n        s := mload(add(sig, 64))\\n        v := byte(0, mload(add(sig, 96)))\\n    }\\n    if (v < 27) {\\n        v += 27;\\n    }\\n}\",\"keccak256\":\"0xf6ac57bef90af530b49a385efdddde2bb2c73bb8728f9b4b66760d4e1934299d\",\"license\":\"MIT\"},\"contracts/standard_peekers/bids.sol\":{\"content\":\"pragma solidity ^0.8.8;\\n\\nimport \\\"../libraries/Suave.sol\\\";\\n\\ncontract AnyBundleContract {\\n    event DataRecordEvent(Suave.DataId dataId, uint64 decryptionCondition, address[] allowedPeekers);\\n\\n    function fetchConfidentialBundleData() public returns (bytes memory) {\\n        require(Suave.isConfidential());\\n\\n        bytes memory confidentialInputs = Suave.confidentialInputs();\\n        return abi.decode(confidentialInputs, (bytes));\\n    }\\n\\n    function emitDataRecord(Suave.DataRecord calldata dataRecord) public {\\n        emit DataRecordEvent(dataRecord.id, dataRecord.decryptionCondition, dataRecord.allowedPeekers);\\n    }\\n}\\n\\ncontract BundleContract is AnyBundleContract {\\n    function newBundle(\\n        uint64 decryptionCondition,\\n        address[] memory dataAllowedPeekers,\\n        address[] memory dataAllowedStores\\n    ) external payable returns (bytes memory) {\\n        require(Suave.isConfidential());\\n\\n        bytes memory bundleData = this.fetchConfidentialBundleData();\\n\\n        uint64 egp = Suave.simulateBundle(bundleData);\\n\\n        Suave.DataRecord memory dataRecord =\\n            Suave.newDataRecord(decryptionCondition, dataAllowedPeekers, dataAllowedStores, \\\"default:v0:ethBundles\\\");\\n\\n        Suave.confidentialStore(dataRecord.id, \\\"default:v0:ethBundles\\\", bundleData);\\n        Suave.confidentialStore(dataRecord.id, \\\"default:v0:ethBundleSimResults\\\", abi.encode(egp));\\n\\n        return emitAndReturn(dataRecord, bundleData);\\n    }\\n\\n    function emitAndReturn(Suave.DataRecord memory dataRecord, bytes memory) internal virtual returns (bytes memory) {\\n        emit DataRecordEvent(dataRecord.id, dataRecord.decryptionCondition, dataRecord.allowedPeekers);\\n        return bytes.concat(this.emitDataRecord.selector, abi.encode(dataRecord));\\n    }\\n}\\n\\ncontract EthBundleSenderContract is BundleContract {\\n    string[] public builderUrls;\\n\\n    constructor(string[] memory builderUrls_) {\\n        builderUrls = builderUrls_;\\n    }\\n\\n    function emitAndReturn(Suave.DataRecord memory dataRecord, bytes memory bundleData)\\n        internal\\n        virtual\\n        override\\n        returns (bytes memory)\\n    {\\n        for (uint256 i = 0; i < builderUrls.length; i++) {\\n            Suave.submitBundleJsonRPC(builderUrls[i], \\\"eth_sendBundle\\\", bundleData);\\n        }\\n\\n        return BundleContract.emitAndReturn(dataRecord, bundleData);\\n    }\\n}\\n\\ncontract MevShareContract is AnyBundleContract {\\n    event HintEvent(Suave.DataId dataId, bytes hint);\\n\\n    event MatchEvent(Suave.DataId matchDataId, bytes matchHint);\\n\\n    function newTransaction(\\n        uint64 decryptionCondition,\\n        address[] memory dataAllowedPeekers,\\n        address[] memory dataAllowedStores\\n    ) external payable returns (bytes memory) {\\n        // 0. check confidential execution\\n        require(Suave.isConfidential());\\n\\n        // 1. fetch bundle data\\n        bytes memory bundleData = this.fetchConfidentialBundleData();\\n\\n        // 2. sim bundle\\n        uint64 egp = Suave.simulateBundle(bundleData);\\n\\n        // 3. extract hint\\n        bytes memory hint = Suave.extractHint(bundleData);\\n\\n        // // 4. store bundle and sim results\\n        Suave.DataRecord memory dataRecord = Suave.newDataRecord(\\n            decryptionCondition, dataAllowedPeekers, dataAllowedStores, \\\"mevshare:v0:unmatchedBundles\\\"\\n        );\\n        Suave.confidentialStore(dataRecord.id, \\\"mevshare:v0:ethBundles\\\", bundleData);\\n        Suave.confidentialStore(dataRecord.id, \\\"mevshare:v0:ethBundleSimResults\\\", abi.encode(egp));\\n        emit DataRecordEvent(dataRecord.id, dataRecord.decryptionCondition, dataRecord.allowedPeekers);\\n        emit HintEvent(dataRecord.id, hint);\\n\\n        // // 5. return \\\"callback\\\" to emit hint onchain\\n        return bytes.concat(this.emitDataRecordAndHint.selector, abi.encode(dataRecord, hint));\\n    }\\n\\n    function emitDataRecordAndHint(Suave.DataRecord calldata dataRecord, bytes memory hint) public {\\n        emit DataRecordEvent(dataRecord.id, dataRecord.decryptionCondition, dataRecord.allowedPeekers);\\n        emit HintEvent(dataRecord.id, hint);\\n    }\\n\\n    function newMatch(\\n        uint64 decryptionCondition,\\n        address[] memory dataAllowedPeekers,\\n        address[] memory dataAllowedStores,\\n        Suave.DataId sharedataId\\n    ) external payable returns (bytes memory) {\\n        // WARNING : this function will copy the original mev share bid\\n        // into a new key with potentially different permsissions\\n\\n        require(Suave.isConfidential());\\n        // 1. fetch confidential data\\n        bytes memory matchBundleData = this.fetchConfidentialBundleData();\\n\\n        // 2. sim match alone for validity\\n        uint64 egp = Suave.simulateBundle(matchBundleData);\\n\\n        // 3. extract hint\\n        bytes memory matchHint = Suave.extractHint(matchBundleData);\\n\\n        Suave.DataRecord memory dataRecord = Suave.newDataRecord(\\n            decryptionCondition, dataAllowedPeekers, dataAllowedStores, \\\"mevshare:v0:matchDataRecords\\\"\\n        );\\n        Suave.confidentialStore(dataRecord.id, \\\"mevshare:v0:ethBundles\\\", matchBundleData);\\n        Suave.confidentialStore(dataRecord.id, \\\"mevshare:v0:ethBundleSimResults\\\", abi.encode(0));\\n\\n        //4. merge data records\\n        Suave.DataId[] memory dataRecords = new Suave.DataId[](2);\\n        dataRecords[0] = sharedataId;\\n        dataRecords[1] = dataRecord.id;\\n        Suave.confidentialStore(dataRecord.id, \\\"mevshare:v0:mergedDataRecords\\\", abi.encode(dataRecords));\\n\\n        return emitMatchDataRecordAndHint(dataRecord, matchHint);\\n    }\\n\\n    function emitMatchDataRecordAndHint(Suave.DataRecord memory dataRecord, bytes memory matchHint)\\n        internal\\n        virtual\\n        returns (bytes memory)\\n    {\\n        emit DataRecordEvent(dataRecord.id, dataRecord.decryptionCondition, dataRecord.allowedPeekers);\\n        emit MatchEvent(dataRecord.id, matchHint);\\n\\n        return bytes.concat(this.emitDataRecord.selector, abi.encode(dataRecord));\\n    }\\n}\\n\\ncontract MevShareBundleSenderContract is MevShareContract {\\n    string[] public builderUrls;\\n\\n    constructor(string[] memory builderUrls_) {\\n        builderUrls = builderUrls_;\\n    }\\n\\n    function emitMatchDataRecordAndHint(Suave.DataRecord memory dataRecord, bytes memory matchHint)\\n        internal\\n        virtual\\n        override\\n        returns (bytes memory)\\n    {\\n        bytes memory bundleData = Suave.fillMevShareBundle(dataRecord.id);\\n        for (uint256 i = 0; i < builderUrls.length; i++) {\\n            Suave.submitBundleJsonRPC(builderUrls[i], \\\"mev_sendBundle\\\", bundleData);\\n        }\\n\\n        return MevShareContract.emitMatchDataRecordAndHint(dataRecord, matchHint);\\n    }\\n}\\n\\n/* Not tested or implemented on the precompile side */\\nstruct EgpRecordPair {\\n    uint64 egp; // in wei, beware overflow\\n    Suave.DataId dataId;\\n}\\n\\ncontract EthBlockContract is AnyBundleContract {\\n    event BuilderBoostBidEvent(Suave.DataId dataId, bytes builderBid);\\n\\n    function idsEqual(Suave.DataId _l, Suave.DataId _r) public pure returns (bool) {\\n        bytes memory l = abi.encodePacked(_l);\\n        bytes memory r = abi.encodePacked(_r);\\n        for (uint256 i = 0; i < l.length; i++) {\\n            if (bytes(l)[i] != r[i]) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    function buildMevShare(Suave.BuildBlockArgs memory blockArgs, uint64 blockHeight) public returns (bytes memory) {\\n        require(Suave.isConfidential());\\n\\n        Suave.DataRecord[] memory allShareMatchDataRecords =\\n            Suave.fetchDataRecords(blockHeight, \\\"mevshare:v0:matchDataRecords\\\");\\n        Suave.DataRecord[] memory allShareUserDataRecords =\\n            Suave.fetchDataRecords(blockHeight, \\\"mevshare:v0:unmatchedBundles\\\");\\n\\n        if (allShareUserDataRecords.length == 0) {\\n            revert Suave.PeekerReverted(address(this), \\\"no data records\\\");\\n        }\\n\\n        Suave.DataRecord[] memory allRecords = new Suave.DataRecord[](allShareUserDataRecords.length);\\n        for (uint256 i = 0; i < allShareUserDataRecords.length; i++) {\\n            // TODO: sort matches by egp first!\\n            Suave.DataRecord memory dataRecordToInsert = allShareUserDataRecords[i]; // will be updated with the best match if any\\n            for (uint256 j = 0; j < allShareMatchDataRecords.length; j++) {\\n                // TODO: should be done once at the start and sorted\\n                Suave.DataId[] memory mergeddataIds = abi.decode(\\n                    Suave.confidentialRetrieve(allShareMatchDataRecords[j].id, \\\"mevshare:v0:mergedDataRecords\\\"),\\n                    (Suave.DataId[])\\n                );\\n                if (idsEqual(mergeddataIds[0], allShareUserDataRecords[i].id)) {\\n                    dataRecordToInsert = allShareMatchDataRecords[j];\\n                    break;\\n                }\\n            }\\n            allRecords[i] = dataRecordToInsert;\\n        }\\n\\n        EgpRecordPair[] memory bidsByEGP = new EgpRecordPair[](allRecords.length);\\n        for (uint256 i = 0; i < allRecords.length; i++) {\\n            bytes memory simResults = Suave.confidentialRetrieve(allRecords[i].id, \\\"mevshare:v0:ethBundleSimResults\\\");\\n            uint64 egp = abi.decode(simResults, (uint64));\\n            bidsByEGP[i] = EgpRecordPair(egp, allRecords[i].id);\\n        }\\n\\n        // Bubble sort, cause why not\\n        uint256 n = bidsByEGP.length;\\n        for (uint256 i = 0; i < n - 1; i++) {\\n            for (uint256 j = i + 1; j < n; j++) {\\n                if (bidsByEGP[i].egp < bidsByEGP[j].egp) {\\n                    EgpRecordPair memory temp = bidsByEGP[i];\\n                    bidsByEGP[i] = bidsByEGP[j];\\n                    bidsByEGP[j] = temp;\\n                }\\n            }\\n        }\\n\\n        Suave.DataId[] memory alldataIds = new Suave.DataId[](allRecords.length);\\n        for (uint256 i = 0; i < bidsByEGP.length; i++) {\\n            alldataIds[i] = bidsByEGP[i].dataId;\\n        }\\n\\n        return buildAndEmit(blockArgs, blockHeight, alldataIds, \\\"mevshare:v0\\\");\\n    }\\n\\n    function buildFromPool(Suave.BuildBlockArgs memory blockArgs, uint64 blockHeight) public returns (bytes memory) {\\n        require(Suave.isConfidential());\\n\\n        Suave.DataRecord[] memory allRecords = Suave.fetchDataRecords(blockHeight, \\\"default:v0:ethBundles\\\");\\n        if (allRecords.length == 0) {\\n            revert Suave.PeekerReverted(address(this), \\\"no data records\\\");\\n        }\\n\\n        EgpRecordPair[] memory bidsByEGP = new EgpRecordPair[](allRecords.length);\\n        for (uint256 i = 0; i < allRecords.length; i++) {\\n            bytes memory simResults = Suave.confidentialRetrieve(allRecords[i].id, \\\"default:v0:ethBundleSimResults\\\");\\n            uint64 egp = abi.decode(simResults, (uint64));\\n            bidsByEGP[i] = EgpRecordPair(egp, allRecords[i].id);\\n        }\\n\\n        // Bubble sort, cause why not\\n        uint256 n = bidsByEGP.length;\\n        for (uint256 i = 0; i < n - 1; i++) {\\n            for (uint256 j = i + 1; j < n; j++) {\\n                if (bidsByEGP[i].egp < bidsByEGP[j].egp) {\\n                    EgpRecordPair memory temp = bidsByEGP[i];\\n                    bidsByEGP[i] = bidsByEGP[j];\\n                    bidsByEGP[j] = temp;\\n                }\\n            }\\n        }\\n\\n        Suave.DataId[] memory alldataIds = new Suave.DataId[](allRecords.length);\\n        for (uint256 i = 0; i < bidsByEGP.length; i++) {\\n            alldataIds[i] = bidsByEGP[i].dataId;\\n        }\\n\\n        return buildAndEmit(blockArgs, blockHeight, alldataIds, \\\"\\\");\\n    }\\n\\n    function buildAndEmit(\\n        Suave.BuildBlockArgs memory blockArgs,\\n        uint64 blockHeight,\\n        Suave.DataId[] memory records,\\n        string memory namespace\\n    ) public virtual returns (bytes memory) {\\n        require(Suave.isConfidential());\\n\\n        (Suave.DataRecord memory blockBid, bytes memory builderBid) =\\n            this.doBuild(blockArgs, blockHeight, records, namespace);\\n\\n        emit BuilderBoostBidEvent(blockBid.id, builderBid);\\n        emit DataRecordEvent(blockBid.id, blockBid.decryptionCondition, blockBid.allowedPeekers);\\n        return bytes.concat(this.emitBuilderBidAndBid.selector, abi.encode(blockBid, builderBid));\\n    }\\n\\n    function doBuild(\\n        Suave.BuildBlockArgs memory blockArgs,\\n        uint64 blockHeight,\\n        Suave.DataId[] memory records,\\n        string memory namespace\\n    ) public view returns (Suave.DataRecord memory, bytes memory) {\\n        address[] memory allowedPeekers = new address[](2);\\n        allowedPeekers[0] = address(this);\\n        allowedPeekers[1] = Suave.BUILD_ETH_BLOCK;\\n\\n        Suave.DataRecord memory blockBid =\\n            Suave.newDataRecord(blockHeight, allowedPeekers, allowedPeekers, \\\"default:v0:mergedDataRecords\\\");\\n        Suave.confidentialStore(blockBid.id, \\\"default:v0:mergedDataRecords\\\", abi.encode(records));\\n\\n        (bytes memory builderBid, bytes memory payload) = Suave.buildEthBlock(blockArgs, blockBid.id, namespace);\\n        Suave.confidentialStore(blockBid.id, \\\"default:v0:builderPayload\\\", payload); // only through this.unlock\\n\\n        return (blockBid, builderBid);\\n    }\\n\\n    function emitBuilderBidAndBid(Suave.DataRecord memory dataRecord, bytes memory builderBid)\\n        public\\n        returns (Suave.DataRecord memory, bytes memory)\\n    {\\n        emit BuilderBoostBidEvent(dataRecord.id, builderBid);\\n        emit DataRecordEvent(dataRecord.id, dataRecord.decryptionCondition, dataRecord.allowedPeekers);\\n        return (dataRecord, builderBid);\\n    }\\n\\n    function unlock(Suave.DataId dataId, bytes memory signedBlindedHeader) public view returns (bytes memory) {\\n        require(Suave.isConfidential());\\n\\n        // TODO: verify the header is correct\\n        // TODO: incorporate protocol name\\n        bytes memory payload = Suave.confidentialRetrieve(dataId, \\\"default:v0:builderPayload\\\");\\n        return payload;\\n    }\\n}\\n\\ncontract EthBlockBidSenderContract is EthBlockContract {\\n    string boostRelayUrl;\\n\\n    constructor(string memory boostRelayUrl_) {\\n        boostRelayUrl = boostRelayUrl_;\\n    }\\n\\n    function buildAndEmit(\\n        Suave.BuildBlockArgs memory blockArgs,\\n        uint64 blockHeight,\\n        Suave.DataId[] memory dataRecords,\\n        string memory namespace\\n    ) public virtual override returns (bytes memory) {\\n        require(Suave.isConfidential());\\n\\n        (Suave.DataRecord memory blockDataRecord, bytes memory builderBid) =\\n            this.doBuild(blockArgs, blockHeight, dataRecords, namespace);\\n        Suave.submitEthBlockToRelay(boostRelayUrl, builderBid);\\n\\n        emit DataRecordEvent(blockDataRecord.id, blockDataRecord.decryptionCondition, blockDataRecord.allowedPeekers);\\n        return bytes.concat(this.emitDataRecord.selector, abi.encode(blockDataRecord));\\n    }\\n}\\n\",\"keccak256\":\"0x69d1971b3f0841d3cc7c28122a240b06f1d28d71510bce6a7f915ee392f47918\"},\"node_modules/solady/src/utils/JSONParserLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library for parsing JSONs.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/JSONParserLib.sol)\\nlibrary JSONParserLib {\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The input is invalid.\\n    error ParsingFailed();\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    // There are 6 types of variables in JSON (excluding undefined).\\n\\n    /// @dev For denoting that an item has not been initialized.\\n    /// A item returned from `parse` will never be of an undefined type.\\n    /// Parsing a invalid JSON string will simply revert.\\n    uint8 internal constant TYPE_UNDEFINED = 0;\\n\\n    /// @dev Type representing an array (e.g. `[1,2,3]`).\\n    uint8 internal constant TYPE_ARRAY = 1;\\n\\n    /// @dev Type representing an object (e.g. `{\\\"a\\\":\\\"A\\\",\\\"b\\\":\\\"B\\\"}`).\\n    uint8 internal constant TYPE_OBJECT = 2;\\n\\n    /// @dev Type representing a number (e.g. `-1.23e+21`).\\n    uint8 internal constant TYPE_NUMBER = 3;\\n\\n    /// @dev Type representing a string (e.g. `\\\"hello\\\"`).\\n    uint8 internal constant TYPE_STRING = 4;\\n\\n    /// @dev Type representing a boolean (i.e. `true` or `false`).\\n    uint8 internal constant TYPE_BOOLEAN = 5;\\n\\n    /// @dev Type representing null (i.e. `null`).\\n    uint8 internal constant TYPE_NULL = 6;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                          STRUCTS                           */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev A pointer to a parsed JSON node.\\n    struct Item {\\n        // Do NOT modify the `_data` directly.\\n        uint256 _data;\\n    }\\n\\n    // Private constants for packing `_data`.\\n\\n    uint256 private constant _BITPOS_STRING = 32 * 7 - 8;\\n    uint256 private constant _BITPOS_KEY_LENGTH = 32 * 6 - 8;\\n    uint256 private constant _BITPOS_KEY = 32 * 5 - 8;\\n    uint256 private constant _BITPOS_VALUE_LENGTH = 32 * 4 - 8;\\n    uint256 private constant _BITPOS_VALUE = 32 * 3 - 8;\\n    uint256 private constant _BITPOS_CHILD = 32 * 2 - 8;\\n    uint256 private constant _BITPOS_SIBLING_OR_PARENT = 32 * 1 - 8;\\n    uint256 private constant _BITMASK_POINTER = 0xffffffff;\\n    uint256 private constant _BITMASK_TYPE = 7;\\n    uint256 private constant _KEY_INITED = 1 << 3;\\n    uint256 private constant _VALUE_INITED = 1 << 4;\\n    uint256 private constant _CHILDREN_INITED = 1 << 5;\\n    uint256 private constant _PARENT_IS_ARRAY = 1 << 6;\\n    uint256 private constant _PARENT_IS_OBJECT = 1 << 7;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                   JSON PARSING OPERATION                   */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Parses the JSON string `s`, and returns the root.\\n    /// Reverts if `s` is not a valid JSON as specified in RFC 8259.\\n    /// Object items WILL simply contain all their children, inclusive of repeated keys,\\n    /// in the same order which they appear in the JSON string.\\n    ///\\n    /// Note: For efficiency, this function WILL NOT make a copy of `s`.\\n    /// The parsed tree WILL contain offsets to `s`.\\n    /// Do NOT pass in a string that WILL be modified later on.\\n    function parse(string memory s) internal pure returns (Item memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x40, result) // We will use our own allocation instead.\\n        }\\n        bytes32 r = _query(_toInput(s), 255);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := r\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                    JSON ITEM OPERATIONS                    */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    // Note:\\n    // - An item is a node in the JSON tree.\\n    // - The value of a string item WILL be double-quoted, JSON encoded.\\n    // - We make a distinction between `index` and `key`.\\n    //   - Items in arrays are located by `index` (uint256).\\n    //   - Items in objects are located by `key` (string).\\n    // - Keys are always strings, double-quoted, JSON encoded.\\n    //\\n    // These design choices are made to balance between efficiency and ease-of-use.\\n\\n    /// @dev Returns the string value of the item.\\n    /// This is its exact string representation in the original JSON string.\\n    /// The returned string WILL have leading and trailing whitespace trimmed.\\n    /// All inner whitespace WILL be preserved, exactly as it is in the original JSON string.\\n    /// If the item's type is string, the returned string WILL be double-quoted, JSON encoded.\\n    ///\\n    /// Note: This function lazily instantiates and caches the returned string.\\n    /// Do NOT modify the returned string.\\n    function value(Item memory item) internal pure returns (string memory result) {\\n        bytes32 r = _query(_toInput(item), 0);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := r\\n        }\\n    }\\n\\n    /// @dev Returns the index of the item in the array.\\n    /// It the item's parent is not an array, returns 0.\\n    function index(Item memory item) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if and(mload(item), _PARENT_IS_ARRAY) {\\n                result := and(_BITMASK_POINTER, shr(_BITPOS_KEY, mload(item)))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the key of the item in the object.\\n    /// It the item's parent is not an object, returns an empty string.\\n    /// The returned string WILL be double-quoted, JSON encoded.\\n    ///\\n    /// Note: This function lazily instantiates and caches the returned string.\\n    /// Do NOT modify the returned string.\\n    function key(Item memory item) internal pure returns (string memory result) {\\n        if (item._data & _PARENT_IS_OBJECT != 0) {\\n            bytes32 r = _query(_toInput(item), 1);\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                result := r\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the key of the item in the object.\\n    /// It the item is neither an array nor object, returns an empty array.\\n    ///\\n    /// Note: This function lazily instantiates and caches the returned array.\\n    /// Do NOT modify the returned array.\\n    function children(Item memory item) internal pure returns (Item[] memory result) {\\n        bytes32 r = _query(_toInput(item), 3);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := r\\n        }\\n    }\\n\\n    /// @dev Returns the number of children.\\n    /// It the item is neither an array nor object, returns zero.\\n    function size(Item memory item) internal pure returns (uint256 result) {\\n        bytes32 r = _query(_toInput(item), 3);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(r)\\n        }\\n    }\\n\\n    /// @dev Returns the item at index `i` for (array).\\n    /// If `item` is not an array, the result's type WILL be undefined.\\n    /// If there is no item with the index, the result's type WILL be undefined.\\n    function at(Item memory item, uint256 i) internal pure returns (Item memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x40, result) // Free the default allocation. We'll allocate manually.\\n        }\\n        bytes32 r = _query(_toInput(item), 3);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(add(add(r, 0x20), shl(5, i)))\\n            if iszero(and(lt(i, mload(r)), eq(and(mload(item), _BITMASK_TYPE), TYPE_ARRAY))) {\\n                result := 0x60 // Reset to the zero pointer.\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the item at key `k` for (object).\\n    /// If `item` is not an object, the result's type WILL be undefined.\\n    /// The key MUST be double-quoted, JSON encoded. This is for efficiency reasons.\\n    /// - Correct : `item.at('\\\"k\\\"')`.\\n    /// - Wrong   : `item.at(\\\"k\\\")`.\\n    /// For duplicated keys, the last item with the key WILL be returned.\\n    /// If there is no item with the key, the result's type WILL be undefined.\\n    function at(Item memory item, string memory k) internal pure returns (Item memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x40, result) // Free the default allocation. We'll allocate manually.\\n            result := 0x60 // Initialize to the zero pointer.\\n        }\\n        if (isObject(item)) {\\n            bytes32 kHash = keccak256(bytes(k));\\n            Item[] memory r = children(item);\\n            // We'll just do a linear search. The alternatives are very bloated.\\n            for (uint256 i = r.length << 5; i != 0;) {\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    item := mload(add(r, i))\\n                    i := sub(i, 0x20)\\n                }\\n                if (keccak256(bytes(key(item))) != kHash) continue;\\n                result = item;\\n                break;\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the item's type.\\n    function getType(Item memory item) internal pure returns (uint8 result) {\\n        result = uint8(item._data & _BITMASK_TYPE);\\n    }\\n\\n    /// Note: All types are mutually exclusive.\\n\\n    /// @dev Returns whether the item is of type undefined.\\n    function isUndefined(Item memory item) internal pure returns (bool result) {\\n        result = item._data & _BITMASK_TYPE == TYPE_UNDEFINED;\\n    }\\n\\n    /// @dev Returns whether the item is of type array.\\n    function isArray(Item memory item) internal pure returns (bool result) {\\n        result = item._data & _BITMASK_TYPE == TYPE_ARRAY;\\n    }\\n\\n    /// @dev Returns whether the item is of type object.\\n    function isObject(Item memory item) internal pure returns (bool result) {\\n        result = item._data & _BITMASK_TYPE == TYPE_OBJECT;\\n    }\\n\\n    /// @dev Returns whether the item is of type number.\\n    function isNumber(Item memory item) internal pure returns (bool result) {\\n        result = item._data & _BITMASK_TYPE == TYPE_NUMBER;\\n    }\\n\\n    /// @dev Returns whether the item is of type string.\\n    function isString(Item memory item) internal pure returns (bool result) {\\n        result = item._data & _BITMASK_TYPE == TYPE_STRING;\\n    }\\n\\n    /// @dev Returns whether the item is of type boolean.\\n    function isBoolean(Item memory item) internal pure returns (bool result) {\\n        result = item._data & _BITMASK_TYPE == TYPE_BOOLEAN;\\n    }\\n\\n    /// @dev Returns whether the item is of type null.\\n    function isNull(Item memory item) internal pure returns (bool result) {\\n        result = item._data & _BITMASK_TYPE == TYPE_NULL;\\n    }\\n\\n    /// @dev Returns the item's parent.\\n    /// If the item does not have a parent, the result's type will be undefined.\\n    function parent(Item memory item) internal pure returns (Item memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x40, result) // Free the default allocation. We've already allocated.\\n            result := and(shr(_BITPOS_SIBLING_OR_PARENT, mload(item)), _BITMASK_POINTER)\\n            if iszero(result) { result := 0x60 } // Reset to the zero pointer.\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                     UTILITY FUNCTIONS                      */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Parses an unsigned integer from a string (in decimal, i.e. base 10).\\n    /// Reverts if `s` is not a valid uint256 string matching the RegEx `^[0-9]+$`,\\n    /// or if the parsed number is too big for a uint256.\\n    function parseUint(string memory s) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let n := mload(s)\\n            let preMulOverflowThres := div(not(0), 10)\\n            for { let i := 0 } 1 {} {\\n                i := add(i, 1)\\n                let digit := sub(and(mload(add(s, i)), 0xff), 48)\\n                let mulOverflowed := gt(result, preMulOverflowThres)\\n                let product := mul(10, result)\\n                result := add(product, digit)\\n                n := mul(n, iszero(or(or(mulOverflowed, lt(result, product)), gt(digit, 9))))\\n                if iszero(lt(i, n)) { break }\\n            }\\n            if iszero(n) {\\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Parses a signed integer from a string (in decimal, i.e. base 10).\\n    /// Reverts if `s` is not a valid int256 string matching the RegEx `^[+-]?[0-9]+$`,\\n    /// or if the parsed number cannot fit within `[-2**255 .. 2**255 - 1]`.\\n    function parseInt(string memory s) internal pure returns (int256 result) {\\n        uint256 n = bytes(s).length;\\n        uint256 sign;\\n        uint256 isNegative;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if n {\\n                let c := and(mload(add(s, 1)), 0xff)\\n                isNegative := eq(c, 45)\\n                if or(eq(c, 43), isNegative) {\\n                    sign := c\\n                    s := add(s, 1)\\n                    mstore(s, sub(n, 1))\\n                }\\n                if iszero(or(sign, lt(sub(c, 48), 10))) { s := 0x60 }\\n            }\\n        }\\n        uint256 x = parseUint(s);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(lt(x, add(shl(255, 1), isNegative))) {\\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if sign {\\n                mstore(s, sign)\\n                s := sub(s, 1)\\n                mstore(s, n)\\n            }\\n            result := xor(x, mul(xor(x, add(not(x), 1)), isNegative))\\n        }\\n    }\\n\\n    /// @dev Parses an unsigned integer from a string (in hexadecimal, i.e. base 16).\\n    /// Reverts if `s` is not a valid uint256 hex string matching the RegEx\\n    /// `^(0[xX])?[0-9a-fA-F]+$`, or if the parsed number cannot fit within `[0 .. 2**256 - 1]`.\\n    function parseUintFromHex(string memory s) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let n := mload(s)\\n            // Skip two if starts with '0x' or '0X'.\\n            let i := shl(1, and(eq(0x3078, or(shr(240, mload(add(s, 0x20))), 0x20)), gt(n, 1)))\\n            for {} 1 {} {\\n                i := add(i, 1)\\n                let c :=\\n                    byte(\\n                        and(0x1f, shr(and(mload(add(s, i)), 0xff), 0x3e4088843e41bac000000000000)),\\n                        0x3010a071000000b0104040208000c05090d060e0f\\n                    )\\n                n := mul(n, iszero(or(iszero(c), shr(252, result))))\\n                result := add(shl(4, result), sub(c, 1))\\n                if iszero(lt(i, n)) { break }\\n            }\\n            if iszero(n) {\\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Decodes a JSON encoded string.\\n    /// The string MUST be double-quoted, JSON encoded.\\n    /// Reverts if the string is invalid.\\n    /// As you can see, it's pretty complex for a deceptively simple looking task.\\n    function decodeString(string memory s) internal pure returns (string memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            function fail() {\\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n\\n            function decodeUnicodeEscapeSequence(pIn_, end_) -> _unicode, _pOut {\\n                _pOut := add(pIn_, 4)\\n                let b_ := iszero(gt(_pOut, end_))\\n                let t_ := mload(pIn_) // Load the whole word.\\n                for { let i_ := 0 } iszero(eq(i_, 4)) { i_ := add(i_, 1) } {\\n                    let c_ := sub(byte(i_, t_), 48)\\n                    if iszero(and(shr(c_, 0x7e0000007e03ff), b_)) { fail() } // Not hexadecimal.\\n                    c_ := sub(c_, add(mul(gt(c_, 16), 7), shl(5, gt(c_, 48))))\\n                    _unicode := add(shl(4, _unicode), c_)\\n                }\\n            }\\n\\n            function decodeUnicodeCodePoint(pIn_, end_) -> _unicode, _pOut {\\n                _unicode, _pOut := decodeUnicodeEscapeSequence(pIn_, end_)\\n                if iszero(or(lt(_unicode, 0xd800), gt(_unicode, 0xdbff))) {\\n                    let t_ := mload(_pOut) // Load the whole word.\\n                    end_ := mul(end_, eq(shr(240, t_), 0x5c75)) // Fail if not starting with '\\\\\\\\u'.\\n                    t_, _pOut := decodeUnicodeEscapeSequence(add(_pOut, 2), end_)\\n                    _unicode := add(0x10000, add(shl(10, and(0x3ff, _unicode)), and(0x3ff, t_)))\\n                }\\n            }\\n\\n            function appendCodePointAsUTF8(pIn_, c_) -> _pOut {\\n                if iszero(gt(c_, 0x7f)) {\\n                    mstore8(pIn_, c_)\\n                    _pOut := add(pIn_, 1)\\n                    leave\\n                }\\n                mstore8(0x1f, c_)\\n                mstore8(0x1e, shr(6, c_))\\n                if iszero(gt(c_, 0x7ff)) {\\n                    mstore(pIn_, shl(240, or(0xc080, and(0x1f3f, mload(0x00)))))\\n                    _pOut := add(pIn_, 2)\\n                    leave\\n                }\\n                mstore8(0x1d, shr(12, c_))\\n                if iszero(gt(c_, 0xffff)) {\\n                    mstore(pIn_, shl(232, or(0xe08080, and(0x0f3f3f, mload(0x00)))))\\n                    _pOut := add(pIn_, 3)\\n                    leave\\n                }\\n                mstore8(0x1c, shr(18, c_))\\n                mstore(pIn_, shl(224, or(0xf0808080, and(0x073f3f3f, mload(0x00)))))\\n                _pOut := add(pIn_, shl(2, lt(c_, 0x110000)))\\n            }\\n\\n            function chr(p_) -> _c {\\n                _c := byte(0, mload(p_))\\n            }\\n\\n            let n := mload(s)\\n            let end := add(add(s, n), 0x1f)\\n            if iszero(and(gt(n, 1), eq(0x2222, or(and(0xff00, mload(add(s, 2))), chr(end))))) {\\n                fail() // Fail if not double-quoted.\\n            }\\n            let out := add(mload(0x40), 0x20)\\n            for { let curr := add(s, 0x21) } iszero(eq(curr, end)) {} {\\n                let c := chr(curr)\\n                curr := add(curr, 1)\\n                // Not '\\\\\\\\'.\\n                if iszero(eq(c, 92)) {\\n                    // Not '\\\"'.\\n                    if iszero(eq(c, 34)) {\\n                        mstore8(out, c)\\n                        out := add(out, 1)\\n                        continue\\n                    }\\n                    curr := end\\n                }\\n                if iszero(eq(curr, end)) {\\n                    let escape := chr(curr)\\n                    curr := add(curr, 1)\\n                    // '\\\"', '/', '\\\\\\\\'.\\n                    if and(shr(escape, 0x100000000000800400000000), 1) {\\n                        mstore8(out, escape)\\n                        out := add(out, 1)\\n                        continue\\n                    }\\n                    // 'u'.\\n                    if eq(escape, 117) {\\n                        escape, curr := decodeUnicodeCodePoint(curr, end)\\n                        out := appendCodePointAsUTF8(out, escape)\\n                        continue\\n                    }\\n                    // `{'b':'\\\\b', 'f':'\\\\f', 'n':'\\\\n', 'r':'\\\\r', 't':'\\\\t'}`.\\n                    escape := byte(sub(escape, 85), 0x080000000c000000000000000a0000000d0009)\\n                    if escape {\\n                        mstore8(out, escape)\\n                        out := add(out, 1)\\n                        continue\\n                    }\\n                }\\n                fail()\\n                break\\n            }\\n            mstore(out, 0) // Zeroize the last slot.\\n            result := mload(0x40)\\n            mstore(result, sub(out, add(result, 0x20))) // Store the length.\\n            mstore(0x40, add(out, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                      PRIVATE HELPERS                       */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Performs a query on the input with the given mode.\\n    function _query(bytes32 input, uint256 mode) private pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            function fail() {\\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n\\n            function chr(p_) -> _c {\\n                _c := byte(0, mload(p_))\\n            }\\n\\n            function skipWhitespace(pIn_, end_) -> _pOut {\\n                for { _pOut := pIn_ } 1 { _pOut := add(_pOut, 1) } {\\n                    if iszero(and(shr(chr(_pOut), 0x100002600), 1)) { leave } // Not in ' \\\\n\\\\r\\\\t'.\\n                }\\n            }\\n\\n            function setP(packed_, bitpos_, p_) -> _packed {\\n                // Perform an out-of-gas revert if `p_` exceeds `_BITMASK_POINTER`.\\n                returndatacopy(returndatasize(), returndatasize(), gt(p_, _BITMASK_POINTER))\\n                _packed := or(and(not(shl(bitpos_, _BITMASK_POINTER)), packed_), shl(bitpos_, p_))\\n            }\\n\\n            function getP(packed_, bitpos_) -> _p {\\n                _p := and(_BITMASK_POINTER, shr(bitpos_, packed_))\\n            }\\n\\n            function mallocItem(s_, packed_, pStart_, pCurr_, type_) -> _item {\\n                _item := mload(0x40)\\n                // forgefmt: disable-next-item\\n                packed_ := setP(setP(packed_, _BITPOS_VALUE, sub(pStart_, add(s_, 0x20))),\\n                    _BITPOS_VALUE_LENGTH, sub(pCurr_, pStart_))\\n                mstore(_item, or(packed_, type_))\\n                mstore(0x40, add(_item, 0x20)) // Allocate memory.\\n            }\\n\\n            function parseValue(s_, sibling_, pIn_, end_) -> _item, _pOut {\\n                let packed_ := setP(mload(0x00), _BITPOS_SIBLING_OR_PARENT, sibling_)\\n                _pOut := skipWhitespace(pIn_, end_)\\n                if iszero(lt(_pOut, end_)) { leave }\\n                for { let c_ := chr(_pOut) } 1 {} {\\n                    // If starts with '\\\"'.\\n                    if eq(c_, 34) {\\n                        let pStart_ := _pOut\\n                        _pOut := parseStringSub(s_, packed_, _pOut, end_)\\n                        _item := mallocItem(s_, packed_, pStart_, _pOut, TYPE_STRING)\\n                        break\\n                    }\\n                    // If starts with '['.\\n                    if eq(c_, 91) {\\n                        _item, _pOut := parseArray(s_, packed_, _pOut, end_)\\n                        break\\n                    }\\n                    // If starts with '{'.\\n                    if eq(c_, 123) {\\n                        _item, _pOut := parseObject(s_, packed_, _pOut, end_)\\n                        break\\n                    }\\n                    // If starts with any in '0123456789-'.\\n                    if and(shr(c_, shl(45, 0x1ff9)), 1) {\\n                        _item, _pOut := parseNumber(s_, packed_, _pOut, end_)\\n                        break\\n                    }\\n                    if iszero(gt(add(_pOut, 4), end_)) {\\n                        let pStart_ := _pOut\\n                        let w_ := shr(224, mload(_pOut))\\n                        // 'true' in hex format.\\n                        if eq(w_, 0x74727565) {\\n                            _pOut := add(_pOut, 4)\\n                            _item := mallocItem(s_, packed_, pStart_, _pOut, TYPE_BOOLEAN)\\n                            break\\n                        }\\n                        // 'null' in hex format.\\n                        if eq(w_, 0x6e756c6c) {\\n                            _pOut := add(_pOut, 4)\\n                            _item := mallocItem(s_, packed_, pStart_, _pOut, TYPE_NULL)\\n                            break\\n                        }\\n                    }\\n                    if iszero(gt(add(_pOut, 5), end_)) {\\n                        let pStart_ := _pOut\\n                        let w_ := shr(216, mload(_pOut))\\n                        // 'false' in hex format.\\n                        if eq(w_, 0x66616c7365) {\\n                            _pOut := add(_pOut, 5)\\n                            _item := mallocItem(s_, packed_, pStart_, _pOut, TYPE_BOOLEAN)\\n                            break\\n                        }\\n                    }\\n                    fail()\\n                    break\\n                }\\n                _pOut := skipWhitespace(_pOut, end_)\\n            }\\n\\n            function parseArray(s_, packed_, pIn_, end_) -> _item, _pOut {\\n                let j_ := 0\\n                for { _pOut := add(pIn_, 1) } 1 { _pOut := add(_pOut, 1) } {\\n                    if iszero(lt(_pOut, end_)) { fail() }\\n                    if iszero(_item) {\\n                        _pOut := skipWhitespace(_pOut, end_)\\n                        if eq(chr(_pOut), 93) { break } // ']'.\\n                    }\\n                    _item, _pOut := parseValue(s_, _item, _pOut, end_)\\n                    if _item {\\n                        // forgefmt: disable-next-item\\n                        mstore(_item, setP(or(_PARENT_IS_ARRAY, mload(_item)),\\n                            _BITPOS_KEY, j_))\\n                        j_ := add(j_, 1)\\n                        let c_ := chr(_pOut)\\n                        if eq(c_, 93) { break } // ']'.\\n                        if eq(c_, 44) { continue } // ','.\\n                    }\\n                    _pOut := end_\\n                }\\n                _pOut := add(_pOut, 1)\\n                packed_ := setP(packed_, _BITPOS_CHILD, _item)\\n                _item := mallocItem(s_, packed_, pIn_, _pOut, TYPE_ARRAY)\\n            }\\n\\n            function parseObject(s_, packed_, pIn_, end_) -> _item, _pOut {\\n                for { _pOut := add(pIn_, 1) } 1 { _pOut := add(_pOut, 1) } {\\n                    if iszero(lt(_pOut, end_)) { fail() }\\n                    if iszero(_item) {\\n                        _pOut := skipWhitespace(_pOut, end_)\\n                        if eq(chr(_pOut), 125) { break } // '}'.\\n                    }\\n                    _pOut := skipWhitespace(_pOut, end_)\\n                    let pKeyStart_ := _pOut\\n                    let pKeyEnd_ := parseStringSub(s_, _item, _pOut, end_)\\n                    _pOut := skipWhitespace(pKeyEnd_, end_)\\n                    // If ':'.\\n                    if eq(chr(_pOut), 58) {\\n                        _item, _pOut := parseValue(s_, _item, add(_pOut, 1), end_)\\n                        if _item {\\n                            // forgefmt: disable-next-item\\n                            mstore(_item, setP(setP(or(_PARENT_IS_OBJECT, mload(_item)),\\n                                _BITPOS_KEY_LENGTH, sub(pKeyEnd_, pKeyStart_)),\\n                                    _BITPOS_KEY, sub(pKeyStart_, add(s_, 0x20))))\\n                            let c_ := chr(_pOut)\\n                            if eq(c_, 125) { break } // '}'.\\n                            if eq(c_, 44) { continue } // ','.\\n                        }\\n                    }\\n                    _pOut := end_\\n                }\\n                _pOut := add(_pOut, 1)\\n                packed_ := setP(packed_, _BITPOS_CHILD, _item)\\n                _item := mallocItem(s_, packed_, pIn_, _pOut, TYPE_OBJECT)\\n            }\\n\\n            function checkStringU(p_, o_) {\\n                // If not in '0123456789abcdefABCDEF', revert.\\n                if iszero(and(shr(sub(chr(add(p_, o_)), 48), 0x7e0000007e03ff), 1)) { fail() }\\n                if iszero(eq(o_, 5)) { checkStringU(p_, add(o_, 1)) }\\n            }\\n\\n            function parseStringSub(s_, packed_, pIn_, end_) -> _pOut {\\n                if iszero(lt(pIn_, end_)) { fail() }\\n                for { _pOut := add(pIn_, 1) } 1 {} {\\n                    let c_ := chr(_pOut)\\n                    if eq(c_, 34) { break } // '\\\"'.\\n                    // Not '\\\\'.\\n                    if iszero(eq(c_, 92)) {\\n                        _pOut := add(_pOut, 1)\\n                        continue\\n                    }\\n                    c_ := chr(add(_pOut, 1))\\n                    // '\\\"', '\\\\', '//', 'b', 'f', 'n', 'r', 't'.\\n                    if and(shr(sub(c_, 34), 0x510110400000000002001), 1) {\\n                        _pOut := add(_pOut, 2)\\n                        continue\\n                    }\\n                    // 'u'.\\n                    if eq(c_, 117) {\\n                        checkStringU(_pOut, 2)\\n                        _pOut := add(_pOut, 6)\\n                        continue\\n                    }\\n                    _pOut := end_\\n                    break\\n                }\\n                if iszero(lt(_pOut, end_)) { fail() }\\n                _pOut := add(_pOut, 1)\\n            }\\n\\n            function skip0To9s(pIn_, end_, atLeastOne_) -> _pOut {\\n                for { _pOut := pIn_ } 1 { _pOut := add(_pOut, 1) } {\\n                    if iszero(lt(sub(chr(_pOut), 48), 10)) { break } // Not '0'..'9'.\\n                }\\n                if and(atLeastOne_, eq(pIn_, _pOut)) { fail() }\\n            }\\n\\n            function parseNumber(s_, packed_, pIn_, end_) -> _item, _pOut {\\n                _pOut := pIn_\\n                if eq(chr(_pOut), 45) { _pOut := add(_pOut, 1) } // '-'.\\n                if iszero(lt(sub(chr(_pOut), 48), 10)) { fail() } // Not '0'..'9'.\\n                let c_ := chr(_pOut)\\n                _pOut := add(_pOut, 1)\\n                if iszero(eq(c_, 48)) { _pOut := skip0To9s(_pOut, end_, 0) } // Not '0'.\\n                if eq(chr(_pOut), 46) { _pOut := skip0To9s(add(_pOut, 1), end_, 1) } // '.'.\\n                let t_ := mload(_pOut)\\n                // 'E', 'e'.\\n                if eq(or(0x20, byte(0, t_)), 101) {\\n                    // forgefmt: disable-next-item\\n                    _pOut := skip0To9s(add(byte(sub(byte(1, t_), 14), 0x010001), // '+', '-'.\\n                        add(_pOut, 1)), end_, 1)\\n                }\\n                _item := mallocItem(s_, packed_, pIn_, _pOut, TYPE_NUMBER)\\n            }\\n\\n            function copyStr(s_, offset_, len_) -> _sCopy {\\n                _sCopy := mload(0x40)\\n                s_ := add(s_, offset_)\\n                let w_ := not(0x1f)\\n                for { let i_ := and(add(len_, 0x1f), w_) } 1 {} {\\n                    mstore(add(_sCopy, i_), mload(add(s_, i_)))\\n                    i_ := add(i_, w_) // `sub(i_, 0x20)`.\\n                    if iszero(i_) { break }\\n                }\\n                mstore(_sCopy, len_) // Copy the length.\\n                mstore(add(add(_sCopy, 0x20), len_), 0) // Zeroize the last slot.\\n                mstore(0x40, add(add(_sCopy, 0x40), len_)) // Allocate memory.\\n            }\\n\\n            function value(item_) -> _value {\\n                let packed_ := mload(item_)\\n                _value := getP(packed_, _BITPOS_VALUE) // The offset in the string.\\n                if iszero(and(_VALUE_INITED, packed_)) {\\n                    let s_ := getP(packed_, _BITPOS_STRING)\\n                    _value := copyStr(s_, _value, getP(packed_, _BITPOS_VALUE_LENGTH))\\n                    packed_ := setP(packed_, _BITPOS_VALUE, _value)\\n                    mstore(s_, or(_VALUE_INITED, packed_))\\n                }\\n            }\\n\\n            function children(item_) -> _arr {\\n                _arr := 0x60 // Initialize to the zero pointer.\\n                let packed_ := mload(item_)\\n                for {} iszero(gt(and(_BITMASK_TYPE, packed_), TYPE_OBJECT)) {} {\\n                    if or(iszero(packed_), iszero(item_)) { break }\\n                    if and(packed_, _CHILDREN_INITED) {\\n                        _arr := getP(packed_, _BITPOS_CHILD)\\n                        break\\n                    }\\n                    _arr := mload(0x40)\\n                    let o_ := add(_arr, 0x20)\\n                    for { let h_ := getP(packed_, _BITPOS_CHILD) } h_ {} {\\n                        mstore(o_, h_)\\n                        let q_ := mload(h_)\\n                        let y_ := getP(q_, _BITPOS_SIBLING_OR_PARENT)\\n                        mstore(h_, setP(q_, _BITPOS_SIBLING_OR_PARENT, item_))\\n                        h_ := y_\\n                        o_ := add(o_, 0x20)\\n                    }\\n                    let w_ := not(0x1f)\\n                    let n_ := add(w_, sub(o_, _arr))\\n                    mstore(_arr, shr(5, n_))\\n                    mstore(0x40, o_) // Allocate memory.\\n                    packed_ := setP(packed_, _BITPOS_CHILD, _arr)\\n                    mstore(item_, or(_CHILDREN_INITED, packed_))\\n                    // Reverse the array.\\n                    if iszero(lt(n_, 0x40)) {\\n                        let lo_ := add(_arr, 0x20)\\n                        let hi_ := add(_arr, n_)\\n                        for {} 1 {} {\\n                            let temp_ := mload(lo_)\\n                            mstore(lo_, mload(hi_))\\n                            mstore(hi_, temp_)\\n                            hi_ := add(hi_, w_)\\n                            lo_ := add(lo_, 0x20)\\n                            if iszero(lt(lo_, hi_)) { break }\\n                        }\\n                    }\\n                    break\\n                }\\n            }\\n\\n            function getStr(item_, bitpos_, bitposLength_, bitmaskInited_) -> _result {\\n                _result := 0x60 // Initialize to the zero pointer.\\n                let packed_ := mload(item_)\\n                if or(iszero(item_), iszero(packed_)) { leave }\\n                _result := getP(packed_, bitpos_)\\n                if iszero(and(bitmaskInited_, packed_)) {\\n                    let s_ := getP(packed_, _BITPOS_STRING)\\n                    _result := copyStr(s_, _result, getP(packed_, bitposLength_))\\n                    mstore(item_, or(bitmaskInited_, setP(packed_, bitpos_, _result)))\\n                }\\n            }\\n\\n            switch mode\\n            // Get value.\\n            case 0 { result := getStr(input, _BITPOS_VALUE, _BITPOS_VALUE_LENGTH, _VALUE_INITED) }\\n            // Get key.\\n            case 1 { result := getStr(input, _BITPOS_KEY, _BITPOS_KEY_LENGTH, _KEY_INITED) }\\n            // Get children.\\n            case 3 { result := children(input) }\\n            // Parse.\\n            default {\\n                let p := add(input, 0x20)\\n                let e := add(p, mload(input))\\n                if iszero(eq(p, e)) {\\n                    let c := chr(e)\\n                    mstore8(e, 34) // Place a '\\\"' at the end to speed up parsing.\\n                    // The `34 << 248` makes `mallocItem` preserve '\\\"' at the end.\\n                    mstore(0x00, setP(shl(248, 34), _BITPOS_STRING, input))\\n                    result, p := parseValue(input, 0, p, e)\\n                    mstore8(e, c) // Restore the original char at the end.\\n                }\\n                if or(lt(p, e), iszero(result)) { fail() }\\n            }\\n        }\\n    }\\n\\n    /// @dev Casts the input to a bytes32.\\n    function _toInput(string memory input) private pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := input\\n        }\\n    }\\n\\n    /// @dev Casts the input to a bytes32.\\n    function _toInput(Item memory input) private pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := input\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x24ddc4015b10af1bcf9eb4fd69d1e03a575698b0104b9ecc60c0c25464cd4d03\",\"license\":\"MIT\"},\"solady/src/utils/LibString.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library for converting numbers into strings and other string operations.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibString.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)\\n///\\n/// Note:\\n/// For performance and bytecode compactness, most of the string operations are restricted to\\n/// byte strings (7-bit ASCII), except where otherwise specified.\\n/// Usage of byte string operations on charsets with runes spanning two or more bytes\\n/// can lead to undefined behavior.\\nlibrary LibString {\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                        CUSTOM ERRORS                       */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The length of the output is too small to contain all the hex digits.\\n    error HexLengthInsufficient();\\n\\n    /// @dev The length of the string is more than 32 bytes.\\n    error TooBigForSmallString();\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The constant returned when the `search` is not found in the string.\\n    uint256 internal constant NOT_FOUND = type(uint256).max;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                     DECIMAL OPERATIONS                     */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns the base 10 decimal representation of `value`.\\n    function toString(uint256 value) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\\n            // and 3 words for a maximum of 78 digits.\\n            str := add(mload(0x40), 0x80)\\n            // Update the free memory pointer to allocate.\\n            mstore(0x40, add(str, 0x20))\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end of the memory to calculate the length later.\\n            let end := str\\n\\n            let w := not(0) // Tsk.\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for { let temp := value } 1 {} {\\n                str := add(str, w) // `sub(str, 1)`.\\n                // Write the character to the pointer.\\n                // The ASCII index of the '0' character is 48.\\n                mstore8(str, add(48, mod(temp, 10)))\\n                // Keep dividing `temp` until zero.\\n                temp := div(temp, 10)\\n                if iszero(temp) { break }\\n            }\\n\\n            let length := sub(end, str)\\n            // Move the pointer 32 bytes leftwards to make room for the length.\\n            str := sub(str, 0x20)\\n            // Store the length.\\n            mstore(str, length)\\n        }\\n    }\\n\\n    /// @dev Returns the base 10 decimal representation of `value`.\\n    function toString(int256 value) internal pure returns (string memory str) {\\n        if (value >= 0) {\\n            return toString(uint256(value));\\n        }\\n        unchecked {\\n            str = toString(~uint256(value) + 1);\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We still have some spare memory space on the left,\\n            // as we have allocated 3 words (96 bytes) for up to 78 digits.\\n            let length := mload(str) // Load the string length.\\n            mstore(str, 0x2d) // Store the '-' character.\\n            str := sub(str, 1) // Move back the string pointer by a byte.\\n            mstore(str, add(length, 1)) // Update the string length.\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                   HEXADECIMAL OPERATIONS                   */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns the hexadecimal representation of `value`,\\n    /// left-padded to an input length of `length` bytes.\\n    /// The output is prefixed with \\\"0x\\\" encoded using 2 hexadecimal digits per byte,\\n    /// giving a total length of `length * 2 + 2` bytes.\\n    /// Reverts if `length` is too small for the output to contain all the digits.\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value, length);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Write the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`,\\n    /// left-padded to an input length of `length` bytes.\\n    /// The output is prefixed with \\\"0x\\\" encoded using 2 hexadecimal digits per byte,\\n    /// giving a total length of `length * 2` bytes.\\n    /// Reverts if `length` is too small for the output to contain all the digits.\\n    function toHexStringNoPrefix(uint256 value, uint256 length)\\n        internal\\n        pure\\n        returns (string memory str)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes\\n            // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.\\n            // We add 0x20 to the total and round down to a multiple of 0x20.\\n            // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.\\n            str := add(mload(0x40), and(add(shl(1, length), 0x42), not(0x1f)))\\n            // Allocate the memory.\\n            mstore(0x40, add(str, 0x20))\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end to calculate the length later.\\n            let end := str\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            let start := sub(str, add(length, length))\\n            let w := not(1) // Tsk.\\n            let temp := value\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for {} 1 {} {\\n                str := add(str, w) // `sub(str, 2)`.\\n                mstore8(add(str, 1), mload(and(temp, 15)))\\n                mstore8(str, mload(and(shr(4, temp), 15)))\\n                temp := shr(8, temp)\\n                if iszero(xor(str, start)) { break }\\n            }\\n\\n            if temp {\\n                mstore(0x00, 0x2194895a) // `HexLengthInsufficient()`.\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Compute the string's length.\\n            let strLength := sub(end, str)\\n            // Move the pointer and write the length.\\n            str := sub(str, 0x20)\\n            mstore(str, strLength)\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\" and encoded using 2 hexadecimal digits per byte.\\n    /// As address are 20 bytes long, the output will left-padded to have\\n    /// a length of `20 * 2 + 2` bytes.\\n    function toHexString(uint256 value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Write the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\".\\n    /// The output excludes leading \\\"0\\\" from the `toHexString` output.\\n    /// `0x00: \\\"0x0\\\", 0x01: \\\"0x1\\\", 0x12: \\\"0x12\\\", 0x123: \\\"0x123\\\"`.\\n    function toMinimalHexString(uint256 value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(add(str, o), 0x3078) // Write the \\\"0x\\\" prefix, accounting for leading zero.\\n            str := sub(add(str, o), 2) // Move the pointer, accounting for leading zero.\\n            mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output excludes leading \\\"0\\\" from the `toHexStringNoPrefix` output.\\n    /// `0x00: \\\"0\\\", 0x01: \\\"1\\\", 0x12: \\\"12\\\", 0x123: \\\"123\\\"`.\\n    function toMinimalHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\\n            let strLength := mload(str) // Get the length.\\n            str := add(str, o) // Move the pointer, accounting for leading zero.\\n            mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    /// As address are 20 bytes long, the output will left-padded to have\\n    /// a length of `20 * 2` bytes.\\n    function toHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\\n            // 0x02 bytes for the prefix, and 0x40 bytes for the digits.\\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.\\n            str := add(mload(0x40), 0x80)\\n            // Allocate the memory.\\n            mstore(0x40, add(str, 0x20))\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end to calculate the length later.\\n            let end := str\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            let w := not(1) // Tsk.\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for { let temp := value } 1 {} {\\n                str := add(str, w) // `sub(str, 2)`.\\n                mstore8(add(str, 1), mload(and(temp, 15)))\\n                mstore8(str, mload(and(shr(4, temp), 15)))\\n                temp := shr(8, temp)\\n                if iszero(temp) { break }\\n            }\\n\\n            // Compute the string's length.\\n            let strLength := sub(end, str)\\n            // Move the pointer and write the length.\\n            str := sub(str, 0x20)\\n            mstore(str, strLength)\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\", encoded using 2 hexadecimal digits per byte,\\n    /// and the alphabets are capitalized conditionally according to\\n    /// https://eips.ethereum.org/EIPS/eip-55\\n    function toHexStringChecksummed(address value) internal pure returns (string memory str) {\\n        str = toHexString(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`\\n            let o := add(str, 0x22)\\n            let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `\\n            let t := shl(240, 136) // `0b10001000 << 240`\\n            for { let i := 0 } 1 {} {\\n                mstore(add(i, i), mul(t, byte(i, hashed)))\\n                i := add(i, 1)\\n                if eq(i, 20) { break }\\n            }\\n            mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))\\n            o := add(o, 0x20)\\n            mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\" and encoded using 2 hexadecimal digits per byte.\\n    function toHexString(address value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Write the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    function toHexStringNoPrefix(address value) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            str := mload(0x40)\\n\\n            // Allocate the memory.\\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\\n            // 0x02 bytes for the prefix, and 0x28 bytes for the digits.\\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.\\n            mstore(0x40, add(str, 0x80))\\n\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            str := add(str, 2)\\n            mstore(str, 40)\\n\\n            let o := add(str, 0x20)\\n            mstore(add(o, 40), 0)\\n\\n            value := shl(96, value)\\n\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for { let i := 0 } 1 {} {\\n                let p := add(o, add(i, i))\\n                let temp := byte(i, value)\\n                mstore8(add(p, 1), mload(and(temp, 15)))\\n                mstore8(p, mload(shr(4, temp)))\\n                i := add(i, 1)\\n                if eq(i, 20) { break }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the hex encoded string from the raw bytes.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    function toHexString(bytes memory raw) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(raw);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Write the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hex encoded string from the raw bytes.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    function toHexStringNoPrefix(bytes memory raw) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let length := mload(raw)\\n            str := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.\\n            mstore(str, add(length, length)) // Store the length of the output.\\n\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            let o := add(str, 0x20)\\n            let end := add(raw, length)\\n\\n            for {} iszero(eq(raw, end)) {} {\\n                raw := add(raw, 1)\\n                mstore8(add(o, 1), mload(and(mload(raw), 15)))\\n                mstore8(o, mload(and(shr(4, mload(raw)), 15)))\\n                o := add(o, 2)\\n            }\\n            mstore(o, 0) // Zeroize the slot after the string.\\n            mstore(0x40, add(o, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                   RUNE STRING OPERATIONS                   */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns the number of UTF characters in the string.\\n    function runeCount(string memory s) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if mload(s) {\\n                mstore(0x00, div(not(0), 255))\\n                mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)\\n                let o := add(s, 0x20)\\n                let end := add(o, mload(s))\\n                for { result := 1 } 1 { result := add(result, 1) } {\\n                    o := add(o, byte(0, mload(shr(250, mload(o)))))\\n                    if iszero(lt(o, end)) { break }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns if this string is a 7-bit ASCII string.\\n    /// (i.e. all characters codes are in [0..127])\\n    function is7BitASCII(string memory s) internal pure returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let mask := shl(7, div(not(0), 255))\\n            result := 1\\n            let n := mload(s)\\n            if n {\\n                let o := add(s, 0x20)\\n                let end := add(o, n)\\n                let last := mload(end)\\n                mstore(end, 0)\\n                for {} 1 {} {\\n                    if and(mask, mload(o)) {\\n                        result := 0\\n                        break\\n                    }\\n                    o := add(o, 0x20)\\n                    if iszero(lt(o, end)) { break }\\n                }\\n                mstore(end, last)\\n            }\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                   BYTE STRING OPERATIONS                   */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    // For performance and bytecode compactness, byte string operations are restricted\\n    // to 7-bit ASCII strings. All offsets are byte offsets, not UTF character offsets.\\n    // Usage of byte string operations on charsets with runes spanning two or more bytes\\n    // can lead to undefined behavior.\\n\\n    /// @dev Returns `subject` all occurrences of `search` replaced with `replacement`.\\n    function replace(string memory subject, string memory search, string memory replacement)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            let searchLength := mload(search)\\n            let replacementLength := mload(replacement)\\n\\n            subject := add(subject, 0x20)\\n            search := add(search, 0x20)\\n            replacement := add(replacement, 0x20)\\n            result := add(mload(0x40), 0x20)\\n\\n            let subjectEnd := add(subject, subjectLength)\\n            if iszero(gt(searchLength, subjectLength)) {\\n                let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)\\n                let h := 0\\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\\n                let s := mload(search)\\n                for {} 1 {} {\\n                    let t := mload(subject)\\n                    // Whether the first `searchLength % 32` bytes of\\n                    // `subject` and `search` matches.\\n                    if iszero(shr(m, xor(t, s))) {\\n                        if h {\\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\\n                                mstore(result, t)\\n                                result := add(result, 1)\\n                                subject := add(subject, 1)\\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\\n                                continue\\n                            }\\n                        }\\n                        // Copy the `replacement` one word at a time.\\n                        for { let o := 0 } 1 {} {\\n                            mstore(add(result, o), mload(add(replacement, o)))\\n                            o := add(o, 0x20)\\n                            if iszero(lt(o, replacementLength)) { break }\\n                        }\\n                        result := add(result, replacementLength)\\n                        subject := add(subject, searchLength)\\n                        if searchLength {\\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\\n                            continue\\n                        }\\n                    }\\n                    mstore(result, t)\\n                    result := add(result, 1)\\n                    subject := add(subject, 1)\\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\\n                }\\n            }\\n\\n            let resultRemainder := result\\n            result := add(mload(0x40), 0x20)\\n            let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))\\n            // Copy the rest of the string one word at a time.\\n            for {} lt(subject, subjectEnd) {} {\\n                mstore(resultRemainder, mload(subject))\\n                resultRemainder := add(resultRemainder, 0x20)\\n                subject := add(subject, 0x20)\\n            }\\n            result := sub(result, 0x20)\\n            let last := add(add(result, 0x20), k) // Zeroize the slot after the string.\\n            mstore(last, 0)\\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n            mstore(result, k) // Store the length.\\n        }\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from left to right, starting from `from`.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function indexOf(string memory subject, string memory search, uint256 from)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for { let subjectLength := mload(subject) } 1 {} {\\n                if iszero(mload(search)) {\\n                    if iszero(gt(from, subjectLength)) {\\n                        result := from\\n                        break\\n                    }\\n                    result := subjectLength\\n                    break\\n                }\\n                let searchLength := mload(search)\\n                let subjectStart := add(subject, 0x20)\\n\\n                result := not(0) // Initialize to `NOT_FOUND`.\\n\\n                subject := add(subjectStart, from)\\n                let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)\\n\\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\\n                let s := mload(add(search, 0x20))\\n\\n                if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }\\n\\n                if iszero(lt(searchLength, 0x20)) {\\n                    for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\\n                        if iszero(shr(m, xor(mload(subject), s))) {\\n                            if eq(keccak256(subject, searchLength), h) {\\n                                result := sub(subject, subjectStart)\\n                                break\\n                            }\\n                        }\\n                        subject := add(subject, 1)\\n                        if iszero(lt(subject, end)) { break }\\n                    }\\n                    break\\n                }\\n                for {} 1 {} {\\n                    if iszero(shr(m, xor(mload(subject), s))) {\\n                        result := sub(subject, subjectStart)\\n                        break\\n                    }\\n                    subject := add(subject, 1)\\n                    if iszero(lt(subject, end)) { break }\\n                }\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from left to right.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function indexOf(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        result = indexOf(subject, search, 0);\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from right to left, starting from `from`.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function lastIndexOf(string memory subject, string memory search, uint256 from)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {} 1 {} {\\n                result := not(0) // Initialize to `NOT_FOUND`.\\n                let searchLength := mload(search)\\n                if gt(searchLength, mload(subject)) { break }\\n                let w := result\\n\\n                let fromMax := sub(mload(subject), searchLength)\\n                if iszero(gt(fromMax, from)) { from := fromMax }\\n\\n                let end := add(add(subject, 0x20), w)\\n                subject := add(add(subject, 0x20), from)\\n                if iszero(gt(subject, end)) { break }\\n                // As this function is not too often used,\\n                // we shall simply use keccak256 for smaller bytecode size.\\n                for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\\n                    if eq(keccak256(subject, searchLength), h) {\\n                        result := sub(subject, add(end, 1))\\n                        break\\n                    }\\n                    subject := add(subject, w) // `sub(subject, 1)`.\\n                    if iszero(gt(subject, end)) { break }\\n                }\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from right to left.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function lastIndexOf(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        result = lastIndexOf(subject, search, uint256(int256(-1)));\\n    }\\n\\n    /// @dev Returns true if `search` is found in `subject`, false otherwise.\\n    function contains(string memory subject, string memory search) internal pure returns (bool) {\\n        return indexOf(subject, search) != NOT_FOUND;\\n    }\\n\\n    /// @dev Returns whether `subject` starts with `search`.\\n    function startsWith(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (bool result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let searchLength := mload(search)\\n            // Just using keccak256 directly is actually cheaper.\\n            // forgefmt: disable-next-item\\n            result := and(\\n                iszero(gt(searchLength, mload(subject))),\\n                eq(\\n                    keccak256(add(subject, 0x20), searchLength),\\n                    keccak256(add(search, 0x20), searchLength)\\n                )\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns whether `subject` ends with `search`.\\n    function endsWith(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (bool result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let searchLength := mload(search)\\n            let subjectLength := mload(subject)\\n            // Whether `search` is not longer than `subject`.\\n            let withinRange := iszero(gt(searchLength, subjectLength))\\n            // Just using keccak256 directly is actually cheaper.\\n            // forgefmt: disable-next-item\\n            result := and(\\n                withinRange,\\n                eq(\\n                    keccak256(\\n                        // `subject + 0x20 + max(subjectLength - searchLength, 0)`.\\n                        add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),\\n                        searchLength\\n                    ),\\n                    keccak256(add(search, 0x20), searchLength)\\n                )\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns `subject` repeated `times`.\\n    function repeat(string memory subject, uint256 times)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            if iszero(or(iszero(times), iszero(subjectLength))) {\\n                subject := add(subject, 0x20)\\n                result := mload(0x40)\\n                let output := add(result, 0x20)\\n                for {} 1 {} {\\n                    // Copy the `subject` one word at a time.\\n                    for { let o := 0 } 1 {} {\\n                        mstore(add(output, o), mload(add(subject, o)))\\n                        o := add(o, 0x20)\\n                        if iszero(lt(o, subjectLength)) { break }\\n                    }\\n                    output := add(output, subjectLength)\\n                    times := sub(times, 1)\\n                    if iszero(times) { break }\\n                }\\n                mstore(output, 0) // Zeroize the slot after the string.\\n                let resultLength := sub(output, add(result, 0x20))\\n                mstore(result, resultLength) // Store the length.\\n                // Allocate the memory.\\n                mstore(0x40, add(result, add(resultLength, 0x20)))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\\n    /// `start` and `end` are byte offsets.\\n    function slice(string memory subject, uint256 start, uint256 end)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            if iszero(gt(subjectLength, end)) { end := subjectLength }\\n            if iszero(gt(subjectLength, start)) { start := subjectLength }\\n            if lt(start, end) {\\n                result := mload(0x40)\\n                let resultLength := sub(end, start)\\n                mstore(result, resultLength)\\n                subject := add(subject, start)\\n                let w := not(0x1f)\\n                // Copy the `subject` one word at a time, backwards.\\n                for { let o := and(add(resultLength, 0x1f), w) } 1 {} {\\n                    mstore(add(result, o), mload(add(subject, o)))\\n                    o := add(o, w) // `sub(o, 0x20)`.\\n                    if iszero(o) { break }\\n                }\\n                // Zeroize the slot after the string.\\n                mstore(add(add(result, 0x20), resultLength), 0)\\n                // Allocate memory for the length and the bytes,\\n                // rounded up to a multiple of 32.\\n                mstore(0x40, add(result, and(add(resultLength, 0x3f), w)))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the string.\\n    /// `start` is a byte offset.\\n    function slice(string memory subject, uint256 start)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        result = slice(subject, start, uint256(int256(-1)));\\n    }\\n\\n    /// @dev Returns all the indices of `search` in `subject`.\\n    /// The indices are byte offsets.\\n    function indicesOf(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (uint256[] memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            let searchLength := mload(search)\\n\\n            if iszero(gt(searchLength, subjectLength)) {\\n                subject := add(subject, 0x20)\\n                search := add(search, 0x20)\\n                result := add(mload(0x40), 0x20)\\n\\n                let subjectStart := subject\\n                let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)\\n                let h := 0\\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\\n                let s := mload(search)\\n                for {} 1 {} {\\n                    let t := mload(subject)\\n                    // Whether the first `searchLength % 32` bytes of\\n                    // `subject` and `search` matches.\\n                    if iszero(shr(m, xor(t, s))) {\\n                        if h {\\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\\n                                subject := add(subject, 1)\\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\\n                                continue\\n                            }\\n                        }\\n                        // Append to `result`.\\n                        mstore(result, sub(subject, subjectStart))\\n                        result := add(result, 0x20)\\n                        // Advance `subject` by `searchLength`.\\n                        subject := add(subject, searchLength)\\n                        if searchLength {\\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\\n                            continue\\n                        }\\n                    }\\n                    subject := add(subject, 1)\\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\\n                }\\n                let resultEnd := result\\n                // Assign `result` to the free memory pointer.\\n                result := mload(0x40)\\n                // Store the length of `result`.\\n                mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))\\n                // Allocate memory for result.\\n                // We allocate one more word, so this array can be recycled for {split}.\\n                mstore(0x40, add(resultEnd, 0x20))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a arrays of strings based on the `delimiter` inside of the `subject` string.\\n    function split(string memory subject, string memory delimiter)\\n        internal\\n        pure\\n        returns (string[] memory result)\\n    {\\n        uint256[] memory indices = indicesOf(subject, delimiter);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let w := not(0x1f)\\n            let indexPtr := add(indices, 0x20)\\n            let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))\\n            mstore(add(indicesEnd, w), mload(subject))\\n            mstore(indices, add(mload(indices), 1))\\n            let prevIndex := 0\\n            for {} 1 {} {\\n                let index := mload(indexPtr)\\n                mstore(indexPtr, 0x60)\\n                if iszero(eq(index, prevIndex)) {\\n                    let element := mload(0x40)\\n                    let elementLength := sub(index, prevIndex)\\n                    mstore(element, elementLength)\\n                    // Copy the `subject` one word at a time, backwards.\\n                    for { let o := and(add(elementLength, 0x1f), w) } 1 {} {\\n                        mstore(add(element, o), mload(add(add(subject, prevIndex), o)))\\n                        o := add(o, w) // `sub(o, 0x20)`.\\n                        if iszero(o) { break }\\n                    }\\n                    // Zeroize the slot after the string.\\n                    mstore(add(add(element, 0x20), elementLength), 0)\\n                    // Allocate memory for the length and the bytes,\\n                    // rounded up to a multiple of 32.\\n                    mstore(0x40, add(element, and(add(elementLength, 0x3f), w)))\\n                    // Store the `element` into the array.\\n                    mstore(indexPtr, element)\\n                }\\n                prevIndex := add(index, mload(delimiter))\\n                indexPtr := add(indexPtr, 0x20)\\n                if iszero(lt(indexPtr, indicesEnd)) { break }\\n            }\\n            result := indices\\n            if iszero(mload(delimiter)) {\\n                result := add(indices, 0x20)\\n                mstore(result, sub(mload(indices), 2))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a concatenated string of `a` and `b`.\\n    /// Cheaper than `string.concat()` and does not de-align the free memory pointer.\\n    function concat(string memory a, string memory b)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let w := not(0x1f)\\n            result := mload(0x40)\\n            let aLength := mload(a)\\n            // Copy `a` one word at a time, backwards.\\n            for { let o := and(add(aLength, 0x20), w) } 1 {} {\\n                mstore(add(result, o), mload(add(a, o)))\\n                o := add(o, w) // `sub(o, 0x20)`.\\n                if iszero(o) { break }\\n            }\\n            let bLength := mload(b)\\n            let output := add(result, aLength)\\n            // Copy `b` one word at a time, backwards.\\n            for { let o := and(add(bLength, 0x20), w) } 1 {} {\\n                mstore(add(output, o), mload(add(b, o)))\\n                o := add(o, w) // `sub(o, 0x20)`.\\n                if iszero(o) { break }\\n            }\\n            let totalLength := add(aLength, bLength)\\n            let last := add(add(result, 0x20), totalLength)\\n            // Zeroize the slot after the string.\\n            mstore(last, 0)\\n            // Stores the length.\\n            mstore(result, totalLength)\\n            // Allocate memory for the length and the bytes,\\n            // rounded up to a multiple of 32.\\n            mstore(0x40, and(add(last, 0x1f), w))\\n        }\\n    }\\n\\n    /// @dev Returns a copy of the string in either lowercase or UPPERCASE.\\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\\n    function toCase(string memory subject, bool toUpper)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let length := mload(subject)\\n            if length {\\n                result := add(mload(0x40), 0x20)\\n                subject := add(subject, 1)\\n                let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)\\n                let w := not(0)\\n                for { let o := length } 1 {} {\\n                    o := add(o, w)\\n                    let b := and(0xff, mload(add(subject, o)))\\n                    mstore8(add(result, o), xor(b, and(shr(b, flags), 0x20)))\\n                    if iszero(o) { break }\\n                }\\n                result := mload(0x40)\\n                mstore(result, length) // Store the length.\\n                let last := add(add(result, 0x20), length)\\n                mstore(last, 0) // Zeroize the slot after the string.\\n                mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a string from a small bytes32 string.\\n    /// `s` must be null-terminated, or behavior will be undefined.\\n    function fromSmallString(bytes32 s) internal pure returns (string memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            let n := 0\\n            for {} byte(n, s) { n := add(n, 1) } {} // Scan for '\\\\0'.\\n            mstore(result, n)\\n            let o := add(result, 0x20)\\n            mstore(o, s)\\n            mstore(add(o, n), 0)\\n            mstore(0x40, add(result, 0x40))\\n        }\\n    }\\n\\n    /// @dev Returns the small string, with all bytes after the first null byte zeroized.\\n    function normalizeSmallString(bytes32 s) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {} byte(result, s) { result := add(result, 1) } {} // Scan for '\\\\0'.\\n            mstore(0x00, s)\\n            mstore(result, 0x00)\\n            result := mload(0x00)\\n        }\\n    }\\n\\n    /// @dev Returns the string as a normalized null-terminated small string.\\n    function toSmallString(string memory s) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(s)\\n            if iszero(lt(result, 33)) {\\n                mstore(0x00, 0xec92f9a3) // `TooBigForSmallString()`.\\n                revert(0x1c, 0x04)\\n            }\\n            result := shl(shl(3, sub(32, result)), mload(add(s, result)))\\n        }\\n    }\\n\\n    /// @dev Returns a lowercased copy of the string.\\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\\n    function lower(string memory subject) internal pure returns (string memory result) {\\n        result = toCase(subject, false);\\n    }\\n\\n    /// @dev Returns an UPPERCASED copy of the string.\\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\\n    function upper(string memory subject) internal pure returns (string memory result) {\\n        result = toCase(subject, true);\\n    }\\n\\n    /// @dev Escapes the string to be used within HTML tags.\\n    function escapeHTML(string memory s) internal pure returns (string memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let end := add(s, mload(s))\\n            result := add(mload(0x40), 0x20)\\n            // Store the bytes of the packed offsets and strides into the scratch space.\\n            // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.\\n            mstore(0x1f, 0x900094)\\n            mstore(0x08, 0xc0000000a6ab)\\n            // Store \\\"&quot;&amp;&#39;&lt;&gt;\\\" into the scratch space.\\n            mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))\\n            for {} iszero(eq(s, end)) {} {\\n                s := add(s, 1)\\n                let c := and(mload(s), 0xff)\\n                // Not in `[\\\"\\\\\\\"\\\",\\\"'\\\",\\\"&\\\",\\\"<\\\",\\\">\\\"]`.\\n                if iszero(and(shl(c, 1), 0x500000c400000000)) {\\n                    mstore8(result, c)\\n                    result := add(result, 1)\\n                    continue\\n                }\\n                let t := shr(248, mload(c))\\n                mstore(result, mload(and(t, 0x1f)))\\n                result := add(result, shr(5, t))\\n            }\\n            let last := result\\n            mstore(last, 0) // Zeroize the slot after the string.\\n            result := mload(0x40)\\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\\n    /// If `addDoubleQuotes` is true, the result will be enclosed in double-quotes.\\n    function escapeJSON(string memory s, bool addDoubleQuotes)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let end := add(s, mload(s))\\n            result := add(mload(0x40), 0x20)\\n            if addDoubleQuotes {\\n                mstore8(result, 34)\\n                result := add(1, result)\\n            }\\n            // Store \\\"\\\\\\\\u0000\\\" in scratch space.\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            // Also, store `{0x08:\\\"b\\\", 0x09:\\\"t\\\", 0x0a:\\\"n\\\", 0x0c:\\\"f\\\", 0x0d:\\\"r\\\"}`.\\n            // into the scratch space.\\n            mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)\\n            // Bitmask for detecting `[\\\"\\\\\\\"\\\",\\\"\\\\\\\\\\\"]`.\\n            let e := or(shl(0x22, 1), shl(0x5c, 1))\\n            for {} iszero(eq(s, end)) {} {\\n                s := add(s, 1)\\n                let c := and(mload(s), 0xff)\\n                if iszero(lt(c, 0x20)) {\\n                    if iszero(and(shl(c, 1), e)) {\\n                        // Not in `[\\\"\\\\\\\"\\\",\\\"\\\\\\\\\\\"]`.\\n                        mstore8(result, c)\\n                        result := add(result, 1)\\n                        continue\\n                    }\\n                    mstore8(result, 0x5c) // \\\"\\\\\\\\\\\".\\n                    mstore8(add(result, 1), c)\\n                    result := add(result, 2)\\n                    continue\\n                }\\n                if iszero(and(shl(c, 1), 0x3700)) {\\n                    // Not in `[\\\"\\\\b\\\",\\\"\\\\t\\\",\\\"\\\\n\\\",\\\"\\\\f\\\",\\\"\\\\d\\\"]`.\\n                    mstore8(0x1d, mload(shr(4, c))) // Hex value.\\n                    mstore8(0x1e, mload(and(c, 15))) // Hex value.\\n                    mstore(result, mload(0x19)) // \\\"\\\\\\\\u00XX\\\".\\n                    result := add(result, 6)\\n                    continue\\n                }\\n                mstore8(result, 0x5c) // \\\"\\\\\\\\\\\".\\n                mstore8(add(result, 1), mload(add(c, 8)))\\n                result := add(result, 2)\\n            }\\n            if addDoubleQuotes {\\n                mstore8(result, 34)\\n                result := add(1, result)\\n            }\\n            let last := result\\n            mstore(last, 0) // Zeroize the slot after the string.\\n            result := mload(0x40)\\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\\n    function escapeJSON(string memory s) internal pure returns (string memory result) {\\n        result = escapeJSON(s, false);\\n    }\\n\\n    /// @dev Returns whether `a` equals `b`.\\n    function eq(string memory a, string memory b) internal pure returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))\\n        }\\n    }\\n\\n    /// @dev Returns whether `a` equals `b`, where `b` is a null-terminated small string.\\n    function eqs(string memory a, bytes32 b) internal pure returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // These should be evaluated on compile time, as far as possible.\\n            let m := not(shl(7, div(not(iszero(b)), 255))) // `0x7f7f ...`.\\n            let x := not(or(m, or(b, add(m, and(b, m)))))\\n            let r := shl(7, iszero(iszero(shr(128, x))))\\n            r := or(r, shl(6, iszero(iszero(shr(64, shr(r, x))))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\\n            // forgefmt: disable-next-item\\n            result := gt(eq(mload(a), add(iszero(x), xor(31, shr(3, r)))),\\n                xor(shr(add(8, r), b), shr(add(8, r), mload(add(a, 0x20)))))\\n        }\\n    }\\n\\n    /// @dev Packs a single string with its length into a single word.\\n    /// Returns `bytes32(0)` if the length is zero or greater than 31.\\n    function packOne(string memory a) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We don't need to zero right pad the string,\\n            // since this is our own custom non-standard packing scheme.\\n            result :=\\n                mul(\\n                    // Load the length and the bytes.\\n                    mload(add(a, 0x1f)),\\n                    // `length != 0 && length < 32`. Abuses underflow.\\n                    // Assumes that the length is valid and within the block gas limit.\\n                    lt(sub(mload(a), 1), 0x1f)\\n                )\\n        }\\n    }\\n\\n    /// @dev Unpacks a string packed using {packOne}.\\n    /// Returns the empty string if `packed` is `bytes32(0)`.\\n    /// If `packed` is not an output of {packOne}, the output behavior is undefined.\\n    function unpackOne(bytes32 packed) internal pure returns (string memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Grab the free memory pointer.\\n            result := mload(0x40)\\n            // Allocate 2 words (1 for the length, 1 for the bytes).\\n            mstore(0x40, add(result, 0x40))\\n            // Zeroize the length slot.\\n            mstore(result, 0)\\n            // Store the length and bytes.\\n            mstore(add(result, 0x1f), packed)\\n            // Right pad with zeroes.\\n            mstore(add(add(result, 0x20), mload(result)), 0)\\n        }\\n    }\\n\\n    /// @dev Packs two strings with their lengths into a single word.\\n    /// Returns `bytes32(0)` if combined length is zero or greater than 30.\\n    function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let aLength := mload(a)\\n            // We don't need to zero right pad the strings,\\n            // since this is our own custom non-standard packing scheme.\\n            result :=\\n                mul(\\n                    // Load the length and the bytes of `a` and `b`.\\n                    or(\\n                        shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))),\\n                        mload(sub(add(b, 0x1e), aLength))\\n                    ),\\n                    // `totalLength != 0 && totalLength < 31`. Abuses underflow.\\n                    // Assumes that the lengths are valid and within the block gas limit.\\n                    lt(sub(add(aLength, mload(b)), 1), 0x1e)\\n                )\\n        }\\n    }\\n\\n    /// @dev Unpacks strings packed using {packTwo}.\\n    /// Returns the empty strings if `packed` is `bytes32(0)`.\\n    /// If `packed` is not an output of {packTwo}, the output behavior is undefined.\\n    function unpackTwo(bytes32 packed)\\n        internal\\n        pure\\n        returns (string memory resultA, string memory resultB)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Grab the free memory pointer.\\n            resultA := mload(0x40)\\n            resultB := add(resultA, 0x40)\\n            // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.\\n            mstore(0x40, add(resultB, 0x40))\\n            // Zeroize the length slots.\\n            mstore(resultA, 0)\\n            mstore(resultB, 0)\\n            // Store the lengths and bytes.\\n            mstore(add(resultA, 0x1f), packed)\\n            mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))\\n            // Right pad with zeroes.\\n            mstore(add(add(resultA, 0x20), mload(resultA)), 0)\\n            mstore(add(add(resultB, 0x20), mload(resultB)), 0)\\n        }\\n    }\\n\\n    /// @dev Directly returns `a` without copying.\\n    function directReturn(string memory a) internal pure {\\n        assembly {\\n            // Assumes that the string does not start from the scratch space.\\n            let retStart := sub(a, 0x20)\\n            let retSize := add(mload(a), 0x40)\\n            // Right pad with zeroes. Just in case the string is produced\\n            // by a method that doesn't zero right pad.\\n            mstore(add(retStart, retSize), 0)\\n            // Store the return offset.\\n            mstore(retStart, 0x20)\\n            // End the transaction, returning the string.\\n            return(retStart, retSize)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf9089e94e05f506f21357bc513c166d58f4d6a02d589741c72e8a7722cefeda2\",\"license\":\"MIT\"},\"solidity-rlp/contracts/RLPReader.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * @author Hamdi Allam hamdi.allam97@gmail.com\\n * Please reach out with any questions or concerns\\n */\\npragma solidity >=0.5.10 <0.9.0;\\n\\nlibrary RLPReader {\\n    uint8 constant STRING_SHORT_START = 0x80;\\n    uint8 constant STRING_LONG_START = 0xb8;\\n    uint8 constant LIST_SHORT_START = 0xc0;\\n    uint8 constant LIST_LONG_START = 0xf8;\\n    uint8 constant WORD_SIZE = 32;\\n\\n    struct RLPItem {\\n        uint256 len;\\n        uint256 memPtr;\\n    }\\n\\n    struct Iterator {\\n        RLPItem item; // Item that's being iterated over.\\n        uint256 nextPtr; // Position of the next item in the list.\\n    }\\n\\n    /*\\n     * @dev Returns the next element in the iteration. Reverts if it has not next element.\\n     * @param self The iterator.\\n     * @return The next element in the iteration.\\n     */\\n    function next(Iterator memory self) internal pure returns (RLPItem memory) {\\n        require(hasNext(self));\\n\\n        uint256 ptr = self.nextPtr;\\n        uint256 itemLength = _itemLength(ptr);\\n        self.nextPtr = ptr + itemLength;\\n\\n        return RLPItem(itemLength, ptr);\\n    }\\n\\n    /*\\n     * @dev Returns true if the iteration has more elements.\\n     * @param self The iterator.\\n     * @return true if the iteration has more elements.\\n     */\\n    function hasNext(Iterator memory self) internal pure returns (bool) {\\n        RLPItem memory item = self.item;\\n        return self.nextPtr < item.memPtr + item.len;\\n    }\\n\\n    /*\\n     * @param item RLP encoded bytes\\n     */\\n    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\\n        uint256 memPtr;\\n        assembly {\\n            memPtr := add(item, 0x20)\\n        }\\n\\n        return RLPItem(item.length, memPtr);\\n    }\\n\\n    /*\\n     * @dev Create an iterator. Reverts if item is not a list.\\n     * @param self The RLP item.\\n     * @return An 'Iterator' over the item.\\n     */\\n    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {\\n        require(isList(self));\\n\\n        uint256 ptr = self.memPtr + _payloadOffset(self.memPtr);\\n        return Iterator(self, ptr);\\n    }\\n\\n    /*\\n     * @param the RLP item.\\n     */\\n    function rlpLen(RLPItem memory item) internal pure returns (uint256) {\\n        return item.len;\\n    }\\n\\n    /*\\n     * @param the RLP item.\\n     * @return (memPtr, len) pair: location of the item's payload in memory.\\n     */\\n    function payloadLocation(RLPItem memory item) internal pure returns (uint256, uint256) {\\n        uint256 offset = _payloadOffset(item.memPtr);\\n        uint256 memPtr = item.memPtr + offset;\\n        uint256 len = item.len - offset; // data length\\n        return (memPtr, len);\\n    }\\n\\n    /*\\n     * @param the RLP item.\\n     */\\n    function payloadLen(RLPItem memory item) internal pure returns (uint256) {\\n        (, uint256 len) = payloadLocation(item);\\n        return len;\\n    }\\n\\n    /*\\n     * @param the RLP item containing the encoded list.\\n     */\\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {\\n        require(isList(item));\\n\\n        uint256 items = numItems(item);\\n        RLPItem[] memory result = new RLPItem[](items);\\n\\n        uint256 memPtr = item.memPtr + _payloadOffset(item.memPtr);\\n        uint256 dataLen;\\n        for (uint256 i = 0; i < items; i++) {\\n            dataLen = _itemLength(memPtr);\\n            result[i] = RLPItem(dataLen, memPtr);\\n            memPtr = memPtr + dataLen;\\n        }\\n\\n        return result;\\n    }\\n\\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\\n    function isList(RLPItem memory item) internal pure returns (bool) {\\n        if (item.len == 0) return false;\\n\\n        uint8 byte0;\\n        uint256 memPtr = item.memPtr;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 < LIST_SHORT_START) return false;\\n        return true;\\n    }\\n\\n    /*\\n     * @dev A cheaper version of keccak256(toRlpBytes(item)) that avoids copying memory.\\n     * @return keccak256 hash of RLP encoded bytes.\\n     */\\n    function rlpBytesKeccak256(RLPItem memory item) internal pure returns (bytes32) {\\n        uint256 ptr = item.memPtr;\\n        uint256 len = item.len;\\n        bytes32 result;\\n        assembly {\\n            result := keccak256(ptr, len)\\n        }\\n        return result;\\n    }\\n\\n    /*\\n     * @dev A cheaper version of keccak256(toBytes(item)) that avoids copying memory.\\n     * @return keccak256 hash of the item payload.\\n     */\\n    function payloadKeccak256(RLPItem memory item) internal pure returns (bytes32) {\\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\\n        bytes32 result;\\n        assembly {\\n            result := keccak256(memPtr, len)\\n        }\\n        return result;\\n    }\\n\\n    /** RLPItem conversions into data types **/\\n\\n    // @returns raw rlp encoding in bytes\\n    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {\\n        bytes memory result = new bytes(item.len);\\n        if (result.length == 0) return result;\\n\\n        uint256 ptr;\\n        assembly {\\n            ptr := add(0x20, result)\\n        }\\n\\n        copy(item.memPtr, ptr, item.len);\\n        return result;\\n    }\\n\\n    // any non-zero byte except \\\"0x80\\\" is considered true\\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\\n        require(item.len == 1);\\n        uint256 result;\\n        uint256 memPtr = item.memPtr;\\n        assembly {\\n            result := byte(0, mload(memPtr))\\n        }\\n\\n        // SEE Github Issue #5.\\n        // Summary: Most commonly used RLP libraries (i.e Geth) will encode\\n        // \\\"0\\\" as \\\"0x80\\\" instead of as \\\"0\\\". We handle this edge case explicitly\\n        // here.\\n        if (result == 0 || result == STRING_SHORT_START) {\\n            return false;\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    function toAddress(RLPItem memory item) internal pure returns (address) {\\n        // 1 byte for the length prefix\\n        require(item.len == 21);\\n\\n        return address(uint160(toUint(item)));\\n    }\\n\\n    function toUint(RLPItem memory item) internal pure returns (uint256) {\\n        require(item.len > 0 && item.len <= 33);\\n\\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\\n\\n        uint256 result;\\n        assembly {\\n            result := mload(memPtr)\\n\\n            // shift to the correct location if neccesary\\n            if lt(len, 32) {\\n                result := div(result, exp(256, sub(32, len)))\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    // enforces 32 byte length\\n    function toUintStrict(RLPItem memory item) internal pure returns (uint256) {\\n        // one byte prefix\\n        require(item.len == 33);\\n\\n        uint256 result;\\n        uint256 memPtr = item.memPtr + 1;\\n        assembly {\\n            result := mload(memPtr)\\n        }\\n\\n        return result;\\n    }\\n\\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\\n        require(item.len > 0);\\n\\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\\n        bytes memory result = new bytes(len);\\n\\n        uint256 destPtr;\\n        assembly {\\n            destPtr := add(0x20, result)\\n        }\\n\\n        copy(memPtr, destPtr, len);\\n        return result;\\n    }\\n\\n    /*\\n     * Private Helpers\\n     */\\n\\n    // @return number of payload items inside an encoded list.\\n    function numItems(RLPItem memory item) private pure returns (uint256) {\\n        if (item.len == 0) return 0;\\n\\n        uint256 count = 0;\\n        uint256 currPtr = item.memPtr + _payloadOffset(item.memPtr);\\n        uint256 endPtr = item.memPtr + item.len;\\n        while (currPtr < endPtr) {\\n            currPtr = currPtr + _itemLength(currPtr); // skip over an item\\n            count++;\\n        }\\n\\n        return count;\\n    }\\n\\n    // @return entire rlp item byte length\\n    function _itemLength(uint256 memPtr) private pure returns (uint256) {\\n        uint256 itemLen;\\n        uint256 byte0;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 < STRING_SHORT_START) {\\n            itemLen = 1;\\n        } else if (byte0 < STRING_LONG_START) {\\n            itemLen = byte0 - STRING_SHORT_START + 1;\\n        } else if (byte0 < LIST_SHORT_START) {\\n            assembly {\\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\\n                memPtr := add(memPtr, 1) // skip over the first byte\\n\\n                /* 32 byte word size */\\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\\n                itemLen := add(dataLen, add(byteLen, 1))\\n            }\\n        } else if (byte0 < LIST_LONG_START) {\\n            itemLen = byte0 - LIST_SHORT_START + 1;\\n        } else {\\n            assembly {\\n                let byteLen := sub(byte0, 0xf7)\\n                memPtr := add(memPtr, 1)\\n\\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\\n                itemLen := add(dataLen, add(byteLen, 1))\\n            }\\n        }\\n\\n        return itemLen;\\n    }\\n\\n    // @return number of bytes until the data\\n    function _payloadOffset(uint256 memPtr) private pure returns (uint256) {\\n        uint256 byte0;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 < STRING_SHORT_START) {\\n            return 0;\\n        } else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START)) {\\n            return 1;\\n        } else if (byte0 < LIST_SHORT_START) {\\n            // being explicit\\n            return byte0 - (STRING_LONG_START - 1) + 1;\\n        } else {\\n            return byte0 - (LIST_LONG_START - 1) + 1;\\n        }\\n    }\\n\\n    /*\\n     * @param src Pointer to source\\n     * @param dest Pointer to destination\\n     * @param len Amount of memory to copy from the source\\n     */\\n    function copy(uint256 src, uint256 dest, uint256 len) private pure {\\n        if (len == 0) return;\\n\\n        // copy as many word sizes as possible\\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n\\n            src += WORD_SIZE;\\n            dest += WORD_SIZE;\\n        }\\n\\n        if (len > 0) {\\n            // left over bytes. Mask is used to remove unwanted bytes from the word\\n            uint256 mask = 256**(WORD_SIZE - len) - 1;\\n            assembly {\\n                let srcpart := and(mload(src), not(mask)) // zero out src\\n                let destpart := and(mload(dest), mask) // retrieve the bytes\\n                mstore(dest, or(destpart, srcpart))\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x3a44f2de3c752fa4f926f3fd4cad8338dab742484150c0d7d2f785409ed8db4d\",\"license\":\"Apache-2.0\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50614ef4806100206000396000f3fe60806040526004361061010d5760003560e01c80639e0f4f4511610095578063d3596e7f11610064578063d3596e7f14610385578063d40ec066146103b0578063e2411625146103d9578063ea42418b14610402578063f77c47911461042d5761010e565b80639e0f4f45146102db578063adb8b6d614610306578063b72a654014610331578063cf1b037c1461035c5761010e565b806350723553116100dc57806350723553146101e057806357e3c1b51461021d57806370c905a51461025a5780637e48532c146102855780639829ba42146102b05761010e565b80630c79e696146101105780631d148b8d1461014d5780632e0f26251461018a5780633eb84396146101b55761010e565b5b005b34801561011c57600080fd5b5061013760048036038101906101329190613684565b610458565b6040516101449190613716565b60405180910390f35b34801561015957600080fd5b50610174600480360381019061016f91906137d2565b6104c6565b60405161018191906138a3565b60405180910390f35b34801561019657600080fd5b5061019f610637565b6040516101ac91906138e1565b60405180910390f35b3480156101c157600080fd5b506101ca61063c565b6040516101d79190613716565b60405180910390f35b3480156101ec57600080fd5b50610207600480360381019061020291906138fc565b610641565b6040516102149190613716565b60405180910390f35b34801561022957600080fd5b50610244600480360381019061023f91906139a3565b6106cd565b60405161025191906138a3565b60405180910390f35b34801561026657600080fd5b5061026f61083b565b60405161027c9190613a25565b60405180910390f35b34801561029157600080fd5b5061029a610857565b6040516102a791906138a3565b60405180910390f35b3480156102bc57600080fd5b506102c5610994565b6040516102d29190613a25565b60405180910390f35b3480156102e757600080fd5b506102f06109cd565b6040516102fd9190613a25565b60405180910390f35b34801561031257600080fd5b5061031b6109e9565b6040516103289190613a25565b60405180910390f35b34801561033d57600080fd5b50610346610a22565b6040516103539190613a25565b60405180910390f35b34801561036857600080fd5b50610383600480360381019061037e91906139a3565b610a3e565b005b34801561039157600080fd5b5061039a610b6b565b6040516103a79190613a94565b60405180910390f35b3480156103bc57600080fd5b506103d760048036038101906103d29190613aaf565b610b7e565b005b3480156103e557600080fd5b5061040060048036038101906103fb9190613b37565b610bbb565b005b34801561040e57600080fd5b50610417610c91565b6040516104249190613b86565b60405180910390f35b34801561043957600080fd5b50610442610cb7565b60405161044f9190613b86565b60405180910390f35b60006104a0610465610cdd565b6040518060400160405280601081526020017f4e6f7420636f6e666964656e7469616c00000000000000000000000000000000815250610da5565b60006104ab86610641565b90506104ba8682878787610deb565b80915050949350505050565b606060006104d383610e0d565b6040516020016104e39190613c9b565b60405160208183030381529060405290506104fc61340a565b6040518060400160405280600481526020017f504f5354000000000000000000000000000000000000000000000000000000008152508160200181905250818160600181905250600167ffffffffffffffff81111561055e5761055d6134e3565b5b60405190808252806020026020018201604052801561059157816020015b606081526020019060019003908161057c5790505b5081604001819052506040518060400160405280601e81526020017f436f6e74656e742d547970653a206170706c69636174696f6e2f6a736f6e000081525081604001516000815181106105e8576105e7613cc8565b5b602002602001018190525060008160800190151590811515815250506040518060600160405280603c8152602001614e83603c9139816000018190525061062e81610e33565b92505050919050565b600481565b600581565b60008061064d83610eec565b9050600061065a82611091565b905060006106ae6106a96040518060400160405280600781526020017f2270726963652200000000000000000000000000000000000000000000000000815250846110bd90919063ffffffff16565b611140565b90506106c36106bc82611162565b600461122f565b9350505050919050565b60606107156106da610cdd565b6040518060400160405280601081526020017f4e6f7420636f6e666964656e7469616c00000000000000000000000000000000815250610da5565b600073ffffffffffffffffffffffffffffffffffffffff16600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16146107a6576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161079d90613d43565b60405180910390fd5b60006107b1836113f6565b90506107bc816104c6565b5063cf1b037c60e01b836040516024016107d69190613b86565b604051602081830303815290604052907bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff8381831617835250505050915050919050565b604051806060016040528060228152602001614e616022913981565b606061089f610864610cdd565b6040518060400160405280601081526020017f4e6f7420636f6e666964656e7469616c00000000000000000000000000000000815250610da5565b6108ec60008054906101000a900460ff16156040518060400160405280601381526020017f416c726561647920696e697469616c697a656400000000000000000000000000815250610da5565b60006108f86000611593565b905060006109058261168a565b90506000610912836116f6565b905063e241162560e01b818360405160240161092f929190613d63565b604051602081830303815290604052907bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff8381831617835250505050935050505090565b6040518060400160405280601281526020017f6f7261636c653a76303a706b736563726574000000000000000000000000000081525081565b6040518060600160405280603c8152602001614e83603c913981565b6040518060400160405280600381526020017f307835000000000000000000000000000000000000000000000000000000000081525081565b6040518060600160405280603b8152602001614e26603b913981565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff161480610ae85750600073ffffffffffffffffffffffffffffffffffffffff16600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16145b610b27576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610b1e90613d43565b60405180910390fd5b80600260006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050565b600060019054906101000a900460801b81565b7ff61f2fd6ab65716facd3516c91d806d98dffa9670f127beac522f8cacfd1d8df8282604051610baf929190613d8c565b60405180910390a15050565b610c0860008054906101000a900460ff16156040518060400160405280601381526020017f416c726561647920696e697469616c697a656400000000000000000000000000815250610da5565b81600060016101000a8154816fffffffffffffffffffffffffffffffff021916908360801c021790555080600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060016000806101000a81548160ff0219169083151502179055505050565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6000806000634201000073ffffffffffffffffffffffffffffffffffffffff16604051610d0990613ded565b600060405180830381855afa9150503d8060008114610d44576040519150601f19603f3d011682016040523d82523d6000602084013e610d49565b606091505b509150915081610d96576342010000816040517f75fff467000000000000000000000000000000000000000000000000000000008152600401610d8d929190613e02565b60405180910390fd5b80516020820151935050505090565b81610de757806040517f0c25cd98000000000000000000000000000000000000000000000000000000008152600401610dde9190613a25565b60405180910390fd5b5050565b6000610df9868686866118d2565b9050610e04816104c6565b50505050505050565b6060610e1882611a9b565b90506002815101613078825260028203915080825250919050565b6060600080634320000273ffffffffffffffffffffffffffffffffffffffff1684604051602001610e64919061402e565b604051602081830303815290604052604051610e809190614081565b600060405180830381855afa9150503d8060008114610ebb576040519150601f19603f3d011682016040523d82523d6000602084013e610ec0565b606091505b5091509150610ecf8282610da5565b80806020019051810190610ee39190614108565b92505050919050565b60606000600167ffffffffffffffff811115610f0b57610f0a6134e3565b5b604051908082528060200260200182016040528015610f3e57816020015b6060815260200190600190039081610f295790505b5090506040518060400160405280601e81526020017f436f6e74656e742d547970653a206170706c69636174696f6e2f6a736f6e000081525081600081518110610f8b57610f8a613cc8565b5b602002602001018190525060006040518060a001604052806040518060600160405280603b8152602001614e26603b913986604051602001610fce929190614151565b60405160208183030381529060405281526020016040518060400160405280600381526020017f47455400000000000000000000000000000000000000000000000000000000008152508152602001838152602001600067ffffffffffffffff81111561103e5761103d6134e3565b5b6040519080825280601f01601f1916602001820160405280156110705781602001600182028036833780820191505090505b50815260200160001515815250905061108881610e33565b92505050919050565b61109961343b565b8060405260006110b26110ab84611b09565b60ff611b13565b905080915050919050565b6110c561343b565b80604052606090506110d6836123d7565b1561113a5760008280519060200120905060006110f2856123ee565b9050600060058251901b90505b60008114611136578082015195506020810390508261111d87612410565b805190602001200361113157859350611136565b6110ff565b5050505b92915050565b6060600061115761115084612442565b6000611b13565b905080915050919050565b6060600082905060028151116111ad576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016111a4906141c1565b60405180910390fd5b6000600282516111bd9190614210565b905060008167ffffffffffffffff8111156111db576111da6134e3565b5b6040519080825280601f01601f19166020018201604052801561120d5781602001600182028036833780820191505090505b5090506021830160208201845182518252848452505050809350505050919050565b600080839050600080600090505b82518110156112ab57602e60f81b83828151811061125e5761125d613cc8565b5b602001015160f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191603611298578091506112ab565b80806112a390614244565b91505061123d565b5060008060006001905060008490505b600081111561133a57816030876001846112d59190614210565b815181106112e6576112e5613cc8565b5b602001015160f81c60f81b60f81c6112fe919061428c565b60ff1661130b91906142c0565b84611316919061431a565b9350600a8261132591906142c0565b9150808061133290614370565b9150506112bb565b506001905060008760ff1685611350919061431a565b90505b848111156113c55781603087838151811061137157611370613cc8565b5b602001015160f81c60f81b60f81c611389919061428c565b60ff1661139691906142c0565b836113a1919061431a565b9250600a826113b091906142c0565b915080806113bd90614370565b915050611353565b508187600a6113d491906144cc565b846113df91906142c0565b6113e9919061431a565b9550505050505092915050565b606060006040518061014001604052808473ffffffffffffffffffffffffffffffffffffffff168152602001620186a0815260200164174876e800815260200160008152602001600081526020016040516024016040516020818303038152906040527f1aa3a008000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff83818316178352505050508152602001600581526020017f111111111111111111111111111111111111111111111111111111111111111181526020017f11111111111111111111111111111111111111111111111111111111111111118152602001601b67ffffffffffffffff168152509050600061153b8261244c565b905060006115476126fd565b9050611589826040518060400160405280600381526020017f307835000000000000000000000000000000000000000000000000000000000081525083612758565b9350505050919050565b6060600080635320000373ffffffffffffffffffffffffffffffffffffffff16846040516020016115c4919061458e565b6040516020818303038152906040526040516115e09190614081565b600060405180830381855afa9150503d806000811461161b576040519150601f19603f3d011682016040523d82523d6000602084013e611620565b606091505b50915091508161166d576353200003816040517f75fff467000000000000000000000000000000000000000000000000000000008152600401611664929190613e02565b60405180910390fd5b808060200190518101906116819190614619565b92505050919050565b60008060405160200161169c906146ae565b60405160208183030381529060405280519060200120905060006116e1826040516020016116ca91906146f9565b604051602081830303815290604052600086612855565b90506116ed8282612963565b92505050919050565b600080600367ffffffffffffffff811115611714576117136134e3565b5b6040519080825280602002602001820160405280156117425781602001602082028036833780820191505090505b509050308160008151811061175a57611759613cc8565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250506342030001816001815181106117ad576117ac613cc8565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff1681525050634202000181600281518110611800576117ff613cc8565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff1681525050600061187e600083846040518060400160405280601281526020017f6f7261636c653a76303a706b73656372657400000000000000000000000000008152506129d2565b90506118c481600001516040518060400160405280601281526020017f6f7261636c653a76303a706b736563726574000000000000000000000000000081525086612ad8565b806000015192505050919050565b60606000604051806101400160405280600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001620186a0815260200184815260200160008152602001858152602001878760405160240161194f929190613d8c565b6040516020818303038152906040527f4a432a46000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff83818316178352505050508152602001600581526020017f111111111111111111111111111111111111111111111111111111111111111181526020017f11111111111111111111111111111111111111111111111111111111111111118152602001601b67ffffffffffffffff1681525090506000611a408261244c565b90506000611a4c6126fd565b9050611a8e826040518060400160405280600381526020017f307835000000000000000000000000000000000000000000000000000000000081525083612758565b9350505050949350505050565b60608151600260405101915080810182526f30313233343536373839616263646566600f52602082018184015b808514611af657600185019450600f855116516001830153600f855160041c16518253600282019150611ac8565b6000825260208201604052505050919050565b6000819050919050565b600061231f565b63101827966000526004601cfd5b6000815160001a9050919050565b60008190505b600115611b66576001640100002600611b5483611b28565b1c1615611b6757600181019050611b3c565b5b92915050565b600063ffffffff84113d3d3e83831b8263ffffffff851b19161790509392505050565b600081831c63ffffffff16905092915050565b60006040519050611bc88486036078611bc3602086018803605888611b6d565b611b6d565b925085831781526020810160405295945050505050565b600080611bf0846018600051611b6d565b611bfa8787611b36565b9150868210611c095750611d5c565b611c1282611b28565b600115611d4d5760228103611c465782611c2e89858589611f9e565b9350611c3e60048583868a611ba3565b945050611d4d565b605b8103611c6357611c5a88848488611d65565b93509350611d4d565b607b8103611c8057611c7788848488611e3d565b93509350611d4d565b6001611ff9602d1b821c1615611ca557611c9c888484886120ad565b93509350611d4d565b876004840111611d085782835160e01c63747275658103611cdd57600485019450611cd460058684878b611ba3565b95505050611d4d565b636e756c6c8103611d0557600485019450611cfc60068684878b611ba3565b95505050611d4d565b50505b876005840111611d445782835160d81c6466616c73658103611d4157600585019450611d3860058684878b611ba3565b95505050611d4d565b50505b611d4c611b1a565b5b50611d588783611b36565b9150505b94509492505050565b60008060006001860191505b600115611e0f57868210611d8857611d87611b1a565b5b82611dab57611d978783611b36565b9150605d611da483611b28565b0315611e0f575b611db787838587611bdf565b925092508215611e0057611dd18160988551604017611b6d565b8352600181019050611de282611b28565b605d8103611df05750611e0f565b602c8103611dfe5750611e04565b505b8691505b600182019150611d71565b600182019150611e2183603887611b6d565b9450611e31600183888888611ba3565b92505094509492505050565b6000806001850190505b600115611f3057858110611e5e57611e5d611b1a565b5b81611e8157611e6d8682611b36565b9050607d611e7a82611b28565b0315611f30575b611e8b8682611b36565b905080611e9a87838587611f9e565b611ea48882611b36565b9250603a611eb184611b28565b03611f1f57611ec588600185018688611bdf565b935093508315611f1e57611ef16020860183036098611eec85850360b88951608017611b6d565b611b6d565b8452611efc83611b28565b607d8103611f0c57505050611f30565b602c8103611f1c57505050611f25565b505b5b87925050505b600181019050611e47565b600181019050611f4282603886611b6d565b9350611f52600282878787611ba3565b915094509492505050565b6001667e0000007e03ff6030611f74858501611b28565b031c16611f8457611f83611b1a565b5b60058214611f9a57611f996001830182611f5d565b5b5050565b6000848410611fb057611faf611b1a565b5b6001840190505b60011561204957611fc781611b28565b60228103611fd55750612049565b605c8114611fe95760018201915050612044565b611ff560018301611b28565b905060016a0510110400000000002001602283031c161561201c5760028201915050612044565b6075810361203b5761202f600283611f5d565b60068201915050612044565b85915050612049565b611fb7565b84811061205957612058611b1a565b5b600181019050949350505050565b60008190505b60011561209357600a603061208183611b28565b0310156120935760018101905061206d565b8082148416156120a6576120a5611b1a565b5b9392505050565b600080849050602d6120be82611b28565b036120ca576001810190505b600a60306120d783611b28565b03106120e6576120e5611b1a565b5b6120ef81611b28565b6001820191506030811461210c5761210960008884612067565b91505b602e61211783611b28565b0361212e5761212b60018860018501612067565b91505b815160658160001a6020170361215d5761215a6001896001860162010001600e8660011a031a01612067565b92505b61216b600384898989611ba3565b9350505094509492505050565b600060405190508282019150601f1980601f8601165b6001156121a857808401518184015281810190508061218e575b50848252600085602084010152846040830101604052509392505050565b6000606090508151600281600716116122b25782158115176122b25760208116156121fd576121f6603882611b90565b91506122b2565b604051915060208201612211603883611b90565b5b8015612246578082528051612228601882611b90565b61223487601884611b6d565b83528092506020840193505050612212565b50601f1983820381018060051c85528260405261226585603886611b6d565b9350836020178652604081106122ae57602085018186015b6001156122ab5781518151835280825284820191506020830192508183106122a557506122ab565b5061227d565b50505b5050505b50919050565b60006060905081518015831517156122d05750612317565b6122da8482611b90565b9150808616612315576122ee60d882611b90565b6123026122fb8784611b90565b8483612178565b925061230f838684611b6d565b87178452505b505b949350505050565b816000811461239857600181146123ae57600381146123c457602084018451810180821461237d5761235081611b28565b602282536123648760d8602260f81b611b6d565b600052612374828460008a611bdf565b93509450808253505b8315818310171561239157612390611b1a565b5b50506123d0565b6123a7601060786058876122b8565b91506123d0565b6123bd600860b86098876122b8565b91506123d0565b6123cd846121c6565b91505b5092915050565b6000600260ff166007836000015116149050919050565b606060006124056123fe84612442565b6003611b13565b905080915050919050565b6060600060808360000151161461243d57600061243661242f84612442565b6001611b13565b9050809150505b919050565b6000819050919050565b60606000600967ffffffffffffffff81111561246b5761246a6134e3565b5b60405190808252806020026020018201604052801561249e57816020015b60608152602001906001900390816124895790505b5090506124ae8360800151612bbb565b816000815181106124c2576124c1613cc8565b5b60200260200101819052506124da8360400151612bbb565b816001815181106124ee576124ed613cc8565b5b60200260200101819052506125068360200151612bbb565b8160028151811061251a57612519613cc8565b5b6020026020010181905250600073ffffffffffffffffffffffffffffffffffffffff16836000015173ffffffffffffffffffffffffffffffffffffffff16036125995761257560405180602001604052806000815250612bd5565b8160038151811061258957612588613cc8565b5b60200260200101819052506125c6565b6125a68360000151612c53565b816003815181106125ba576125b9613cc8565b5b60200260200101819052505b6125d38360600151612bbb565b816004815181106125e7576125e6613cc8565b5b60200260200101819052506125ff8360a00151612bd5565b8160058151811061261357612612613cc8565b5b602002602001018190525061263683610120015167ffffffffffffffff16612bbb565b8160068151811061264a57612649613cc8565b5b60200260200101819052506126818360e0015160405160200161266d91906146f9565b604051602081830303815290604052612bd5565b8160078151811061269557612694613cc8565b5b60200260200101819052506126cd8361010001516040516020016126b991906146f9565b604051602081830303815290604052612bd5565b816008815181106126e1576126e0613cc8565b5b60200260200101819052506126f581612c84565b915050919050565b6060600061274f600060019054906101000a900460801b6040518060400160405280601281526020017f6f7261636c653a76303a706b7365637265740000000000000000000000000000815250612cc8565b90508091505090565b6060600080634010000173ffffffffffffffffffffffffffffffffffffffff1686868660405160200161278d93929190614714565b6040516020818303038152906040526040516127a99190614081565b600060405180830381855afa9150503d80600081146127e4576040519150601f19603f3d011682016040523d82523d6000602084013e6127e9565b606091505b509150915081612836576340100001816040517f75fff46700000000000000000000000000000000000000000000000000000000815260040161282d929190613e02565b60405180910390fd5b8080602001905181019061284a9190614108565b925050509392505050565b606061285f610cdd565b61286857600080fd5b600080634010000373ffffffffffffffffffffffffffffffffffffffff1686868660405160200161289b93929190614760565b6040516020818303038152906040526040516128b79190614081565b600060405180830381855afa9150503d80600081146128f2576040519150601f19603f3d011682016040523d82523d6000602084013e6128f7565b606091505b509150915081612944576340100003816040517f75fff46700000000000000000000000000000000000000000000000000000000815260040161293b929190613e02565b60405180910390fd5b808060200190518101906129589190614108565b925050509392505050565b60008060008061297285612daf565b9250925092506001868285856040516000815260200160405260405161299b94939291906147b4565b6020604051602081039080840390855afa1580156129bd573d6000803e3d6000fd5b50505060206040510351935050505092915050565b6129da61344e565b600080634203000073ffffffffffffffffffffffffffffffffffffffff1687878787604051602001612a0f94939291906148c6565b604051602081830303815290604052604051612a2b9190614081565b600060405180830381855afa9150503d8060008114612a66576040519150601f19603f3d011682016040523d82523d6000602084013e612a6b565b606091505b509150915081612ab8576342030000816040517f75fff467000000000000000000000000000000000000000000000000000000008152600401612aaf929190613e02565b60405180910390fd5b80806020019051810190612acc9190614b25565b92505050949350505050565b600080634202000073ffffffffffffffffffffffffffffffffffffffff16858585604051602001612b0b93929190614b6e565b604051602081830303815290604052604051612b279190614081565b600060405180830381855afa9150503d8060008114612b62576040519150601f19603f3d011682016040523d82523d6000602084013e612b67565b606091505b509150915081612bb4576342020000816040517f75fff467000000000000000000000000000000000000000000000000000000008152600401612bab929190613e02565b60405180910390fd5b5050505050565b6060612bce612bc983612e33565b612bd5565b9050919050565b60608060018351148015612c0d5750608083600081518110612bfa57612bf9613cc8565b5b602001015160f81c60f81b60f81c60ff16105b15612c1a57829050612c4a565b612c2683516080612fb6565b83604051602001612c38929190614bb3565b60405160208183030381529060405290505b80915050919050565b6060612c7d82604051602001612c699190614c1f565b604051602081830303815290604052612bd5565b9050919050565b60606000612c9183613202565b9050612c9f815160c0612fb6565b81604051602001612cb1929190614bb3565b604051602081830303815290604052915050919050565b6060600080634202000173ffffffffffffffffffffffffffffffffffffffff168585604051602001612cfb929190614c3a565b604051602081830303815290604052604051612d179190614081565b600060405180830381855afa9150503d8060008114612d52576040519150601f19603f3d011682016040523d82523d6000602084013e612d57565b606091505b509150915081612da4576342020001816040517f75fff467000000000000000000000000000000000000000000000000000000008152600401612d9b929190613e02565b60405180910390fd5b809250505092915050565b60008060006041845114612df8576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401612def90614cb6565b60405180910390fd5b6020840151925060408401519150606084015160001a9050601b8160ff161015612e2c57601b81612e299190614cd6565b90505b9193909250565b6060600082604051602001612e489190614d2e565b604051602081830303815290604052905060005b6020811015612ec257600060f81b828281518110612e7d57612e7c613cc8565b5b602001015160f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191603612ec2578080612eba90614244565b915050612e5c565b6000816020612ed19190614210565b67ffffffffffffffff811115612eea57612ee96134e3565b5b6040519080825280601f01601f191660200182016040528015612f1c5781602001600182028036833780820191505090505b50905060005b8151811015612faa57838380612f3790614244565b945081518110612f4a57612f49613cc8565b5b602001015160f81c60f81b828281518110612f6857612f67613cc8565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a9053508080612fa290614244565b915050612f22565b50809350505050919050565b606080603884101561306957600167ffffffffffffffff811115612fdd57612fdc6134e3565b5b6040519080825280601f01601f19166020018201604052801561300f5781602001600182028036833780820191505090505b509050828461301e9190614cd6565b60f81b8160008151811061303557613034613cc8565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a9053506131f8565b600080600190505b6000818761307f9190614d78565b146130a757818061308f90614244565b925050610100816130a091906142c0565b9050613071565b6001826130b4919061431a565b67ffffffffffffffff8111156130cd576130cc6134e3565b5b6040519080825280601f01601f1916602001820160405280156130ff5781602001600182028036833780820191505090505b509250603785836131109190614cd6565b61311a9190614cd6565b60f81b8360008151811061313157613130613cc8565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a905350600190505b8181116131f557610100818361317b9190614210565b6101006131889190614da9565b876131939190614d78565b61319d9190614df4565b60f81b8382815181106131b3576131b2613cc8565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a90535080806131ed90614244565b915050613165565b50505b8091505092915050565b6060600082510361326257600067ffffffffffffffff811115613228576132276134e3565b5b6040519080825280601f01601f19166020018201604052801561325a5781602001600182028036833780820191505090505b50905061338f565b600080600090505b83518110156132af5783818151811061328657613285613cc8565b5b6020026020010151518261329a919061431a565b915080806132a790614244565b91505061326a565b60008267ffffffffffffffff8111156132cb576132ca6134e3565b5b6040519080825280601f01601f1916602001820160405280156132fd5781602001600182028036833780820191505090505b5090506000602082019050600092505b855183101561338757600086848151811061332b5761332a613cc8565b5b60200260200101519050600060208201905061334983828451613394565b87858151811061335c5761335b613cc8565b5b60200260200101515183613370919061431a565b92505050828061337f90614244565b93505061330d565b819450505050505b919050565b6000839050600083905060008390505b602081106133e257815183526020836133bd919061431a565b92506020826133cc919061431a565b91506020816133db9190614210565b90506133a4565b60006001826020036101000a0390508019835116818551168181178652505050505050505050565b6040518060a00160405280606081526020016060815260200160608152602001606081526020016000151581525090565b6040518060200160405280600081525090565b6040518060c0016040528060006fffffffffffffffffffffffffffffffff1916815260200160006fffffffffffffffffffffffffffffffff19168152602001600067ffffffffffffffff1681526020016060815260200160608152602001606081525090565b6000604051905090565b600080fd5b600080fd5b600080fd5b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b61351b826134d2565b810181811067ffffffffffffffff8211171561353a576135396134e3565b5b80604052505050565b600061354d6134b4565b90506135598282613512565b919050565b600067ffffffffffffffff821115613579576135786134e3565b5b613582826134d2565b9050602081019050919050565b82818337600083830152505050565b60006135b16135ac8461355e565b613543565b9050828152602081018484840111156135cd576135cc6134cd565b5b6135d884828561358f565b509392505050565b600082601f8301126135f5576135f46134c8565b5b813561360584826020860161359e565b91505092915050565b6000819050919050565b6136218161360e565b811461362c57600080fd5b50565b60008135905061363e81613618565b92915050565b600067ffffffffffffffff82169050919050565b61366181613644565b811461366c57600080fd5b50565b60008135905061367e81613658565b92915050565b6000806000806080858703121561369e5761369d6134be565b5b600085013567ffffffffffffffff8111156136bc576136bb6134c3565b5b6136c8878288016135e0565b94505060206136d98782880161362f565b93505060406136ea8782880161362f565b92505060606136fb8782880161366f565b91505092959194509250565b6137108161360e565b82525050565b600060208201905061372b6000830184613707565b92915050565b600067ffffffffffffffff82111561374c5761374b6134e3565b5b613755826134d2565b9050602081019050919050565b600061377561377084613731565b613543565b905082815260208101848484011115613791576137906134cd565b5b61379c84828561358f565b509392505050565b600082601f8301126137b9576137b86134c8565b5b81356137c9848260208601613762565b91505092915050565b6000602082840312156137e8576137e76134be565b5b600082013567ffffffffffffffff811115613806576138056134c3565b5b613812848285016137a4565b91505092915050565b600081519050919050565b600082825260208201905092915050565b60005b8381101561385557808201518184015260208101905061383a565b83811115613864576000848401525b50505050565b60006138758261381b565b61387f8185613826565b935061388f818560208601613837565b613898816134d2565b840191505092915050565b600060208201905081810360008301526138bd818461386a565b905092915050565b600060ff82169050919050565b6138db816138c5565b82525050565b60006020820190506138f660008301846138d2565b92915050565b600060208284031215613912576139116134be565b5b600082013567ffffffffffffffff8111156139305761392f6134c3565b5b61393c848285016135e0565b91505092915050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b600061397082613945565b9050919050565b61398081613965565b811461398b57600080fd5b50565b60008135905061399d81613977565b92915050565b6000602082840312156139b9576139b86134be565b5b60006139c78482850161398e565b91505092915050565b600081519050919050565b600082825260208201905092915050565b60006139f7826139d0565b613a0181856139db565b9350613a11818560208601613837565b613a1a816134d2565b840191505092915050565b60006020820190508181036000830152613a3f81846139ec565b905092915050565b60007fffffffffffffffffffffffffffffffff0000000000000000000000000000000082169050919050565b6000613a7e82613a47565b9050919050565b613a8e81613a73565b82525050565b6000602082019050613aa96000830184613a85565b92915050565b60008060408385031215613ac657613ac56134be565b5b600083013567ffffffffffffffff811115613ae457613ae36134c3565b5b613af0858286016135e0565b9250506020613b018582860161362f565b9150509250929050565b613b1481613a47565b8114613b1f57600080fd5b50565b600081359050613b3181613b0b565b92915050565b60008060408385031215613b4e57613b4d6134be565b5b6000613b5c85828601613b22565b9250506020613b6d8582860161398e565b9150509250929050565b613b8081613965565b82525050565b6000602082019050613b9b6000830184613b77565b92915050565b600081905092915050565b7f7b226a736f6e727063223a22322e30222c226d6574686f64223a226574685f7360008201527f656e645261775472616e73616374696f6e222c22706172616d73223a5b220000602082015250565b6000613c08603e83613ba1565b9150613c1382613bac565b603e82019050919050565b6000613c29826139d0565b613c338185613ba1565b9350613c43818560208601613837565b80840191505092915050565b7f225d2c226964223a317d00000000000000000000000000000000000000000000600082015250565b6000613c85600a83613ba1565b9150613c9082613c4f565b600a82019050919050565b6000613ca682613bfb565b9150613cb28284613c1e565b9150613cbd82613c78565b915081905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b7f416c726561647920726567697374657265640000000000000000000000000000600082015250565b6000613d2d6012836139db565b9150613d3882613cf7565b602082019050919050565b60006020820190508181036000830152613d5c81613d20565b9050919050565b6000604082019050613d786000830185613a85565b613d856020830184613b77565b9392505050565b60006040820190508181036000830152613da681856139ec565b9050613db56020830184613707565b9392505050565b600081905092915050565b50565b6000613dd7600083613dbc565b9150613de282613dc7565b600082019050919050565b6000613df882613dca565b9150819050919050565b6000604082019050613e176000830185613b77565b8181036020830152613e29818461386a565b90509392505050565b600082825260208201905092915050565b6000613e4e826139d0565b613e588185613e32565b9350613e68818560208601613837565b613e71816134d2565b840191505092915050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b6000613eb48383613e43565b905092915050565b6000602082019050919050565b6000613ed482613e7c565b613ede8185613e87565b935083602082028501613ef085613e98565b8060005b85811015613f2c5784840389528151613f0d8582613ea8565b9450613f1883613ebc565b925060208a01995050600181019050613ef4565b50829750879550505050505092915050565b600082825260208201905092915050565b6000613f5a8261381b565b613f648185613f3e565b9350613f74818560208601613837565b613f7d816134d2565b840191505092915050565b60008115159050919050565b613f9d81613f88565b82525050565b600060a0830160008301518482036000860152613fc08282613e43565b91505060208301518482036020860152613fda8282613e43565b91505060408301518482036040860152613ff48282613ec9565b9150506060830151848203606086015261400e8282613f4f565b91505060808301516140236080860182613f94565b508091505092915050565b600060208201905081810360008301526140488184613fa3565b905092915050565b600061405b8261381b565b6140658185613dbc565b9350614075818560208601613837565b80840191505092915050565b600061408d8284614050565b915081905092915050565b60006140ab6140a684613731565b613543565b9050828152602081018484840111156140c7576140c66134cd565b5b6140d2848285613837565b509392505050565b600082601f8301126140ef576140ee6134c8565b5b81516140ff848260208601614098565b91505092915050565b60006020828403121561411e5761411d6134be565b5b600082015167ffffffffffffffff81111561413c5761413b6134c3565b5b614148848285016140da565b91505092915050565b600061415d8285613c1e565b91506141698284613c1e565b91508190509392505050565b7f496e70757420746f6f2073686f72740000000000000000000000000000000000600082015250565b60006141ab600f836139db565b91506141b682614175565b602082019050919050565b600060208201905081810360008301526141da8161419e565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600061421b8261360e565b91506142268361360e565b925082821015614239576142386141e1565b5b828203905092915050565b600061424f8261360e565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203614281576142806141e1565b5b600182019050919050565b6000614297826138c5565b91506142a2836138c5565b9250828210156142b5576142b46141e1565b5b828203905092915050565b60006142cb8261360e565b91506142d68361360e565b9250817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff048311821515161561430f5761430e6141e1565b5b828202905092915050565b60006143258261360e565b91506143308361360e565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff03821115614365576143646141e1565b5b828201905092915050565b600061437b8261360e565b91506000820361438e5761438d6141e1565b5b600182039050919050565b60008160011c9050919050565b6000808291508390505b60018511156143f0578086048111156143cc576143cb6141e1565b5b60018516156143db5780820291505b80810290506143e985614399565b94506143b0565b94509492505050565b60008261440957600190506144c5565b8161441757600090506144c5565b816001811461442d576002811461443757614466565b60019150506144c5565b60ff841115614449576144486141e1565b5b8360020a9150848211156144605761445f6141e1565b5b506144c5565b5060208310610133831016604e8410600b841016171561449b5782820a905083811115614496576144956141e1565b5b6144c5565b6144a884848460016143a6565b925090508184048111156144bf576144be6141e1565b5b81810290505b9392505050565b60006144d78261360e565b91506144e2836138c5565b925061450f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff84846143f9565b905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b6002811061455757614556614517565b5b50565b600081905061456882614546565b919050565b60006145788261455a565b9050919050565b6145888161456d565b82525050565b60006020820190506145a3600083018461457f565b92915050565b60006145bc6145b78461355e565b613543565b9050828152602081018484840111156145d8576145d76134cd565b5b6145e3848285613837565b509392505050565b600082601f830112614600576145ff6134c8565b5b81516146108482602086016145a9565b91505092915050565b60006020828403121561462f5761462e6134be565b5b600082015167ffffffffffffffff81111561464d5761464c6134c3565b5b614659848285016145eb565b91505092915050565b7f796f000000000000000000000000000000000000000000000000000000000000600082015250565b60006146986002836139db565b91506146a382614662565b602082019050919050565b600060208201905081810360008301526146c78161468b565b9050919050565b6000819050919050565b6000819050919050565b6146f36146ee826146ce565b6146d8565b82525050565b600061470582846146e2565b60208201915081905092915050565b6000606082019050818103600083015261472e818661386a565b9050818103602083015261474281856139ec565b9050818103604083015261475681846139ec565b9050949350505050565b6000606082019050818103600083015261477a818661386a565b9050614789602083018561457f565b818103604083015261479b81846139ec565b9050949350505050565b6147ae816146ce565b82525050565b60006080820190506147c960008301876147a5565b6147d660208301866138d2565b6147e360408301856147a5565b6147f060608301846147a5565b95945050505050565b61480281613644565b82525050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b61483d81613965565b82525050565b600061484f8383614834565b60208301905092915050565b6000602082019050919050565b600061487382614808565b61487d8185614813565b935061488883614824565b8060005b838110156148b95781516148a08882614843565b97506148ab8361485b565b92505060018101905061488c565b5085935050505092915050565b60006080820190506148db60008301876147f9565b81810360208301526148ed8186614868565b905081810360408301526149018185614868565b9050818103606083015261491581846139ec565b905095945050505050565b600080fd5b600080fd5b60008151905061493981613b0b565b92915050565b60008151905061494e81613658565b92915050565b600067ffffffffffffffff82111561496f5761496e6134e3565b5b602082029050602081019050919050565b600080fd5b60008151905061499481613977565b92915050565b60006149ad6149a884614954565b613543565b905080838252602082019050602084028301858111156149d0576149cf614980565b5b835b818110156149f957806149e58882614985565b8452602084019350506020810190506149d2565b5050509392505050565b600082601f830112614a1857614a176134c8565b5b8151614a2884826020860161499a565b91505092915050565b600060c08284031215614a4757614a46614920565b5b614a5160c0613543565b90506000614a618482850161492a565b6000830152506020614a758482850161492a565b6020830152506040614a898482850161493f565b604083015250606082015167ffffffffffffffff811115614aad57614aac614925565b5b614ab984828501614a03565b606083015250608082015167ffffffffffffffff811115614add57614adc614925565b5b614ae984828501614a03565b60808301525060a082015167ffffffffffffffff811115614b0d57614b0c614925565b5b614b19848285016145eb565b60a08301525092915050565b600060208284031215614b3b57614b3a6134be565b5b600082015167ffffffffffffffff811115614b5957614b586134c3565b5b614b6584828501614a31565b91505092915050565b6000606082019050614b836000830186613a85565b8181036020830152614b9581856139ec565b90508181036040830152614ba9818461386a565b9050949350505050565b6000614bbf8285614050565b9150614bcb8284614050565b91508190509392505050565b60008160601b9050919050565b6000614bef82614bd7565b9050919050565b6000614c0182614be4565b9050919050565b614c19614c1482613965565b614bf6565b82525050565b6000614c2b8284614c08565b60148201915081905092915050565b6000604082019050614c4f6000830185613a85565b8181036020830152614c6181846139ec565b90509392505050565b7f696e76616c6964207369676e6174757265206c656e6774680000000000000000600082015250565b6000614ca06018836139db565b9150614cab82614c6a565b602082019050919050565b60006020820190508181036000830152614ccf81614c93565b9050919050565b6000614ce1826138c5565b9150614cec836138c5565b92508260ff03821115614d0257614d016141e1565b5b828201905092915050565b6000819050919050565b614d28614d238261360e565b614d0d565b82525050565b6000614d3a8284614d17565b60208201915081905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b6000614d838261360e565b9150614d8e8361360e565b925082614d9e57614d9d614d49565b5b828204905092915050565b6000614db48261360e565b9150614dbf8361360e565b9250614dec7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff84846143f9565b905092915050565b6000614dff8261360e565b9150614e0a8361360e565b925082614e1a57614e19614d49565b5b82820690509291505056fe68747470733a2f2f646174612d6170692e62696e616e63652e766973696f6e2f6170692f76332f7469636b65722f70726963653f73796d626f6c3d68747470733a2f2f72656c61792d676f65726c692e666c617368626f74732e6e657468747470733a2f2f676f65726c692e696e667572612e696f2f76332f3961613364393562336263343430666138386561313265616134343536313631a264697066735822122051af2885264fb714c6cf80a4a229b0e9dcfb7dc378be215fd56ade56bd22bc4364736f6c634300080d0033",
  "deployedBytecode": "0x60806040526004361061010d5760003560e01c80639e0f4f4511610095578063d3596e7f11610064578063d3596e7f14610385578063d40ec066146103b0578063e2411625146103d9578063ea42418b14610402578063f77c47911461042d5761010e565b80639e0f4f45146102db578063adb8b6d614610306578063b72a654014610331578063cf1b037c1461035c5761010e565b806350723553116100dc57806350723553146101e057806357e3c1b51461021d57806370c905a51461025a5780637e48532c146102855780639829ba42146102b05761010e565b80630c79e696146101105780631d148b8d1461014d5780632e0f26251461018a5780633eb84396146101b55761010e565b5b005b34801561011c57600080fd5b5061013760048036038101906101329190613684565b610458565b6040516101449190613716565b60405180910390f35b34801561015957600080fd5b50610174600480360381019061016f91906137d2565b6104c6565b60405161018191906138a3565b60405180910390f35b34801561019657600080fd5b5061019f610637565b6040516101ac91906138e1565b60405180910390f35b3480156101c157600080fd5b506101ca61063c565b6040516101d79190613716565b60405180910390f35b3480156101ec57600080fd5b50610207600480360381019061020291906138fc565b610641565b6040516102149190613716565b60405180910390f35b34801561022957600080fd5b50610244600480360381019061023f91906139a3565b6106cd565b60405161025191906138a3565b60405180910390f35b34801561026657600080fd5b5061026f61083b565b60405161027c9190613a25565b60405180910390f35b34801561029157600080fd5b5061029a610857565b6040516102a791906138a3565b60405180910390f35b3480156102bc57600080fd5b506102c5610994565b6040516102d29190613a25565b60405180910390f35b3480156102e757600080fd5b506102f06109cd565b6040516102fd9190613a25565b60405180910390f35b34801561031257600080fd5b5061031b6109e9565b6040516103289190613a25565b60405180910390f35b34801561033d57600080fd5b50610346610a22565b6040516103539190613a25565b60405180910390f35b34801561036857600080fd5b50610383600480360381019061037e91906139a3565b610a3e565b005b34801561039157600080fd5b5061039a610b6b565b6040516103a79190613a94565b60405180910390f35b3480156103bc57600080fd5b506103d760048036038101906103d29190613aaf565b610b7e565b005b3480156103e557600080fd5b5061040060048036038101906103fb9190613b37565b610bbb565b005b34801561040e57600080fd5b50610417610c91565b6040516104249190613b86565b60405180910390f35b34801561043957600080fd5b50610442610cb7565b60405161044f9190613b86565b60405180910390f35b60006104a0610465610cdd565b6040518060400160405280601081526020017f4e6f7420636f6e666964656e7469616c00000000000000000000000000000000815250610da5565b60006104ab86610641565b90506104ba8682878787610deb565b80915050949350505050565b606060006104d383610e0d565b6040516020016104e39190613c9b565b60405160208183030381529060405290506104fc61340a565b6040518060400160405280600481526020017f504f5354000000000000000000000000000000000000000000000000000000008152508160200181905250818160600181905250600167ffffffffffffffff81111561055e5761055d6134e3565b5b60405190808252806020026020018201604052801561059157816020015b606081526020019060019003908161057c5790505b5081604001819052506040518060400160405280601e81526020017f436f6e74656e742d547970653a206170706c69636174696f6e2f6a736f6e000081525081604001516000815181106105e8576105e7613cc8565b5b602002602001018190525060008160800190151590811515815250506040518060600160405280603c8152602001614e83603c9139816000018190525061062e81610e33565b92505050919050565b600481565b600581565b60008061064d83610eec565b9050600061065a82611091565b905060006106ae6106a96040518060400160405280600781526020017f2270726963652200000000000000000000000000000000000000000000000000815250846110bd90919063ffffffff16565b611140565b90506106c36106bc82611162565b600461122f565b9350505050919050565b60606107156106da610cdd565b6040518060400160405280601081526020017f4e6f7420636f6e666964656e7469616c00000000000000000000000000000000815250610da5565b600073ffffffffffffffffffffffffffffffffffffffff16600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16146107a6576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161079d90613d43565b60405180910390fd5b60006107b1836113f6565b90506107bc816104c6565b5063cf1b037c60e01b836040516024016107d69190613b86565b604051602081830303815290604052907bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff8381831617835250505050915050919050565b604051806060016040528060228152602001614e616022913981565b606061089f610864610cdd565b6040518060400160405280601081526020017f4e6f7420636f6e666964656e7469616c00000000000000000000000000000000815250610da5565b6108ec60008054906101000a900460ff16156040518060400160405280601381526020017f416c726561647920696e697469616c697a656400000000000000000000000000815250610da5565b60006108f86000611593565b905060006109058261168a565b90506000610912836116f6565b905063e241162560e01b818360405160240161092f929190613d63565b604051602081830303815290604052907bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff8381831617835250505050935050505090565b6040518060400160405280601281526020017f6f7261636c653a76303a706b736563726574000000000000000000000000000081525081565b6040518060600160405280603c8152602001614e83603c913981565b6040518060400160405280600381526020017f307835000000000000000000000000000000000000000000000000000000000081525081565b6040518060600160405280603b8152602001614e26603b913981565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff161480610ae85750600073ffffffffffffffffffffffffffffffffffffffff16600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16145b610b27576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610b1e90613d43565b60405180910390fd5b80600260006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050565b600060019054906101000a900460801b81565b7ff61f2fd6ab65716facd3516c91d806d98dffa9670f127beac522f8cacfd1d8df8282604051610baf929190613d8c565b60405180910390a15050565b610c0860008054906101000a900460ff16156040518060400160405280601381526020017f416c726561647920696e697469616c697a656400000000000000000000000000815250610da5565b81600060016101000a8154816fffffffffffffffffffffffffffffffff021916908360801c021790555080600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060016000806101000a81548160ff0219169083151502179055505050565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6000806000634201000073ffffffffffffffffffffffffffffffffffffffff16604051610d0990613ded565b600060405180830381855afa9150503d8060008114610d44576040519150601f19603f3d011682016040523d82523d6000602084013e610d49565b606091505b509150915081610d96576342010000816040517f75fff467000000000000000000000000000000000000000000000000000000008152600401610d8d929190613e02565b60405180910390fd5b80516020820151935050505090565b81610de757806040517f0c25cd98000000000000000000000000000000000000000000000000000000008152600401610dde9190613a25565b60405180910390fd5b5050565b6000610df9868686866118d2565b9050610e04816104c6565b50505050505050565b6060610e1882611a9b565b90506002815101613078825260028203915080825250919050565b6060600080634320000273ffffffffffffffffffffffffffffffffffffffff1684604051602001610e64919061402e565b604051602081830303815290604052604051610e809190614081565b600060405180830381855afa9150503d8060008114610ebb576040519150601f19603f3d011682016040523d82523d6000602084013e610ec0565b606091505b5091509150610ecf8282610da5565b80806020019051810190610ee39190614108565b92505050919050565b60606000600167ffffffffffffffff811115610f0b57610f0a6134e3565b5b604051908082528060200260200182016040528015610f3e57816020015b6060815260200190600190039081610f295790505b5090506040518060400160405280601e81526020017f436f6e74656e742d547970653a206170706c69636174696f6e2f6a736f6e000081525081600081518110610f8b57610f8a613cc8565b5b602002602001018190525060006040518060a001604052806040518060600160405280603b8152602001614e26603b913986604051602001610fce929190614151565b60405160208183030381529060405281526020016040518060400160405280600381526020017f47455400000000000000000000000000000000000000000000000000000000008152508152602001838152602001600067ffffffffffffffff81111561103e5761103d6134e3565b5b6040519080825280601f01601f1916602001820160405280156110705781602001600182028036833780820191505090505b50815260200160001515815250905061108881610e33565b92505050919050565b61109961343b565b8060405260006110b26110ab84611b09565b60ff611b13565b905080915050919050565b6110c561343b565b80604052606090506110d6836123d7565b1561113a5760008280519060200120905060006110f2856123ee565b9050600060058251901b90505b60008114611136578082015195506020810390508261111d87612410565b805190602001200361113157859350611136565b6110ff565b5050505b92915050565b6060600061115761115084612442565b6000611b13565b905080915050919050565b6060600082905060028151116111ad576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016111a4906141c1565b60405180910390fd5b6000600282516111bd9190614210565b905060008167ffffffffffffffff8111156111db576111da6134e3565b5b6040519080825280601f01601f19166020018201604052801561120d5781602001600182028036833780820191505090505b5090506021830160208201845182518252848452505050809350505050919050565b600080839050600080600090505b82518110156112ab57602e60f81b83828151811061125e5761125d613cc8565b5b602001015160f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191603611298578091506112ab565b80806112a390614244565b91505061123d565b5060008060006001905060008490505b600081111561133a57816030876001846112d59190614210565b815181106112e6576112e5613cc8565b5b602001015160f81c60f81b60f81c6112fe919061428c565b60ff1661130b91906142c0565b84611316919061431a565b9350600a8261132591906142c0565b9150808061133290614370565b9150506112bb565b506001905060008760ff1685611350919061431a565b90505b848111156113c55781603087838151811061137157611370613cc8565b5b602001015160f81c60f81b60f81c611389919061428c565b60ff1661139691906142c0565b836113a1919061431a565b9250600a826113b091906142c0565b915080806113bd90614370565b915050611353565b508187600a6113d491906144cc565b846113df91906142c0565b6113e9919061431a565b9550505050505092915050565b606060006040518061014001604052808473ffffffffffffffffffffffffffffffffffffffff168152602001620186a0815260200164174876e800815260200160008152602001600081526020016040516024016040516020818303038152906040527f1aa3a008000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff83818316178352505050508152602001600581526020017f111111111111111111111111111111111111111111111111111111111111111181526020017f11111111111111111111111111111111111111111111111111111111111111118152602001601b67ffffffffffffffff168152509050600061153b8261244c565b905060006115476126fd565b9050611589826040518060400160405280600381526020017f307835000000000000000000000000000000000000000000000000000000000081525083612758565b9350505050919050565b6060600080635320000373ffffffffffffffffffffffffffffffffffffffff16846040516020016115c4919061458e565b6040516020818303038152906040526040516115e09190614081565b600060405180830381855afa9150503d806000811461161b576040519150601f19603f3d011682016040523d82523d6000602084013e611620565b606091505b50915091508161166d576353200003816040517f75fff467000000000000000000000000000000000000000000000000000000008152600401611664929190613e02565b60405180910390fd5b808060200190518101906116819190614619565b92505050919050565b60008060405160200161169c906146ae565b60405160208183030381529060405280519060200120905060006116e1826040516020016116ca91906146f9565b604051602081830303815290604052600086612855565b90506116ed8282612963565b92505050919050565b600080600367ffffffffffffffff811115611714576117136134e3565b5b6040519080825280602002602001820160405280156117425781602001602082028036833780820191505090505b509050308160008151811061175a57611759613cc8565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250506342030001816001815181106117ad576117ac613cc8565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff1681525050634202000181600281518110611800576117ff613cc8565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff1681525050600061187e600083846040518060400160405280601281526020017f6f7261636c653a76303a706b73656372657400000000000000000000000000008152506129d2565b90506118c481600001516040518060400160405280601281526020017f6f7261636c653a76303a706b736563726574000000000000000000000000000081525086612ad8565b806000015192505050919050565b60606000604051806101400160405280600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001620186a0815260200184815260200160008152602001858152602001878760405160240161194f929190613d8c565b6040516020818303038152906040527f4a432a46000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff83818316178352505050508152602001600581526020017f111111111111111111111111111111111111111111111111111111111111111181526020017f11111111111111111111111111111111111111111111111111111111111111118152602001601b67ffffffffffffffff1681525090506000611a408261244c565b90506000611a4c6126fd565b9050611a8e826040518060400160405280600381526020017f307835000000000000000000000000000000000000000000000000000000000081525083612758565b9350505050949350505050565b60608151600260405101915080810182526f30313233343536373839616263646566600f52602082018184015b808514611af657600185019450600f855116516001830153600f855160041c16518253600282019150611ac8565b6000825260208201604052505050919050565b6000819050919050565b600061231f565b63101827966000526004601cfd5b6000815160001a9050919050565b60008190505b600115611b66576001640100002600611b5483611b28565b1c1615611b6757600181019050611b3c565b5b92915050565b600063ffffffff84113d3d3e83831b8263ffffffff851b19161790509392505050565b600081831c63ffffffff16905092915050565b60006040519050611bc88486036078611bc3602086018803605888611b6d565b611b6d565b925085831781526020810160405295945050505050565b600080611bf0846018600051611b6d565b611bfa8787611b36565b9150868210611c095750611d5c565b611c1282611b28565b600115611d4d5760228103611c465782611c2e89858589611f9e565b9350611c3e60048583868a611ba3565b945050611d4d565b605b8103611c6357611c5a88848488611d65565b93509350611d4d565b607b8103611c8057611c7788848488611e3d565b93509350611d4d565b6001611ff9602d1b821c1615611ca557611c9c888484886120ad565b93509350611d4d565b876004840111611d085782835160e01c63747275658103611cdd57600485019450611cd460058684878b611ba3565b95505050611d4d565b636e756c6c8103611d0557600485019450611cfc60068684878b611ba3565b95505050611d4d565b50505b876005840111611d445782835160d81c6466616c73658103611d4157600585019450611d3860058684878b611ba3565b95505050611d4d565b50505b611d4c611b1a565b5b50611d588783611b36565b9150505b94509492505050565b60008060006001860191505b600115611e0f57868210611d8857611d87611b1a565b5b82611dab57611d978783611b36565b9150605d611da483611b28565b0315611e0f575b611db787838587611bdf565b925092508215611e0057611dd18160988551604017611b6d565b8352600181019050611de282611b28565b605d8103611df05750611e0f565b602c8103611dfe5750611e04565b505b8691505b600182019150611d71565b600182019150611e2183603887611b6d565b9450611e31600183888888611ba3565b92505094509492505050565b6000806001850190505b600115611f3057858110611e5e57611e5d611b1a565b5b81611e8157611e6d8682611b36565b9050607d611e7a82611b28565b0315611f30575b611e8b8682611b36565b905080611e9a87838587611f9e565b611ea48882611b36565b9250603a611eb184611b28565b03611f1f57611ec588600185018688611bdf565b935093508315611f1e57611ef16020860183036098611eec85850360b88951608017611b6d565b611b6d565b8452611efc83611b28565b607d8103611f0c57505050611f30565b602c8103611f1c57505050611f25565b505b5b87925050505b600181019050611e47565b600181019050611f4282603886611b6d565b9350611f52600282878787611ba3565b915094509492505050565b6001667e0000007e03ff6030611f74858501611b28565b031c16611f8457611f83611b1a565b5b60058214611f9a57611f996001830182611f5d565b5b5050565b6000848410611fb057611faf611b1a565b5b6001840190505b60011561204957611fc781611b28565b60228103611fd55750612049565b605c8114611fe95760018201915050612044565b611ff560018301611b28565b905060016a0510110400000000002001602283031c161561201c5760028201915050612044565b6075810361203b5761202f600283611f5d565b60068201915050612044565b85915050612049565b611fb7565b84811061205957612058611b1a565b5b600181019050949350505050565b60008190505b60011561209357600a603061208183611b28565b0310156120935760018101905061206d565b8082148416156120a6576120a5611b1a565b5b9392505050565b600080849050602d6120be82611b28565b036120ca576001810190505b600a60306120d783611b28565b03106120e6576120e5611b1a565b5b6120ef81611b28565b6001820191506030811461210c5761210960008884612067565b91505b602e61211783611b28565b0361212e5761212b60018860018501612067565b91505b815160658160001a6020170361215d5761215a6001896001860162010001600e8660011a031a01612067565b92505b61216b600384898989611ba3565b9350505094509492505050565b600060405190508282019150601f1980601f8601165b6001156121a857808401518184015281810190508061218e575b50848252600085602084010152846040830101604052509392505050565b6000606090508151600281600716116122b25782158115176122b25760208116156121fd576121f6603882611b90565b91506122b2565b604051915060208201612211603883611b90565b5b8015612246578082528051612228601882611b90565b61223487601884611b6d565b83528092506020840193505050612212565b50601f1983820381018060051c85528260405261226585603886611b6d565b9350836020178652604081106122ae57602085018186015b6001156122ab5781518151835280825284820191506020830192508183106122a557506122ab565b5061227d565b50505b5050505b50919050565b60006060905081518015831517156122d05750612317565b6122da8482611b90565b9150808616612315576122ee60d882611b90565b6123026122fb8784611b90565b8483612178565b925061230f838684611b6d565b87178452505b505b949350505050565b816000811461239857600181146123ae57600381146123c457602084018451810180821461237d5761235081611b28565b602282536123648760d8602260f81b611b6d565b600052612374828460008a611bdf565b93509450808253505b8315818310171561239157612390611b1a565b5b50506123d0565b6123a7601060786058876122b8565b91506123d0565b6123bd600860b86098876122b8565b91506123d0565b6123cd846121c6565b91505b5092915050565b6000600260ff166007836000015116149050919050565b606060006124056123fe84612442565b6003611b13565b905080915050919050565b6060600060808360000151161461243d57600061243661242f84612442565b6001611b13565b9050809150505b919050565b6000819050919050565b60606000600967ffffffffffffffff81111561246b5761246a6134e3565b5b60405190808252806020026020018201604052801561249e57816020015b60608152602001906001900390816124895790505b5090506124ae8360800151612bbb565b816000815181106124c2576124c1613cc8565b5b60200260200101819052506124da8360400151612bbb565b816001815181106124ee576124ed613cc8565b5b60200260200101819052506125068360200151612bbb565b8160028151811061251a57612519613cc8565b5b6020026020010181905250600073ffffffffffffffffffffffffffffffffffffffff16836000015173ffffffffffffffffffffffffffffffffffffffff16036125995761257560405180602001604052806000815250612bd5565b8160038151811061258957612588613cc8565b5b60200260200101819052506125c6565b6125a68360000151612c53565b816003815181106125ba576125b9613cc8565b5b60200260200101819052505b6125d38360600151612bbb565b816004815181106125e7576125e6613cc8565b5b60200260200101819052506125ff8360a00151612bd5565b8160058151811061261357612612613cc8565b5b602002602001018190525061263683610120015167ffffffffffffffff16612bbb565b8160068151811061264a57612649613cc8565b5b60200260200101819052506126818360e0015160405160200161266d91906146f9565b604051602081830303815290604052612bd5565b8160078151811061269557612694613cc8565b5b60200260200101819052506126cd8361010001516040516020016126b991906146f9565b604051602081830303815290604052612bd5565b816008815181106126e1576126e0613cc8565b5b60200260200101819052506126f581612c84565b915050919050565b6060600061274f600060019054906101000a900460801b6040518060400160405280601281526020017f6f7261636c653a76303a706b7365637265740000000000000000000000000000815250612cc8565b90508091505090565b6060600080634010000173ffffffffffffffffffffffffffffffffffffffff1686868660405160200161278d93929190614714565b6040516020818303038152906040526040516127a99190614081565b600060405180830381855afa9150503d80600081146127e4576040519150601f19603f3d011682016040523d82523d6000602084013e6127e9565b606091505b509150915081612836576340100001816040517f75fff46700000000000000000000000000000000000000000000000000000000815260040161282d929190613e02565b60405180910390fd5b8080602001905181019061284a9190614108565b925050509392505050565b606061285f610cdd565b61286857600080fd5b600080634010000373ffffffffffffffffffffffffffffffffffffffff1686868660405160200161289b93929190614760565b6040516020818303038152906040526040516128b79190614081565b600060405180830381855afa9150503d80600081146128f2576040519150601f19603f3d011682016040523d82523d6000602084013e6128f7565b606091505b509150915081612944576340100003816040517f75fff46700000000000000000000000000000000000000000000000000000000815260040161293b929190613e02565b60405180910390fd5b808060200190518101906129589190614108565b925050509392505050565b60008060008061297285612daf565b9250925092506001868285856040516000815260200160405260405161299b94939291906147b4565b6020604051602081039080840390855afa1580156129bd573d6000803e3d6000fd5b50505060206040510351935050505092915050565b6129da61344e565b600080634203000073ffffffffffffffffffffffffffffffffffffffff1687878787604051602001612a0f94939291906148c6565b604051602081830303815290604052604051612a2b9190614081565b600060405180830381855afa9150503d8060008114612a66576040519150601f19603f3d011682016040523d82523d6000602084013e612a6b565b606091505b509150915081612ab8576342030000816040517f75fff467000000000000000000000000000000000000000000000000000000008152600401612aaf929190613e02565b60405180910390fd5b80806020019051810190612acc9190614b25565b92505050949350505050565b600080634202000073ffffffffffffffffffffffffffffffffffffffff16858585604051602001612b0b93929190614b6e565b604051602081830303815290604052604051612b279190614081565b600060405180830381855afa9150503d8060008114612b62576040519150601f19603f3d011682016040523d82523d6000602084013e612b67565b606091505b509150915081612bb4576342020000816040517f75fff467000000000000000000000000000000000000000000000000000000008152600401612bab929190613e02565b60405180910390fd5b5050505050565b6060612bce612bc983612e33565b612bd5565b9050919050565b60608060018351148015612c0d5750608083600081518110612bfa57612bf9613cc8565b5b602001015160f81c60f81b60f81c60ff16105b15612c1a57829050612c4a565b612c2683516080612fb6565b83604051602001612c38929190614bb3565b60405160208183030381529060405290505b80915050919050565b6060612c7d82604051602001612c699190614c1f565b604051602081830303815290604052612bd5565b9050919050565b60606000612c9183613202565b9050612c9f815160c0612fb6565b81604051602001612cb1929190614bb3565b604051602081830303815290604052915050919050565b6060600080634202000173ffffffffffffffffffffffffffffffffffffffff168585604051602001612cfb929190614c3a565b604051602081830303815290604052604051612d179190614081565b600060405180830381855afa9150503d8060008114612d52576040519150601f19603f3d011682016040523d82523d6000602084013e612d57565b606091505b509150915081612da4576342020001816040517f75fff467000000000000000000000000000000000000000000000000000000008152600401612d9b929190613e02565b60405180910390fd5b809250505092915050565b60008060006041845114612df8576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401612def90614cb6565b60405180910390fd5b6020840151925060408401519150606084015160001a9050601b8160ff161015612e2c57601b81612e299190614cd6565b90505b9193909250565b6060600082604051602001612e489190614d2e565b604051602081830303815290604052905060005b6020811015612ec257600060f81b828281518110612e7d57612e7c613cc8565b5b602001015160f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191603612ec2578080612eba90614244565b915050612e5c565b6000816020612ed19190614210565b67ffffffffffffffff811115612eea57612ee96134e3565b5b6040519080825280601f01601f191660200182016040528015612f1c5781602001600182028036833780820191505090505b50905060005b8151811015612faa57838380612f3790614244565b945081518110612f4a57612f49613cc8565b5b602001015160f81c60f81b828281518110612f6857612f67613cc8565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a9053508080612fa290614244565b915050612f22565b50809350505050919050565b606080603884101561306957600167ffffffffffffffff811115612fdd57612fdc6134e3565b5b6040519080825280601f01601f19166020018201604052801561300f5781602001600182028036833780820191505090505b509050828461301e9190614cd6565b60f81b8160008151811061303557613034613cc8565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a9053506131f8565b600080600190505b6000818761307f9190614d78565b146130a757818061308f90614244565b925050610100816130a091906142c0565b9050613071565b6001826130b4919061431a565b67ffffffffffffffff8111156130cd576130cc6134e3565b5b6040519080825280601f01601f1916602001820160405280156130ff5781602001600182028036833780820191505090505b509250603785836131109190614cd6565b61311a9190614cd6565b60f81b8360008151811061313157613130613cc8565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a905350600190505b8181116131f557610100818361317b9190614210565b6101006131889190614da9565b876131939190614d78565b61319d9190614df4565b60f81b8382815181106131b3576131b2613cc8565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a90535080806131ed90614244565b915050613165565b50505b8091505092915050565b6060600082510361326257600067ffffffffffffffff811115613228576132276134e3565b5b6040519080825280601f01601f19166020018201604052801561325a5781602001600182028036833780820191505090505b50905061338f565b600080600090505b83518110156132af5783818151811061328657613285613cc8565b5b6020026020010151518261329a919061431a565b915080806132a790614244565b91505061326a565b60008267ffffffffffffffff8111156132cb576132ca6134e3565b5b6040519080825280601f01601f1916602001820160405280156132fd5781602001600182028036833780820191505090505b5090506000602082019050600092505b855183101561338757600086848151811061332b5761332a613cc8565b5b60200260200101519050600060208201905061334983828451613394565b87858151811061335c5761335b613cc8565b5b60200260200101515183613370919061431a565b92505050828061337f90614244565b93505061330d565b819450505050505b919050565b6000839050600083905060008390505b602081106133e257815183526020836133bd919061431a565b92506020826133cc919061431a565b91506020816133db9190614210565b90506133a4565b60006001826020036101000a0390508019835116818551168181178652505050505050505050565b6040518060a00160405280606081526020016060815260200160608152602001606081526020016000151581525090565b6040518060200160405280600081525090565b6040518060c0016040528060006fffffffffffffffffffffffffffffffff1916815260200160006fffffffffffffffffffffffffffffffff19168152602001600067ffffffffffffffff1681526020016060815260200160608152602001606081525090565b6000604051905090565b600080fd5b600080fd5b600080fd5b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b61351b826134d2565b810181811067ffffffffffffffff8211171561353a576135396134e3565b5b80604052505050565b600061354d6134b4565b90506135598282613512565b919050565b600067ffffffffffffffff821115613579576135786134e3565b5b613582826134d2565b9050602081019050919050565b82818337600083830152505050565b60006135b16135ac8461355e565b613543565b9050828152602081018484840111156135cd576135cc6134cd565b5b6135d884828561358f565b509392505050565b600082601f8301126135f5576135f46134c8565b5b813561360584826020860161359e565b91505092915050565b6000819050919050565b6136218161360e565b811461362c57600080fd5b50565b60008135905061363e81613618565b92915050565b600067ffffffffffffffff82169050919050565b61366181613644565b811461366c57600080fd5b50565b60008135905061367e81613658565b92915050565b6000806000806080858703121561369e5761369d6134be565b5b600085013567ffffffffffffffff8111156136bc576136bb6134c3565b5b6136c8878288016135e0565b94505060206136d98782880161362f565b93505060406136ea8782880161362f565b92505060606136fb8782880161366f565b91505092959194509250565b6137108161360e565b82525050565b600060208201905061372b6000830184613707565b92915050565b600067ffffffffffffffff82111561374c5761374b6134e3565b5b613755826134d2565b9050602081019050919050565b600061377561377084613731565b613543565b905082815260208101848484011115613791576137906134cd565b5b61379c84828561358f565b509392505050565b600082601f8301126137b9576137b86134c8565b5b81356137c9848260208601613762565b91505092915050565b6000602082840312156137e8576137e76134be565b5b600082013567ffffffffffffffff811115613806576138056134c3565b5b613812848285016137a4565b91505092915050565b600081519050919050565b600082825260208201905092915050565b60005b8381101561385557808201518184015260208101905061383a565b83811115613864576000848401525b50505050565b60006138758261381b565b61387f8185613826565b935061388f818560208601613837565b613898816134d2565b840191505092915050565b600060208201905081810360008301526138bd818461386a565b905092915050565b600060ff82169050919050565b6138db816138c5565b82525050565b60006020820190506138f660008301846138d2565b92915050565b600060208284031215613912576139116134be565b5b600082013567ffffffffffffffff8111156139305761392f6134c3565b5b61393c848285016135e0565b91505092915050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b600061397082613945565b9050919050565b61398081613965565b811461398b57600080fd5b50565b60008135905061399d81613977565b92915050565b6000602082840312156139b9576139b86134be565b5b60006139c78482850161398e565b91505092915050565b600081519050919050565b600082825260208201905092915050565b60006139f7826139d0565b613a0181856139db565b9350613a11818560208601613837565b613a1a816134d2565b840191505092915050565b60006020820190508181036000830152613a3f81846139ec565b905092915050565b60007fffffffffffffffffffffffffffffffff0000000000000000000000000000000082169050919050565b6000613a7e82613a47565b9050919050565b613a8e81613a73565b82525050565b6000602082019050613aa96000830184613a85565b92915050565b60008060408385031215613ac657613ac56134be565b5b600083013567ffffffffffffffff811115613ae457613ae36134c3565b5b613af0858286016135e0565b9250506020613b018582860161362f565b9150509250929050565b613b1481613a47565b8114613b1f57600080fd5b50565b600081359050613b3181613b0b565b92915050565b60008060408385031215613b4e57613b4d6134be565b5b6000613b5c85828601613b22565b9250506020613b6d8582860161398e565b9150509250929050565b613b8081613965565b82525050565b6000602082019050613b9b6000830184613b77565b92915050565b600081905092915050565b7f7b226a736f6e727063223a22322e30222c226d6574686f64223a226574685f7360008201527f656e645261775472616e73616374696f6e222c22706172616d73223a5b220000602082015250565b6000613c08603e83613ba1565b9150613c1382613bac565b603e82019050919050565b6000613c29826139d0565b613c338185613ba1565b9350613c43818560208601613837565b80840191505092915050565b7f225d2c226964223a317d00000000000000000000000000000000000000000000600082015250565b6000613c85600a83613ba1565b9150613c9082613c4f565b600a82019050919050565b6000613ca682613bfb565b9150613cb28284613c1e565b9150613cbd82613c78565b915081905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b7f416c726561647920726567697374657265640000000000000000000000000000600082015250565b6000613d2d6012836139db565b9150613d3882613cf7565b602082019050919050565b60006020820190508181036000830152613d5c81613d20565b9050919050565b6000604082019050613d786000830185613a85565b613d856020830184613b77565b9392505050565b60006040820190508181036000830152613da681856139ec565b9050613db56020830184613707565b9392505050565b600081905092915050565b50565b6000613dd7600083613dbc565b9150613de282613dc7565b600082019050919050565b6000613df882613dca565b9150819050919050565b6000604082019050613e176000830185613b77565b8181036020830152613e29818461386a565b90509392505050565b600082825260208201905092915050565b6000613e4e826139d0565b613e588185613e32565b9350613e68818560208601613837565b613e71816134d2565b840191505092915050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b6000613eb48383613e43565b905092915050565b6000602082019050919050565b6000613ed482613e7c565b613ede8185613e87565b935083602082028501613ef085613e98565b8060005b85811015613f2c5784840389528151613f0d8582613ea8565b9450613f1883613ebc565b925060208a01995050600181019050613ef4565b50829750879550505050505092915050565b600082825260208201905092915050565b6000613f5a8261381b565b613f648185613f3e565b9350613f74818560208601613837565b613f7d816134d2565b840191505092915050565b60008115159050919050565b613f9d81613f88565b82525050565b600060a0830160008301518482036000860152613fc08282613e43565b91505060208301518482036020860152613fda8282613e43565b91505060408301518482036040860152613ff48282613ec9565b9150506060830151848203606086015261400e8282613f4f565b91505060808301516140236080860182613f94565b508091505092915050565b600060208201905081810360008301526140488184613fa3565b905092915050565b600061405b8261381b565b6140658185613dbc565b9350614075818560208601613837565b80840191505092915050565b600061408d8284614050565b915081905092915050565b60006140ab6140a684613731565b613543565b9050828152602081018484840111156140c7576140c66134cd565b5b6140d2848285613837565b509392505050565b600082601f8301126140ef576140ee6134c8565b5b81516140ff848260208601614098565b91505092915050565b60006020828403121561411e5761411d6134be565b5b600082015167ffffffffffffffff81111561413c5761413b6134c3565b5b614148848285016140da565b91505092915050565b600061415d8285613c1e565b91506141698284613c1e565b91508190509392505050565b7f496e70757420746f6f2073686f72740000000000000000000000000000000000600082015250565b60006141ab600f836139db565b91506141b682614175565b602082019050919050565b600060208201905081810360008301526141da8161419e565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600061421b8261360e565b91506142268361360e565b925082821015614239576142386141e1565b5b828203905092915050565b600061424f8261360e565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203614281576142806141e1565b5b600182019050919050565b6000614297826138c5565b91506142a2836138c5565b9250828210156142b5576142b46141e1565b5b828203905092915050565b60006142cb8261360e565b91506142d68361360e565b9250817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff048311821515161561430f5761430e6141e1565b5b828202905092915050565b60006143258261360e565b91506143308361360e565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff03821115614365576143646141e1565b5b828201905092915050565b600061437b8261360e565b91506000820361438e5761438d6141e1565b5b600182039050919050565b60008160011c9050919050565b6000808291508390505b60018511156143f0578086048111156143cc576143cb6141e1565b5b60018516156143db5780820291505b80810290506143e985614399565b94506143b0565b94509492505050565b60008261440957600190506144c5565b8161441757600090506144c5565b816001811461442d576002811461443757614466565b60019150506144c5565b60ff841115614449576144486141e1565b5b8360020a9150848211156144605761445f6141e1565b5b506144c5565b5060208310610133831016604e8410600b841016171561449b5782820a905083811115614496576144956141e1565b5b6144c5565b6144a884848460016143a6565b925090508184048111156144bf576144be6141e1565b5b81810290505b9392505050565b60006144d78261360e565b91506144e2836138c5565b925061450f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff84846143f9565b905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b6002811061455757614556614517565b5b50565b600081905061456882614546565b919050565b60006145788261455a565b9050919050565b6145888161456d565b82525050565b60006020820190506145a3600083018461457f565b92915050565b60006145bc6145b78461355e565b613543565b9050828152602081018484840111156145d8576145d76134cd565b5b6145e3848285613837565b509392505050565b600082601f830112614600576145ff6134c8565b5b81516146108482602086016145a9565b91505092915050565b60006020828403121561462f5761462e6134be565b5b600082015167ffffffffffffffff81111561464d5761464c6134c3565b5b614659848285016145eb565b91505092915050565b7f796f000000000000000000000000000000000000000000000000000000000000600082015250565b60006146986002836139db565b91506146a382614662565b602082019050919050565b600060208201905081810360008301526146c78161468b565b9050919050565b6000819050919050565b6000819050919050565b6146f36146ee826146ce565b6146d8565b82525050565b600061470582846146e2565b60208201915081905092915050565b6000606082019050818103600083015261472e818661386a565b9050818103602083015261474281856139ec565b9050818103604083015261475681846139ec565b9050949350505050565b6000606082019050818103600083015261477a818661386a565b9050614789602083018561457f565b818103604083015261479b81846139ec565b9050949350505050565b6147ae816146ce565b82525050565b60006080820190506147c960008301876147a5565b6147d660208301866138d2565b6147e360408301856147a5565b6147f060608301846147a5565b95945050505050565b61480281613644565b82525050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b61483d81613965565b82525050565b600061484f8383614834565b60208301905092915050565b6000602082019050919050565b600061487382614808565b61487d8185614813565b935061488883614824565b8060005b838110156148b95781516148a08882614843565b97506148ab8361485b565b92505060018101905061488c565b5085935050505092915050565b60006080820190506148db60008301876147f9565b81810360208301526148ed8186614868565b905081810360408301526149018185614868565b9050818103606083015261491581846139ec565b905095945050505050565b600080fd5b600080fd5b60008151905061493981613b0b565b92915050565b60008151905061494e81613658565b92915050565b600067ffffffffffffffff82111561496f5761496e6134e3565b5b602082029050602081019050919050565b600080fd5b60008151905061499481613977565b92915050565b60006149ad6149a884614954565b613543565b905080838252602082019050602084028301858111156149d0576149cf614980565b5b835b818110156149f957806149e58882614985565b8452602084019350506020810190506149d2565b5050509392505050565b600082601f830112614a1857614a176134c8565b5b8151614a2884826020860161499a565b91505092915050565b600060c08284031215614a4757614a46614920565b5b614a5160c0613543565b90506000614a618482850161492a565b6000830152506020614a758482850161492a565b6020830152506040614a898482850161493f565b604083015250606082015167ffffffffffffffff811115614aad57614aac614925565b5b614ab984828501614a03565b606083015250608082015167ffffffffffffffff811115614add57614adc614925565b5b614ae984828501614a03565b60808301525060a082015167ffffffffffffffff811115614b0d57614b0c614925565b5b614b19848285016145eb565b60a08301525092915050565b600060208284031215614b3b57614b3a6134be565b5b600082015167ffffffffffffffff811115614b5957614b586134c3565b5b614b6584828501614a31565b91505092915050565b6000606082019050614b836000830186613a85565b8181036020830152614b9581856139ec565b90508181036040830152614ba9818461386a565b9050949350505050565b6000614bbf8285614050565b9150614bcb8284614050565b91508190509392505050565b60008160601b9050919050565b6000614bef82614bd7565b9050919050565b6000614c0182614be4565b9050919050565b614c19614c1482613965565b614bf6565b82525050565b6000614c2b8284614c08565b60148201915081905092915050565b6000604082019050614c4f6000830185613a85565b8181036020830152614c6181846139ec565b90509392505050565b7f696e76616c6964207369676e6174757265206c656e6774680000000000000000600082015250565b6000614ca06018836139db565b9150614cab82614c6a565b602082019050919050565b60006020820190508181036000830152614ccf81614c93565b9050919050565b6000614ce1826138c5565b9150614cec836138c5565b92508260ff03821115614d0257614d016141e1565b5b828201905092915050565b6000819050919050565b614d28614d238261360e565b614d0d565b82525050565b6000614d3a8284614d17565b60208201915081905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b6000614d838261360e565b9150614d8e8361360e565b925082614d9e57614d9d614d49565b5b828204905092915050565b6000614db48261360e565b9150614dbf8361360e565b9250614dec7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff84846143f9565b905092915050565b6000614dff8261360e565b9150614e0a8361360e565b925082614e1a57614e19614d49565b5b82820690509291505056fe68747470733a2f2f646174612d6170692e62696e616e63652e766973696f6e2f6170692f76332f7469636b65722f70726963653f73796d626f6c3d68747470733a2f2f72656c61792d676f65726c692e666c617368626f74732e6e657468747470733a2f2f676f65726c692e696e667572612e696f2f76332f3961613364393562336263343430666138386561313265616134343536313631a264697066735822122051af2885264fb714c6cf80a4a229b0e9dcfb7dc378be215fd56ade56bd22bc4364736f6c634300080d0033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 5384,
        "contract": "contracts/oracle/BinanceOracle.sol:BinanceOracle",
        "label": "isInitialized",
        "offset": 0,
        "slot": "0",
        "type": "t_bool"
      },
      {
        "astId": 5387,
        "contract": "contracts/oracle/BinanceOracle.sol:BinanceOracle",
        "label": "pkBidId",
        "offset": 1,
        "slot": "0",
        "type": "t_userDefinedValueType(DataId)2642"
      },
      {
        "astId": 5389,
        "contract": "contracts/oracle/BinanceOracle.sol:BinanceOracle",
        "label": "controller",
        "offset": 0,
        "slot": "1",
        "type": "t_address"
      },
      {
        "astId": 5391,
        "contract": "contracts/oracle/BinanceOracle.sol:BinanceOracle",
        "label": "settlementContract",
        "offset": 0,
        "slot": "2",
        "type": "t_address"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_userDefinedValueType(DataId)2642": {
        "encoding": "inplace",
        "label": "Suave.DataId",
        "numberOfBytes": "16"
      }
    }
  }
}