{
  "language": "Solidity",
  "sources": {
    "contracts/blockad/lib/SuaveContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Author: Miha Lotric (halo3mic)\n\npragma solidity ^0.8.8;\n\nimport { Suave } from \"../../standard_peekers/bids.sol\";\n\n\nabstract contract SuaveContract {\n\terror SuaveError(string message);\n\terror SuaveErrorWithData(string message, bytes data);\n\n\tmodifier onlyConfidential() {\n\t\tcrequire(Suave.isConfidential(), \"Not confidential\");\n\t\t_;\n\t}\n\n\tfunction simulateBundleSafe(bytes memory bundle, bool doRevert) internal view returns (bool valid, uint64 egp) {\n\t\t(bool success, bytes memory d) = Suave.SIMULATE_BUNDLE.staticcall{ gas: 20_000 }(abi.encode(bundle));\n\t\tcrequire(!doRevert || success, string(d));\n\t\tif (success) {\n\t\t\treturn (true, abi.decode(d, (uint64)));\n\t\t}\n\t}\n\n\tfunction crequire(bool condition, string memory message) internal pure {\n\t\tif (!condition) {\n\t\t\trevert SuaveError(message);\n\t\t}\n\t}\n}\n"
    },
    "contracts/libraries/Bundle.sol": {
      "content": "// Source: https://github.com/flashbots/suave-std/blob/main/src/protocols/Bundle.sol\n\n\n// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.13;\n\nimport \"./Suave.sol\";\nimport \"solady/src/utils/LibString.sol\";\n\n// https://docs.flashbots.net/flashbots-auction/advanced/rpc-endpoint#eth_sendbundle\nlibrary Bundle {\n    struct BundleObj {\n        uint64 blockNumber;\n        uint64 minTimestamp;\n        uint64 maxTimestamp;\n        bytes[] txns;\n    }\n\n    function sendBundle(string memory url, BundleObj memory bundle) internal view returns (bytes memory) {\n        Suave.HttpRequest memory request = encodeBundle(bundle);\n        request.url = url;\n        return Suave.doHTTPRequest(request);\n    }\n\n    function encodeBundle(BundleObj memory args) internal pure returns (Suave.HttpRequest memory) {\n        require(args.txns.length > 0, \"Bundle: no txns\");\n\n        bytes memory params =\n            abi.encodePacked('{\"blockNumber\": \"', LibString.toHexString(args.blockNumber), '\", \"txs\": [');\n        for (uint256 i = 0; i < args.txns.length; i++) {\n            params = abi.encodePacked(params, '\"', LibString.toHexString(args.txns[i]), '\"');\n            if (i < args.txns.length - 1) {\n                params = abi.encodePacked(params, \",\");\n            } else {\n                params = abi.encodePacked(params, \"]\");\n            }\n        }\n        if (args.minTimestamp > 0) {\n            params = abi.encodePacked(params, ', \"minTimestamp\": ', LibString.toString(args.minTimestamp));\n        }\n        if (args.maxTimestamp > 0) {\n            params = abi.encodePacked(params, ', \"maxTimestamp\": ', LibString.toString(args.maxTimestamp));\n        }\n        params = abi.encodePacked(params, ', \"maxTimestamp\": ', LibString.toString(args.maxTimestamp));\n        params = abi.encodePacked(params, \"}\");\n\n        bytes memory body =\n            abi.encodePacked('{\"jsonrpc\":\"2.0\",\"method\":\"eth_sendBundle\",\"params\":[', params, '],\"id\":1}');\n\n        Suave.HttpRequest memory request;\n        request.method = \"POST\";\n        request.body = body;\n        request.headers = new string[](1);\n        request.headers[0] = \"Content-Type: application/json\";\n        request.withFlashbotsSignature = true;\n\n        return request;\n    }\n}"
    },
    "contracts/libraries/RLPWriter.sol": {
      "content": "// Source: https://github.com/flashbots/suave-std/blob/main/src/utils/RLPWriter.sol\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @custom:attribution https://github.com/bakaoh/solidity-rlp-encode\n * @title RLPWriter\n * @author RLPWriter is a library for encoding Solidity types to RLP bytes. Adapted from Bakaoh's\n *         RLPEncode library (https://github.com/bakaoh/solidity-rlp-encode) with minor\n *         modifications to improve legibility.\n */\nlibrary RLPWriter {\n    /**\n     * @notice RLP encodes a byte string.\n     *\n     * @param _in The byte string to encode.\n     *\n     * @return The RLP encoded string in bytes.\n     */\n    function writeBytes(bytes memory _in) internal pure returns (bytes memory) {\n        bytes memory encoded;\n\n        if (_in.length == 1 && uint8(_in[0]) < 128) {\n            encoded = _in;\n        } else {\n            encoded = abi.encodePacked(_writeLength(_in.length, 128), _in);\n        }\n\n        return encoded;\n    }\n\n    /**\n     * @notice RLP encodes a list of RLP encoded byte byte strings.\n     *\n     * @param _in The list of RLP encoded byte strings.\n     *\n     * @return The RLP encoded list of items in bytes.\n     */\n    function writeList(bytes[] memory _in) internal pure returns (bytes memory) {\n        bytes memory list = _flatten(_in);\n        return abi.encodePacked(_writeLength(list.length, 192), list);\n    }\n\n    /**\n     * @notice RLP encodes a string.\n     *\n     * @param _in The string to encode.\n     *\n     * @return The RLP encoded string in bytes.\n     */\n    function writeString(string memory _in) internal pure returns (bytes memory) {\n        return writeBytes(bytes(_in));\n    }\n\n    /**\n     * @notice RLP encodes an address.\n     *\n     * @param _in The address to encode.\n     *\n     * @return The RLP encoded address in bytes.\n     */\n    function writeAddress(address _in) internal pure returns (bytes memory) {\n        return writeBytes(abi.encodePacked(_in));\n    }\n\n    /**\n     * @notice RLP encodes a uint.\n     *\n     * @param _in The uint256 to encode.\n     *\n     * @return The RLP encoded uint256 in bytes.\n     */\n    function writeUint(uint256 _in) internal pure returns (bytes memory) {\n        return writeBytes(_toBinary(_in));\n    }\n\n    /**\n     * @notice RLP encodes a bool.\n     *\n     * @param _in The bool to encode.\n     *\n     * @return The RLP encoded bool in bytes.\n     */\n    function writeBool(bool _in) internal pure returns (bytes memory) {\n        bytes memory encoded = new bytes(1);\n        encoded[0] = (_in ? bytes1(0x01) : bytes1(0x80));\n        return encoded;\n    }\n\n    /**\n     * @notice Encode the first byte and then the `len` in binary form if `length` is more than 55.\n     *\n     * @param _len    The length of the string or the payload.\n     * @param _offset 128 if item is string, 192 if item is list.\n     *\n     * @return RLP encoded bytes.\n     */\n    function _writeLength(uint256 _len, uint256 _offset) private pure returns (bytes memory) {\n        bytes memory encoded;\n\n        if (_len < 56) {\n            encoded = new bytes(1);\n            encoded[0] = bytes1(uint8(_len) + uint8(_offset));\n        } else {\n            uint256 lenLen;\n            uint256 i = 1;\n            while (_len / i != 0) {\n                lenLen++;\n                i *= 256;\n            }\n\n            encoded = new bytes(lenLen + 1);\n            encoded[0] = bytes1(uint8(lenLen) + uint8(_offset) + 55);\n            for (i = 1; i <= lenLen; i++) {\n                encoded[i] = bytes1(uint8((_len / (256 ** (lenLen - i))) % 256));\n            }\n        }\n\n        return encoded;\n    }\n\n    /**\n     * @notice Encode integer in big endian binary form with no leading zeroes.\n     *\n     * @param _x The integer to encode.\n     *\n     * @return RLP encoded bytes.\n     */\n    function _toBinary(uint256 _x) private pure returns (bytes memory) {\n        bytes memory b = abi.encodePacked(_x);\n\n        uint256 i = 0;\n        for (; i < 32; i++) {\n            if (b[i] != 0) {\n                break;\n            }\n        }\n\n        bytes memory res = new bytes(32 - i);\n        for (uint256 j = 0; j < res.length; j++) {\n            res[j] = b[i++];\n        }\n\n        return res;\n    }\n\n    /**\n     * @custom:attribution https://github.com/Arachnid/solidity-stringutils\n     * @notice Copies a piece of memory to another location.\n     *\n     * @param _dest Destination location.\n     * @param _src  Source location.\n     * @param _len  Length of memory to copy.\n     */\n    function _memcpy(uint256 _dest, uint256 _src, uint256 _len) private pure {\n        uint256 dest = _dest;\n        uint256 src = _src;\n        uint256 len = _len;\n\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        uint256 mask;\n        unchecked {\n            mask = 256 ** (32 - len) - 1;\n        }\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n\n    /**\n     * @custom:attribution https://github.com/sammayo/solidity-rlp-encoder\n     * @notice Flattens a list of byte strings into one byte string.\n     *\n     * @param _list List of byte strings to flatten.\n     *\n     * @return The flattened byte string.\n     */\n    function _flatten(bytes[] memory _list) private pure returns (bytes memory) {\n        if (_list.length == 0) {\n            return new bytes(0);\n        }\n\n        uint256 len;\n        uint256 i = 0;\n        for (; i < _list.length; i++) {\n            len += _list[i].length;\n        }\n\n        bytes memory flattened = new bytes(len);\n        uint256 flattenedPtr;\n        assembly {\n            flattenedPtr := add(flattened, 0x20)\n        }\n\n        for (i = 0; i < _list.length; i++) {\n            bytes memory item = _list[i];\n\n            uint256 listPtr;\n            assembly {\n                listPtr := add(item, 0x20)\n            }\n\n            _memcpy(flattenedPtr, listPtr, item.length);\n            flattenedPtr += _list[i].length;\n        }\n\n        return flattened;\n    }\n}"
    },
    "contracts/libraries/Suave.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.8;\n\nlibrary Suave {\n    error PeekerReverted(address, bytes);\n\n    enum CryptoSignature {\n        SECP256,\n        BLS\n    }\n\n    type DataId is bytes16;\n\n    struct BuildBlockArgs {\n        uint64 slot;\n        bytes proposerPubkey;\n        bytes32 parent;\n        uint64 timestamp;\n        address feeRecipient;\n        uint64 gasLimit;\n        bytes32 random;\n        Withdrawal[] withdrawals;\n        bytes extra;\n        bytes32 parentBeaconBlockRoot;\n        bool fillPending;\n    }\n\n    struct DataRecord {\n        DataId id;\n        DataId salt;\n        uint64 decryptionCondition;\n        address[] allowedPeekers;\n        address[] allowedStores;\n        string version;\n    }\n\n    struct HttpRequest {\n        string url;\n        string method;\n        string[] headers;\n        bytes body;\n        bool withFlashbotsSignature;\n    }\n\n    struct SimulateTransactionResult {\n        uint64 egp;\n        SimulatedLog[] logs;\n        bool success;\n        string error;\n    }\n\n    struct SimulatedLog {\n        bytes data;\n        address addr;\n        bytes32[] topics;\n    }\n\n    struct Withdrawal {\n        uint64 index;\n        uint64 validator;\n        address Address;\n        uint64 amount;\n    }\n\n    address public constant ANYALLOWED = 0xC8df3686b4Afb2BB53e60EAe97EF043FE03Fb829;\n\n    address public constant IS_CONFIDENTIAL_ADDR = 0x0000000000000000000000000000000042010000;\n\n    address public constant BUILD_ETH_BLOCK = 0x0000000000000000000000000000000042100001;\n\n    address public constant CONFIDENTIAL_INPUTS = 0x0000000000000000000000000000000042010001;\n\n    address public constant CONFIDENTIAL_RETRIEVE = 0x0000000000000000000000000000000042020001;\n\n    address public constant CONFIDENTIAL_STORE = 0x0000000000000000000000000000000042020000;\n\n    address public constant DO_HTTPREQUEST = 0x0000000000000000000000000000000043200002;\n\n    address public constant ETHstaticcall = 0x0000000000000000000000000000000042100003;\n\n    address public constant EXTRACT_HINT = 0x0000000000000000000000000000000042100037;\n\n    address public constant FETCH_DATA_RECORDS = 0x0000000000000000000000000000000042030001;\n\n    address public constant FILL_MEV_SHARE_BUNDLE = 0x0000000000000000000000000000000043200001;\n\n    address public constant NEW_BUILDER = 0x0000000000000000000000000000000053200001;\n\n    address public constant NEW_DATA_RECORD = 0x0000000000000000000000000000000042030000;\n\n    address public constant PRIVATE_KEY_GEN = 0x0000000000000000000000000000000053200003;\n\n    address public constant SIGN_ETH_TRANSACTION = 0x0000000000000000000000000000000040100001;\n\n    address public constant SIGN_MESSAGE = 0x0000000000000000000000000000000040100003;\n\n    address public constant SIMULATE_BUNDLE = 0x0000000000000000000000000000000042100000;\n\n    address public constant SIMULATE_TRANSACTION = 0x0000000000000000000000000000000053200002;\n\n    address public constant SUBMIT_BUNDLE_JSON_RPC = 0x0000000000000000000000000000000043000001;\n\n    address public constant SUBMIT_ETH_BLOCK_TO_RELAY = 0x0000000000000000000000000000000042100002;\n\n    // Returns whether execution is off- or on-chain\n    function isConfidential() internal view returns (bool b) {\n        (bool success, bytes memory isConfidentialBytes) = IS_CONFIDENTIAL_ADDR.staticcall(\"\");\n        if (!success) {\n            revert PeekerReverted(IS_CONFIDENTIAL_ADDR, isConfidentialBytes);\n        }\n        assembly {\n            // Load the length of data (first 32 bytes)\n            let len := mload(isConfidentialBytes)\n            // Load the data after 32 bytes, so add 0x20\n            b := mload(add(isConfidentialBytes, 0x20))\n        }\n    }\n\n    function buildEthBlock(BuildBlockArgs memory blockArgs, DataId dataId, string memory namespace)\n        internal\n        view\n        returns (bytes memory, bytes memory)\n    {\n        (bool success, bytes memory data) = BUILD_ETH_BLOCK.staticcall(abi.encode(blockArgs, dataId, namespace));\n        if (!success) {\n            revert PeekerReverted(BUILD_ETH_BLOCK, data);\n        }\n\n        return abi.decode(data, (bytes, bytes));\n    }\n\n    function confidentialInputs() internal view returns (bytes memory) {\n        (bool success, bytes memory data) = CONFIDENTIAL_INPUTS.staticcall(abi.encode());\n        if (!success) {\n            revert PeekerReverted(CONFIDENTIAL_INPUTS, data);\n        }\n\n        return data;\n    }\n\n    function confidentialRetrieve(DataId dataId, string memory key) internal view returns (bytes memory) {\n        (bool success, bytes memory data) = CONFIDENTIAL_RETRIEVE.staticcall(abi.encode(dataId, key));\n        if (!success) {\n            revert PeekerReverted(CONFIDENTIAL_RETRIEVE, data);\n        }\n\n        return data;\n    }\n\n    function confidentialStore(DataId dataId, string memory key, bytes memory value) internal view {\n        (bool success, bytes memory data) = CONFIDENTIAL_STORE.staticcall(abi.encode(dataId, key, value));\n        if (!success) {\n            revert PeekerReverted(CONFIDENTIAL_STORE, data);\n        }\n    }\n\n    function doHTTPRequest(HttpRequest memory request) internal view returns (bytes memory) {\n        (bool success, bytes memory data) = DO_HTTPREQUEST.staticcall(abi.encode(request));\n        if (!success) {\n            revert PeekerReverted(DO_HTTPREQUEST, data);\n        }\n\n        return abi.decode(data, (bytes));\n    }\n\n    function ethstaticcall(address contractAddr, bytes memory input1) internal view returns (bytes memory) {\n        (bool success, bytes memory data) = ETHstaticcall.staticcall(abi.encode(contractAddr, input1));\n        if (!success) {\n            revert PeekerReverted(ETHstaticcall, data);\n        }\n\n        return abi.decode(data, (bytes));\n    }\n\n    function extractHint(bytes memory bundleData) internal view returns (bytes memory) {\n        require(isConfidential());\n        (bool success, bytes memory data) = EXTRACT_HINT.staticcall(abi.encode(bundleData));\n        if (!success) {\n            revert PeekerReverted(EXTRACT_HINT, data);\n        }\n\n        return data;\n    }\n\n    function fetchDataRecords(uint64 cond, string memory namespace) internal view returns (DataRecord[] memory) {\n        (bool success, bytes memory data) = FETCH_DATA_RECORDS.staticcall(abi.encode(cond, namespace));\n        if (!success) {\n            revert PeekerReverted(FETCH_DATA_RECORDS, data);\n        }\n\n        return abi.decode(data, (DataRecord[]));\n    }\n\n    function fillMevShareBundle(DataId dataId) internal view returns (bytes memory) {\n        require(isConfidential());\n        (bool success, bytes memory data) = FILL_MEV_SHARE_BUNDLE.staticcall(abi.encode(dataId));\n        if (!success) {\n            revert PeekerReverted(FILL_MEV_SHARE_BUNDLE, data);\n        }\n\n        return data;\n    }\n\n    function newBuilder() internal view returns (string memory) {\n        (bool success, bytes memory data) = NEW_BUILDER.staticcall(abi.encode());\n        if (!success) {\n            revert PeekerReverted(NEW_BUILDER, data);\n        }\n\n        return abi.decode(data, (string));\n    }\n\n    function newDataRecord(\n        uint64 decryptionCondition,\n        address[] memory allowedPeekers,\n        address[] memory allowedStores,\n        string memory dataType\n    ) internal view returns (DataRecord memory) {\n        (bool success, bytes memory data) =\n            NEW_DATA_RECORD.staticcall(abi.encode(decryptionCondition, allowedPeekers, allowedStores, dataType));\n        if (!success) {\n            revert PeekerReverted(NEW_DATA_RECORD, data);\n        }\n\n        return abi.decode(data, (DataRecord));\n    }\n\n    function privateKeyGen(CryptoSignature crypto) internal view returns (string memory) {\n        (bool success, bytes memory data) = PRIVATE_KEY_GEN.staticcall(abi.encode(crypto));\n        if (!success) {\n            revert PeekerReverted(PRIVATE_KEY_GEN, data);\n        }\n\n        return abi.decode(data, (string));\n    }\n\n    function signEthTransaction(bytes memory txn, string memory chainId, string memory signingKey)\n        internal\n        view\n        returns (bytes memory)\n    {\n        (bool success, bytes memory data) = SIGN_ETH_TRANSACTION.staticcall(abi.encode(txn, chainId, signingKey));\n        if (!success) {\n            revert PeekerReverted(SIGN_ETH_TRANSACTION, data);\n        }\n\n        return abi.decode(data, (bytes));\n    }\n\n    function signMessage(bytes memory digest, CryptoSignature crypto, string memory signingKey)\n        internal\n        view\n        returns (bytes memory)\n    {\n        require(isConfidential());\n        (bool success, bytes memory data) = SIGN_MESSAGE.staticcall(abi.encode(digest, crypto, signingKey));\n        if (!success) {\n            revert PeekerReverted(SIGN_MESSAGE, data);\n        }\n\n        return abi.decode(data, (bytes));\n    }\n\n    function simulateBundle(bytes memory bundleData) internal view returns (uint64) {\n        (bool success, bytes memory data) = SIMULATE_BUNDLE.staticcall(abi.encode(bundleData));\n        if (!success) {\n            revert PeekerReverted(SIMULATE_BUNDLE, data);\n        }\n\n        return abi.decode(data, (uint64));\n    }\n\n    function simulateTransaction(string memory sessionid, bytes memory txn)\n        internal\n        view\n        returns (SimulateTransactionResult memory)\n    {\n        (bool success, bytes memory data) = SIMULATE_TRANSACTION.staticcall(abi.encode(sessionid, txn));\n        if (!success) {\n            revert PeekerReverted(SIMULATE_TRANSACTION, data);\n        }\n\n        return abi.decode(data, (SimulateTransactionResult));\n    }\n\n    function submitBundleJsonRPC(string memory url, string memory method, bytes memory params)\n        internal\n        view\n        returns (bytes memory)\n    {\n        require(isConfidential());\n        (bool success, bytes memory data) = SUBMIT_BUNDLE_JSON_RPC.staticcall(abi.encode(url, method, params));\n        if (!success) {\n            revert PeekerReverted(SUBMIT_BUNDLE_JSON_RPC, data);\n        }\n\n        return data;\n    }\n\n    function submitEthBlockToRelay(string memory relayUrl, bytes memory builderBid) internal view returns (bytes memory) {\n        require(isConfidential());\n        (bool success, bytes memory data) = SUBMIT_ETH_BLOCK_TO_RELAY.staticcall(abi.encode(relayUrl, builderBid));\n        if (!success) {\n            revert PeekerReverted(SUBMIT_ETH_BLOCK_TO_RELAY, data);\n        }\n\n        return data;\n    }\n}\n"
    },
    "contracts/libraries/Transactions.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.13;\n\nimport \"./RLPWriter.sol\";\nimport \"./Suave.sol\";\nimport \"solidity-rlp/contracts/RLPReader.sol\";\n\nlibrary Transactions {\n    using RLPReader for RLPReader.RLPItem;\n    using RLPReader for RLPReader.Iterator;\n    using RLPReader for bytes;\n\n    struct EIP155 {\n        address to;\n        uint256 gas;\n        uint256 gasPrice;\n        uint256 value;\n        uint256 nonce;\n        bytes data;\n        uint256 chainId;\n        bytes32 r;\n        bytes32 s;\n        uint64 v;\n    }\n\n    struct EIP155Request {\n        address to;\n        uint256 gas;\n        uint256 gasPrice;\n        uint256 value;\n        uint256 nonce;\n        bytes data;\n        uint256 chainId;\n    }\n\n    struct EIP1559 {\n        address to;\n        uint64 gas;\n        uint64 maxFeePerGas;\n        uint64 maxPriorityFeePerGas;\n        uint64 value;\n        uint64 nonce;\n        bytes data;\n        uint64 chainId;\n        bytes accessList;\n        bytes32 r;\n        bytes32 s;\n        uint64 v;\n    }\n\n    struct EIP1559Request {\n        address to;\n        uint64 gas;\n        uint64 maxFeePerGas;\n        uint64 maxPriorityFeePerGas;\n        uint64 value;\n        uint64 nonce;\n        bytes data;\n        uint64 chainId;\n        bytes accessList;\n    }\n\n    function encodeRLP(EIP155 memory txStruct) internal pure returns (bytes memory) {\n        bytes[] memory items = new bytes[](9);\n\n        items[0] = RLPWriter.writeUint(txStruct.nonce);\n        items[1] = RLPWriter.writeUint(txStruct.gasPrice);\n        items[2] = RLPWriter.writeUint(txStruct.gas);\n\n        if (txStruct.to == address(0)) {\n            items[3] = RLPWriter.writeBytes(bytes(\"\"));\n        } else {\n            items[3] = RLPWriter.writeAddress(txStruct.to);\n        }\n        items[4] = RLPWriter.writeUint(txStruct.value);\n        items[5] = RLPWriter.writeBytes(txStruct.data);\n        items[6] = RLPWriter.writeUint(uint256(txStruct.v));\n        items[7] = RLPWriter.writeBytes(abi.encodePacked(txStruct.r));\n        items[8] = RLPWriter.writeBytes(abi.encodePacked(txStruct.s));\n\n        return RLPWriter.writeList(items);\n    }\n\n    function encodeRLP(EIP155Request memory txStruct) internal pure returns (bytes memory) {\n        bytes[] memory items = new bytes[](9);\n\n        items[0] = RLPWriter.writeUint(txStruct.nonce);\n        items[1] = RLPWriter.writeUint(txStruct.gasPrice);\n        items[2] = RLPWriter.writeUint(txStruct.gas);\n\n        if (txStruct.to == address(0)) {\n            items[3] = RLPWriter.writeBytes(bytes(\"\"));\n        } else {\n            items[3] = RLPWriter.writeAddress(txStruct.to);\n        }\n        items[4] = RLPWriter.writeUint(txStruct.value);\n        items[5] = RLPWriter.writeBytes(txStruct.data);\n        items[6] = RLPWriter.writeUint(txStruct.chainId);\n        items[7] = RLPWriter.writeBytes(\"\");\n        items[8] = RLPWriter.writeBytes(\"\");\n\n        return RLPWriter.writeList(items);\n    }\n\n    function encodeRLP(EIP1559 memory txStruct) internal pure returns (bytes memory) {\n        bytes[] memory items = new bytes[](12);\n\n        items[0] = RLPWriter.writeUint(txStruct.chainId);\n        items[1] = RLPWriter.writeUint(txStruct.nonce);\n        items[2] = RLPWriter.writeUint(txStruct.maxPriorityFeePerGas);\n        items[3] = RLPWriter.writeUint(txStruct.maxFeePerGas);\n        items[4] = RLPWriter.writeUint(txStruct.gas);\n\n        if (txStruct.to == address(0)) {\n            items[5] = RLPWriter.writeBytes(bytes(\"\"));\n        } else {\n            items[5] = RLPWriter.writeAddress(txStruct.to);\n        }\n\n        items[6] = RLPWriter.writeUint(txStruct.value);\n        items[7] = RLPWriter.writeBytes(txStruct.data);\n\n        if (txStruct.accessList.length == 0) {\n            items[8] = hex\"c0\"; // Empty list encoding\n        } else {\n            items[8] = RLPWriter.writeBytes(txStruct.accessList);\n        }\n\n        items[9] = RLPWriter.writeUint(uint256(txStruct.v));\n        items[10] = RLPWriter.writeBytes(abi.encodePacked(txStruct.r));\n        items[11] = RLPWriter.writeBytes(abi.encodePacked(txStruct.s));\n\n        bytes memory rlpTxn = RLPWriter.writeList(items);\n\n        bytes memory txn = new bytes(1 + rlpTxn.length);\n        txn[0] = 0x02;\n\n        for (uint256 i = 0; i < rlpTxn.length; ++i) {\n            txn[i + 1] = rlpTxn[i];\n        }\n\n        return txn;\n    }\n\n    function encodeRLP(EIP1559Request memory txStruct) internal pure returns (bytes memory) {\n        bytes[] memory items = new bytes[](9);\n\n        items[0] = RLPWriter.writeUint(txStruct.chainId);\n        items[1] = RLPWriter.writeUint(txStruct.nonce);\n        items[2] = RLPWriter.writeUint(txStruct.maxPriorityFeePerGas);\n        items[3] = RLPWriter.writeUint(txStruct.maxFeePerGas);\n        items[4] = RLPWriter.writeUint(txStruct.gas);\n\n        if (txStruct.to == address(0)) {\n            items[5] = RLPWriter.writeBytes(bytes(\"\"));\n        } else {\n            items[5] = RLPWriter.writeAddress(txStruct.to);\n        }\n\n        items[6] = RLPWriter.writeUint(txStruct.value);\n        items[7] = RLPWriter.writeBytes(txStruct.data);\n\n        if (txStruct.accessList.length == 0) {\n            items[8] = hex\"c0\"; // Empty list encoding\n        } else {\n            items[8] = RLPWriter.writeBytes(txStruct.accessList);\n        }\n\n        bytes memory rlpTxn = RLPWriter.writeList(items);\n\n        bytes memory txn = new bytes(1 + rlpTxn.length);\n        txn[0] = 0x02;\n\n        for (uint256 i = 0; i < rlpTxn.length; ++i) {\n            txn[i + 1] = rlpTxn[i];\n        }\n\n        return txn;\n    }\n\n    function decodeRLP_EIP155(bytes memory rlp) internal pure returns (EIP155 memory) {\n        EIP155 memory txStruct;\n\n        RLPReader.RLPItem[] memory ls = rlp.toRlpItem().toList();\n        require(ls.length == 9, \"invalid transaction\");\n\n        txStruct.nonce = uint64(ls[0].toUint());\n        txStruct.gasPrice = uint64(ls[1].toUint());\n        txStruct.gas = uint64(ls[2].toUint());\n\n        if (ls[3].toRlpBytes().length == 1) {\n            txStruct.to = address(0);\n        } else {\n            txStruct.to = ls[3].toAddress();\n        }\n\n        txStruct.value = uint64(ls[4].toUint());\n        txStruct.data = ls[5].toBytes();\n        txStruct.v = uint64(ls[6].toUint());\n        txStruct.r = bytesToBytes32(ls[7].toBytes());\n        txStruct.s = bytesToBytes32(ls[8].toBytes());\n\n        return txStruct;\n    }\n\n    function decodeRLP_EIP155Request(bytes memory rlp) internal pure returns (EIP155Request memory) {\n        EIP155Request memory txStruct;\n\n        RLPReader.RLPItem[] memory ls = rlp.toRlpItem().toList();\n        require(ls.length == 9, \"invalid transaction\");\n\n        txStruct.nonce = ls[0].toUint();\n        txStruct.gasPrice = ls[1].toUint();\n        txStruct.gas = ls[2].toUint();\n\n        if (ls[3].toRlpBytes().length == 1) {\n            txStruct.to = address(0);\n        } else {\n            txStruct.to = ls[3].toAddress();\n        }\n\n        txStruct.value = ls[4].toUint();\n        txStruct.data = ls[5].toBytes();\n        txStruct.chainId = uint64(ls[6].toUint());\n\n        return txStruct;\n    }\n\n    function decodeRLP_EIP1559(bytes memory rlp) internal pure returns (EIP1559 memory) {\n        EIP1559 memory txStruct;\n\n        bytes memory rlpWithoutPrefix = new bytes(rlp.length - 1);\n\n        for (uint256 i = 0; i < rlp.length - 1; ++i) {\n            rlpWithoutPrefix[i] = rlp[i + 1];\n        }\n\n        RLPReader.RLPItem[] memory ls = rlpWithoutPrefix.toRlpItem().toList();\n        require(ls.length == 12, \"invalid transaction\");\n\n        txStruct.chainId = uint64(ls[0].toUint());\n        txStruct.nonce = uint64(ls[1].toUint());\n        txStruct.maxPriorityFeePerGas = uint64(ls[2].toUint());\n        txStruct.maxFeePerGas = uint64(ls[3].toUint());\n        txStruct.gas = uint64(ls[4].toUint());\n\n        if (ls[5].toRlpBytes().length == 1) {\n            txStruct.to = address(0);\n        } else {\n            txStruct.to = ls[5].toAddress();\n        }\n\n        txStruct.value = uint64(ls[6].toUint());\n        txStruct.data = ls[7].toBytes();\n        txStruct.accessList = ls[8].toBytes();\n        txStruct.v = uint64(ls[9].toUint());\n        txStruct.r = bytesToBytes32(ls[10].toBytes());\n        txStruct.s = bytesToBytes32(ls[11].toBytes());\n\n        return txStruct;\n    }\n\n    function decodeRLP_EIP1559Request(bytes memory rlp) internal pure returns (EIP1559Request memory) {\n        EIP1559Request memory txStruct;\n\n        bytes memory rlpWithoutPrefix = new bytes(rlp.length - 1);\n\n        for (uint256 i = 0; i < rlp.length - 1; ++i) {\n            rlpWithoutPrefix[i] = rlp[i + 1];\n        }\n\n        RLPReader.RLPItem[] memory ls = rlpWithoutPrefix.toRlpItem().toList();\n        require(ls.length == 8, \"invalid transaction\");\n\n        txStruct.chainId = uint64(ls[0].toUint());\n        txStruct.nonce = uint64(ls[1].toUint());\n        txStruct.maxPriorityFeePerGas = uint64(ls[2].toUint());\n        txStruct.maxFeePerGas = uint64(ls[3].toUint());\n        txStruct.gas = uint64(ls[4].toUint());\n\n        if (ls[5].toRlpBytes().length == 1) {\n            txStruct.to = address(0);\n        } else {\n            txStruct.to = ls[5].toAddress();\n        }\n\n        txStruct.value = uint64(ls[6].toUint());\n        txStruct.data = ls[7].toBytes();\n\n        return txStruct;\n    }\n\n    function bytesToBytes32(bytes memory inBytes) internal pure returns (bytes32 out) {\n        require(inBytes.length == 32, \"bytesToBytes32: invalid input length\");\n        assembly {\n            out := mload(add(inBytes, 32))\n        }\n    }\n\n    function signTxn(Transactions.EIP1559Request memory request, string memory signingKey)\n        internal\n        view\n        returns (Transactions.EIP1559 memory response)\n    {\n        bytes memory rlp = Transactions.encodeRLP(request);\n        bytes memory hash = abi.encodePacked(keccak256(rlp));\n        bytes memory signature = Suave.signMessage(hash, Suave.CryptoSignature.SECP256, signingKey);\n        (uint8 v, bytes32 r, bytes32 s) = decodeSignature(signature);\n\n        response.to = request.to;\n        response.gas = request.gas;\n        response.maxFeePerGas = request.maxFeePerGas;\n        response.maxPriorityFeePerGas = request.maxPriorityFeePerGas;\n        response.value = request.value;\n        response.nonce = request.nonce;\n        response.data = request.data;\n        response.chainId = request.chainId;\n        response.accessList = request.accessList;\n        response.v = v;\n        response.r = r;\n        response.s = s;\n\n        return response;\n    }\n\n    function signTxn(Transactions.EIP155Request memory request, string memory signingKey)\n        internal\n        view\n        returns (Transactions.EIP155 memory response)\n    {\n        bytes memory rlp = Transactions.encodeRLP(request);\n        bytes memory hash = abi.encodePacked(keccak256(rlp));\n        bytes memory signature = Suave.signMessage(hash, Suave.CryptoSignature.SECP256, signingKey);\n\n        // TODO: check overflow\n        uint64 chainIdMul = uint64(request.chainId) * 2;\n        (uint8 v, bytes32 r, bytes32 s) = decodeSignature(signature);\n\n        uint64 v64 = uint64(v) + 35;\n        v64 += chainIdMul;\n\n        response.to = request.to;\n        response.gas = request.gas;\n        response.gasPrice = request.gasPrice;\n        response.value = request.value;\n        response.nonce = request.nonce;\n        response.data = request.data;\n        response.chainId = request.chainId;\n        response.v = v64;\n        response.r = r;\n        response.s = s;\n\n        return response;\n    }\n\n    function decodeSignature(bytes memory signature) public pure returns (uint8 v, bytes32 r, bytes32 s) {\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n    }\n}"
    },
    "contracts/oracle/BinanceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Author: Miha Lotric (halo3mic)\n\npragma solidity ^0.8.13;\n\nimport { AnyBundleContract, Suave } from \"../standard_peekers/bids.sol\";\nimport { SuaveContract } from \"../blockad/lib/SuaveContract.sol\";\nimport \"solady/src/utils/JSONParserLib.sol\";\nimport \"solady/src/utils/LibString.sol\";\nimport \"../libraries/Transactions.sol\";\nimport \"../libraries/Bundle.sol\";\n\n\ncontract BinanceOracle is SuaveContract {\n    using JSONParserLib for *;\n\n    uint public constant HOLESKY_CHAINID = 17000;\n    string public constant HOLESKY_CHAINID_STR = \"0x4268\";\n    uint8 public constant DECIMALS = 4;\n    string public constant S_NAMESPACE = \"oracle:v0:pksecret\";\n    string public constant REMOTE_HOLESKY_RPC = \"https://ethereum-holesky-rpc.publicnode.com\";\n    string public constant URL_PARTIAL = \"https://data-api.binance.vision/api/v3/ticker/price?symbol=\";\n    string public constant HOLESKY_BUNDLE_ENDPOINT = \"https://relay-holesky.flashbots.net\";\n    \n    bool public isInitialized;\n    Suave.DataId public pkBidId;\n    address public controller;\n    address public settlementContract;\n\n    event PriceSubmission(string ticker, uint price);\n\n    // â›“ï¸ EVM Methods\n\n    function confidentialConstructorCallback(\n        Suave.DataId _pkBidId, \n        address pkAddress\n    ) public {\n        crequire(!isInitialized, \"Already initialized\");\n        pkBidId = _pkBidId;\n        controller = pkAddress;\n        isInitialized = true;\n    }\n\n    function registerCallback(address _settlementContract) public {\n        require(settlementContract == address(0), \"Already registered\");\n        settlementContract = _settlementContract;\n    }\n\n    // ! Warning: This method is not restricted and emitted events should not be relied upon\n    function queryAndSubmitCallback(string memory ticker, uint price) public {\n        emit PriceSubmission(ticker, price);\n    }\n\n    fallback() external payable {\n        // Needed to accept MEVM calls with no callbacks\n    }\n\n    // ðŸ¤ MEVM Methods\n\n    function confidentialConstructor() external view onlyConfidential returns (bytes memory) {\n        crequire(!isInitialized, \"Already initialized\");\n\n        string memory pk = Suave.privateKeyGen(Suave.CryptoSignature.SECP256);\n        address pkAddress = getAddressForPk(pk);\n\t\tSuave.DataId bidId = storePK(bytes(pk));\n\n        return abi.encodeWithSelector(\n            this.confidentialConstructorCallback.selector, \n            bidId, \n            pkAddress\n        );\n    }\n\n    function registerSettlementContract(\n        address _settlementContract\n    ) external view onlyConfidential() returns (bytes memory) {\n        // Allow multiple registrations for the same address (consider the intial tx is not commited to the chain)\n        require(_settlementContract == settlementContract || settlementContract == address(0), \"Already registered\");\n        bytes memory signedTx = createRegisterTx(_settlementContract);\n        sendRawTx(signedTx);\n        return abi.encodeWithSelector(this.registerCallback.selector, _settlementContract);\n    }\n\n    function queryAndSubmit(\n        string memory ticker,\n        uint nonce,\n        uint gasPrice,\n        uint64 settlementBlockNum,\n        bool privateSubmission\n    ) external view onlyConfidential returns (bytes memory) {\n        uint price = queryLatestPrice(ticker);\n        submitPriceUpdate(ticker, price, nonce, gasPrice, settlementBlockNum, privateSubmission);\n        return abi.encodeWithSelector(this.queryAndSubmitCallback.selector, ticker, price);\n    }\n\n    function queryLatestPrice(string memory ticker) public view returns (uint price) {\n        bytes memory response = doBinanceQuery(ticker);\n        JSONParserLib.Item memory parsedRes = string(response).parse();\n        // solhint-disable-next-line\n        string memory priceStr = string(parsedRes.at('\"price\"').value());\n        price = floatToInt(trimStrEdges(priceStr), DECIMALS);\n    }\n\n    function submitPriceUpdate(\n        string memory ticker,\n        uint price, \n        uint nonce,\n        uint gasPrice,\n        uint64 settlementBlockNum,\n        bool privateSubmission\n    ) internal view {\n        bytes memory signedTx = createPriceUpdateTx(ticker, price, nonce, gasPrice);\n        if (privateSubmission) {\n            sendBundle(signedTx, settlementBlockNum);\n        } else {\n            sendRawTx(signedTx);\n        }\n    }\n\n    function createRegisterTx(address _settlementContract) internal view returns (bytes memory txSigned) {\n        Transactions.EIP155 memory transaction = Transactions.EIP155({\n            nonce: 0,\n            gasPrice: 100 gwei,\n            gas: 100_000,\n            to: _settlementContract,\n            value: 0,\n            data: abi.encodeWithSignature(\"register()\"),\n            chainId: HOLESKY_CHAINID,\n            v: 27,\n            r: hex\"1111111111111111111111111111111111111111111111111111111111111111\",\n            s: hex\"1111111111111111111111111111111111111111111111111111111111111111\"\n        });\n        bytes memory txRlp = Transactions.encodeRLP(transaction);\n        string memory pk = retreivePK();\n        txSigned = Suave.signEthTransaction(txRlp, HOLESKY_CHAINID_STR, pk);\n    }\n\n    function createPriceUpdateTx(\n        string memory ticker, \n        uint price, \n        uint nonce, \n        uint gasPrice\n    ) internal view returns (bytes memory txSigned)  {\n        Transactions.EIP155 memory transaction = Transactions.EIP155({\n            nonce: nonce,\n            gasPrice: gasPrice,\n            gas: 100_000,\n            to: settlementContract,\n            value: 0,\n            data: abi.encodeWithSignature(\"updatePrice(string,uint256)\", ticker, price),\n            chainId: HOLESKY_CHAINID,\n            v: 27,\n            r: hex\"1111111111111111111111111111111111111111111111111111111111111111\",\n            s: hex\"1111111111111111111111111111111111111111111111111111111111111111\"\n        });\n        bytes memory txRlp = Transactions.encodeRLP(transaction);\n        string memory pk = retreivePK();\n        txSigned = Suave.signEthTransaction(txRlp, HOLESKY_CHAINID_STR, pk);\n    }\n\n    function sendRawTx(bytes memory txSigned) public view returns (bytes memory) {\n        /* solhint-disable */\n        bytes memory body = abi.encodePacked(\n            '{\"jsonrpc\":\"2.0\",\"method\":\"eth_sendRawTransaction\",\"params\":[\"', \n            LibString.toHexString(txSigned), \n            '\"],\"id\":1}'\n        );\n        /* solhint-enable */\n        Suave.HttpRequest memory request;\n        request.method = \"POST\";\n        request.body = body;\n        request.headers = new string[](1);\n        request.headers[0] = \"Content-Type: application/json\";\n        request.withFlashbotsSignature = false;\n        request.url = REMOTE_HOLESKY_RPC;\n        return doHttpRequest(request);\n    }\n\n    function sendBundle(bytes memory txSigned, uint64 settlementBlockNum) internal view {\n        simulateTx(txSigned);\n        sendTxViaBundle(txSigned, settlementBlockNum);\n    }\n\n    function simulateTx(bytes memory signedTx) internal view {\n        // solhint-disable-next-line\n        bytes memory bundle = abi.encodePacked('{\"txs\": [\"', LibString.toHexString(signedTx), '\"]}');\n        (bool successSim, bytes memory data) = Suave.SIMULATE_BUNDLE.staticcall(abi.encode(bundle));\n        crequire(successSim,  string(abi.encodePacked(\"BundleSimulationFailed: \", string(data))));\n    }\n\n    function doBinanceQuery(string memory ticker) internal view returns (bytes memory) {\n        string[] memory headers = new string[](1);\n        headers[0] = \"Content-Type: application/json\";\n        Suave.HttpRequest memory request = Suave.HttpRequest({\n            url: string(abi.encodePacked(URL_PARTIAL, ticker)),\n            method: \"GET\",\n            headers: headers,\n            body: new bytes(0),\n            withFlashbotsSignature: false\n        });\n        return doHttpRequest(request);\n    }\n\n    function doHttpRequest(Suave.HttpRequest memory request) internal view returns (bytes memory) {\n        (bool success, bytes memory data) = Suave.DO_HTTPREQUEST.staticcall(abi.encode(request));\n        crequire(success, string(data));\n        return abi.decode(data, (bytes));\n    }\n\n    function sendTxViaBundle(bytes memory txSigned, uint64 settlementBlockNum) internal view {\n        bytes[] memory txns = new bytes[](1);\n        txns[0] = txSigned;\n        bytes memory bundleReqParams = bundleRequestParams(txns, settlementBlockNum);\n        (bool successReq, bytes memory dataReq) = Suave.SUBMIT_BUNDLE_JSON_RPC.staticcall(abi.encode(\n            HOLESKY_BUNDLE_ENDPOINT, \n            \"eth_sendBundle\", \n            bundleReqParams\n        ));\n        crequire(successReq, string(abi.encodePacked(\"BundleSubmissionFailed: \", string(dataReq))));\n    }\n\n    function bundleRequestParams(bytes[] memory txns, uint blockNumber) internal pure returns (bytes memory) {\n        // solhint-disable-next-line\n        bytes memory params = abi.encodePacked('{\"blockNumber\": \"', LibString.toHexString(blockNumber), '\", \"txs\": [');\n        for (uint256 i = 0; i < txns.length; i++) {\n            // solhint-disable-next-line\n            params = abi.encodePacked(params, '\"', LibString.toHexString(txns[i]), '\"');\n            if (i < txns.length - 1) {\n                params = abi.encodePacked(params, \",\");\n            } else {\n                params = abi.encodePacked(params, \"]\");\n            }\n        }\n        params = abi.encodePacked(params, \"}\");\n\n        return params;\n    }\n\n    function storePK(bytes memory pk) internal view returns (Suave.DataId) {\n\t\taddress[] memory peekers = new address[](3);\n\t\tpeekers[0] = address(this);\n\t\tpeekers[1] = Suave.FETCH_DATA_RECORDS;\n\t\tpeekers[2] = Suave.CONFIDENTIAL_RETRIEVE;\n\t\tSuave.DataRecord memory secretBid = Suave.newDataRecord(0, peekers, peekers, S_NAMESPACE);\n\t\tSuave.confidentialStore(secretBid.id, S_NAMESPACE, pk);\n\t\treturn secretBid.id;\n\t}\n\n    function retreivePK() internal view returns (string memory) {\n        bytes memory pkBytes =  Suave.confidentialRetrieve(pkBidId, S_NAMESPACE);\n        return string(pkBytes);\n    }\n\n}\n\n// ðŸ”§ Utils\n\nfunction floatToInt(string memory floatString, uint8 decimals) pure returns (uint) {\n    bytes memory stringBytes = bytes(floatString);\n    uint dotPosition;\n    \n    // Find the position of the dot\n    for (uint i = 0; i < stringBytes.length; i++) {\n        if (stringBytes[i] == 0x2E) {\n            dotPosition = i;\n            break;\n        }\n    }\n    \n    uint integerPart = 0;\n    uint decimalPart = 0;\n    uint tenPower = 1;\n    \n    // Convert integer part\n    for (uint i = dotPosition; i > 0; i--) {\n        integerPart += (uint8(stringBytes[i - 1]) - 48) * tenPower;\n        tenPower *= 10;\n    }\n    // Reset power of ten\n    tenPower = 1;\n    // Convert decimal part\n    for (uint i = dotPosition+decimals; i > dotPosition; i--) {\n        decimalPart += (uint8(stringBytes[i]) - 48) * tenPower;\n        tenPower *= 10;\n    }\n    // Combine integer and decimal parts\n    return integerPart * (10**decimals) + decimalPart;\n}\n\nfunction trimStrEdges(string memory _input) pure returns (string memory) {\n    bytes memory input = bytes(_input);\n    require(input.length > 2, \"Input too short\");\n\n    uint newLength = input.length - 2;\n    bytes memory result = new bytes(newLength);\n\n    assembly {\n        let inputPtr := add(input, 0x21)\n        let resultPtr := add(result, 0x20)\n        let length := mload(input)\n        mstore(resultPtr, mload(inputPtr))\n        mstore(result, newLength)\n    }\n    return string(result);\n}\n\nfunction getAddressForPk(string memory pk) view returns (address) {\n    bytes32 digest = keccak256(abi.encode(\"yo\"));\n    bytes memory sig = Suave.signMessage(abi.encodePacked(digest), Suave.CryptoSignature.SECP256, pk);\n    return recoverSigner(digest, sig);\n}\n\nfunction recoverSigner(bytes32 _ethSignedMessageHash, bytes memory _signature) pure returns (address) {\n    (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);\n    return ecrecover(_ethSignedMessageHash, v, r, s);\n}\n\nfunction splitSignature(bytes memory sig) pure returns (bytes32 r, bytes32 s, uint8 v) {\n    require(sig.length == 65, \"invalid signature length\");\n    assembly {\n        r := mload(add(sig, 32))\n        s := mload(add(sig, 64))\n        v := byte(0, mload(add(sig, 96)))\n    }\n    if (v < 27) {\n        v += 27;\n    }\n}"
    },
    "contracts/standard_peekers/bids.sol": {
      "content": "pragma solidity ^0.8.8;\n\nimport \"../libraries/Suave.sol\";\n\ncontract AnyBundleContract {\n    event DataRecordEvent(Suave.DataId dataId, uint64 decryptionCondition, address[] allowedPeekers);\n\n    function fetchConfidentialBundleData() public returns (bytes memory) {\n        require(Suave.isConfidential());\n\n        bytes memory confidentialInputs = Suave.confidentialInputs();\n        return abi.decode(confidentialInputs, (bytes));\n    }\n\n    function emitDataRecord(Suave.DataRecord calldata dataRecord) public {\n        emit DataRecordEvent(dataRecord.id, dataRecord.decryptionCondition, dataRecord.allowedPeekers);\n    }\n}\n\ncontract BundleContract is AnyBundleContract {\n    function newBundle(\n        uint64 decryptionCondition,\n        address[] memory dataAllowedPeekers,\n        address[] memory dataAllowedStores\n    ) external payable returns (bytes memory) {\n        require(Suave.isConfidential());\n\n        bytes memory bundleData = this.fetchConfidentialBundleData();\n\n        uint64 egp = Suave.simulateBundle(bundleData);\n\n        Suave.DataRecord memory dataRecord =\n            Suave.newDataRecord(decryptionCondition, dataAllowedPeekers, dataAllowedStores, \"default:v0:ethBundles\");\n\n        Suave.confidentialStore(dataRecord.id, \"default:v0:ethBundles\", bundleData);\n        Suave.confidentialStore(dataRecord.id, \"default:v0:ethBundleSimResults\", abi.encode(egp));\n\n        return emitAndReturn(dataRecord, bundleData);\n    }\n\n    function emitAndReturn(Suave.DataRecord memory dataRecord, bytes memory) internal virtual returns (bytes memory) {\n        emit DataRecordEvent(dataRecord.id, dataRecord.decryptionCondition, dataRecord.allowedPeekers);\n        return bytes.concat(this.emitDataRecord.selector, abi.encode(dataRecord));\n    }\n}\n\ncontract EthBundleSenderContract is BundleContract {\n    string[] public builderUrls;\n\n    constructor(string[] memory builderUrls_) {\n        builderUrls = builderUrls_;\n    }\n\n    function emitAndReturn(Suave.DataRecord memory dataRecord, bytes memory bundleData)\n        internal\n        virtual\n        override\n        returns (bytes memory)\n    {\n        for (uint256 i = 0; i < builderUrls.length; i++) {\n            Suave.submitBundleJsonRPC(builderUrls[i], \"eth_sendBundle\", bundleData);\n        }\n\n        return BundleContract.emitAndReturn(dataRecord, bundleData);\n    }\n}\n\ncontract MevShareContract is AnyBundleContract {\n    event HintEvent(Suave.DataId dataId, bytes hint);\n\n    event MatchEvent(Suave.DataId matchDataId, bytes matchHint);\n\n    function newTransaction(\n        uint64 decryptionCondition,\n        address[] memory dataAllowedPeekers,\n        address[] memory dataAllowedStores\n    ) external payable returns (bytes memory) {\n        // 0. check confidential execution\n        require(Suave.isConfidential());\n\n        // 1. fetch bundle data\n        bytes memory bundleData = this.fetchConfidentialBundleData();\n\n        // 2. sim bundle\n        uint64 egp = Suave.simulateBundle(bundleData);\n\n        // 3. extract hint\n        bytes memory hint = Suave.extractHint(bundleData);\n\n        // // 4. store bundle and sim results\n        Suave.DataRecord memory dataRecord = Suave.newDataRecord(\n            decryptionCondition, dataAllowedPeekers, dataAllowedStores, \"mevshare:v0:unmatchedBundles\"\n        );\n        Suave.confidentialStore(dataRecord.id, \"mevshare:v0:ethBundles\", bundleData);\n        Suave.confidentialStore(dataRecord.id, \"mevshare:v0:ethBundleSimResults\", abi.encode(egp));\n        emit DataRecordEvent(dataRecord.id, dataRecord.decryptionCondition, dataRecord.allowedPeekers);\n        emit HintEvent(dataRecord.id, hint);\n\n        // // 5. return \"callback\" to emit hint onchain\n        return bytes.concat(this.emitDataRecordAndHint.selector, abi.encode(dataRecord, hint));\n    }\n\n    function emitDataRecordAndHint(Suave.DataRecord calldata dataRecord, bytes memory hint) public {\n        emit DataRecordEvent(dataRecord.id, dataRecord.decryptionCondition, dataRecord.allowedPeekers);\n        emit HintEvent(dataRecord.id, hint);\n    }\n\n    function newMatch(\n        uint64 decryptionCondition,\n        address[] memory dataAllowedPeekers,\n        address[] memory dataAllowedStores,\n        Suave.DataId sharedataId\n    ) external payable returns (bytes memory) {\n        // WARNING : this function will copy the original mev share bid\n        // into a new key with potentially different permsissions\n\n        require(Suave.isConfidential());\n        // 1. fetch confidential data\n        bytes memory matchBundleData = this.fetchConfidentialBundleData();\n\n        // 2. sim match alone for validity\n        uint64 egp = Suave.simulateBundle(matchBundleData);\n\n        // 3. extract hint\n        bytes memory matchHint = Suave.extractHint(matchBundleData);\n\n        Suave.DataRecord memory dataRecord = Suave.newDataRecord(\n            decryptionCondition, dataAllowedPeekers, dataAllowedStores, \"mevshare:v0:matchDataRecords\"\n        );\n        Suave.confidentialStore(dataRecord.id, \"mevshare:v0:ethBundles\", matchBundleData);\n        Suave.confidentialStore(dataRecord.id, \"mevshare:v0:ethBundleSimResults\", abi.encode(0));\n\n        //4. merge data records\n        Suave.DataId[] memory dataRecords = new Suave.DataId[](2);\n        dataRecords[0] = sharedataId;\n        dataRecords[1] = dataRecord.id;\n        Suave.confidentialStore(dataRecord.id, \"mevshare:v0:mergedDataRecords\", abi.encode(dataRecords));\n\n        return emitMatchDataRecordAndHint(dataRecord, matchHint);\n    }\n\n    function emitMatchDataRecordAndHint(Suave.DataRecord memory dataRecord, bytes memory matchHint)\n        internal\n        virtual\n        returns (bytes memory)\n    {\n        emit DataRecordEvent(dataRecord.id, dataRecord.decryptionCondition, dataRecord.allowedPeekers);\n        emit MatchEvent(dataRecord.id, matchHint);\n\n        return bytes.concat(this.emitDataRecord.selector, abi.encode(dataRecord));\n    }\n}\n\ncontract MevShareBundleSenderContract is MevShareContract {\n    string[] public builderUrls;\n\n    constructor(string[] memory builderUrls_) {\n        builderUrls = builderUrls_;\n    }\n\n    function emitMatchDataRecordAndHint(Suave.DataRecord memory dataRecord, bytes memory matchHint)\n        internal\n        virtual\n        override\n        returns (bytes memory)\n    {\n        bytes memory bundleData = Suave.fillMevShareBundle(dataRecord.id);\n        for (uint256 i = 0; i < builderUrls.length; i++) {\n            Suave.submitBundleJsonRPC(builderUrls[i], \"mev_sendBundle\", bundleData);\n        }\n\n        return MevShareContract.emitMatchDataRecordAndHint(dataRecord, matchHint);\n    }\n}\n\n/* Not tested or implemented on the precompile side */\nstruct EgpRecordPair {\n    uint64 egp; // in wei, beware overflow\n    Suave.DataId dataId;\n}\n\ncontract EthBlockContract is AnyBundleContract {\n    event BuilderBoostBidEvent(Suave.DataId dataId, bytes builderBid);\n\n    function idsEqual(Suave.DataId _l, Suave.DataId _r) public pure returns (bool) {\n        bytes memory l = abi.encodePacked(_l);\n        bytes memory r = abi.encodePacked(_r);\n        for (uint256 i = 0; i < l.length; i++) {\n            if (bytes(l)[i] != r[i]) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    function buildMevShare(Suave.BuildBlockArgs memory blockArgs, uint64 blockHeight) public returns (bytes memory) {\n        require(Suave.isConfidential());\n\n        Suave.DataRecord[] memory allShareMatchDataRecords =\n            Suave.fetchDataRecords(blockHeight, \"mevshare:v0:matchDataRecords\");\n        Suave.DataRecord[] memory allShareUserDataRecords =\n            Suave.fetchDataRecords(blockHeight, \"mevshare:v0:unmatchedBundles\");\n\n        if (allShareUserDataRecords.length == 0) {\n            revert Suave.PeekerReverted(address(this), \"no data records\");\n        }\n\n        Suave.DataRecord[] memory allRecords = new Suave.DataRecord[](allShareUserDataRecords.length);\n        for (uint256 i = 0; i < allShareUserDataRecords.length; i++) {\n            // TODO: sort matches by egp first!\n            Suave.DataRecord memory dataRecordToInsert = allShareUserDataRecords[i]; // will be updated with the best match if any\n            for (uint256 j = 0; j < allShareMatchDataRecords.length; j++) {\n                // TODO: should be done once at the start and sorted\n                Suave.DataId[] memory mergeddataIds = abi.decode(\n                    Suave.confidentialRetrieve(allShareMatchDataRecords[j].id, \"mevshare:v0:mergedDataRecords\"),\n                    (Suave.DataId[])\n                );\n                if (idsEqual(mergeddataIds[0], allShareUserDataRecords[i].id)) {\n                    dataRecordToInsert = allShareMatchDataRecords[j];\n                    break;\n                }\n            }\n            allRecords[i] = dataRecordToInsert;\n        }\n\n        EgpRecordPair[] memory bidsByEGP = new EgpRecordPair[](allRecords.length);\n        for (uint256 i = 0; i < allRecords.length; i++) {\n            bytes memory simResults = Suave.confidentialRetrieve(allRecords[i].id, \"mevshare:v0:ethBundleSimResults\");\n            uint64 egp = abi.decode(simResults, (uint64));\n            bidsByEGP[i] = EgpRecordPair(egp, allRecords[i].id);\n        }\n\n        // Bubble sort, cause why not\n        uint256 n = bidsByEGP.length;\n        for (uint256 i = 0; i < n - 1; i++) {\n            for (uint256 j = i + 1; j < n; j++) {\n                if (bidsByEGP[i].egp < bidsByEGP[j].egp) {\n                    EgpRecordPair memory temp = bidsByEGP[i];\n                    bidsByEGP[i] = bidsByEGP[j];\n                    bidsByEGP[j] = temp;\n                }\n            }\n        }\n\n        Suave.DataId[] memory alldataIds = new Suave.DataId[](allRecords.length);\n        for (uint256 i = 0; i < bidsByEGP.length; i++) {\n            alldataIds[i] = bidsByEGP[i].dataId;\n        }\n\n        return buildAndEmit(blockArgs, blockHeight, alldataIds, \"mevshare:v0\");\n    }\n\n    function buildFromPool(Suave.BuildBlockArgs memory blockArgs, uint64 blockHeight) public returns (bytes memory) {\n        require(Suave.isConfidential());\n\n        Suave.DataRecord[] memory allRecords = Suave.fetchDataRecords(blockHeight, \"default:v0:ethBundles\");\n        if (allRecords.length == 0) {\n            revert Suave.PeekerReverted(address(this), \"no data records\");\n        }\n\n        EgpRecordPair[] memory bidsByEGP = new EgpRecordPair[](allRecords.length);\n        for (uint256 i = 0; i < allRecords.length; i++) {\n            bytes memory simResults = Suave.confidentialRetrieve(allRecords[i].id, \"default:v0:ethBundleSimResults\");\n            uint64 egp = abi.decode(simResults, (uint64));\n            bidsByEGP[i] = EgpRecordPair(egp, allRecords[i].id);\n        }\n\n        // Bubble sort, cause why not\n        uint256 n = bidsByEGP.length;\n        for (uint256 i = 0; i < n - 1; i++) {\n            for (uint256 j = i + 1; j < n; j++) {\n                if (bidsByEGP[i].egp < bidsByEGP[j].egp) {\n                    EgpRecordPair memory temp = bidsByEGP[i];\n                    bidsByEGP[i] = bidsByEGP[j];\n                    bidsByEGP[j] = temp;\n                }\n            }\n        }\n\n        Suave.DataId[] memory alldataIds = new Suave.DataId[](allRecords.length);\n        for (uint256 i = 0; i < bidsByEGP.length; i++) {\n            alldataIds[i] = bidsByEGP[i].dataId;\n        }\n\n        return buildAndEmit(blockArgs, blockHeight, alldataIds, \"\");\n    }\n\n    function buildAndEmit(\n        Suave.BuildBlockArgs memory blockArgs,\n        uint64 blockHeight,\n        Suave.DataId[] memory records,\n        string memory relayUrl\n    ) public virtual returns (bytes memory) {\n        require(Suave.isConfidential());\n\n        (Suave.DataRecord memory blockBid, bytes memory builderBid) =\n            this.doBuild(blockArgs, blockHeight, records, relayUrl);\n\n        emit BuilderBoostBidEvent(blockBid.id, builderBid);\n        emit DataRecordEvent(blockBid.id, blockBid.decryptionCondition, blockBid.allowedPeekers);\n        return bytes.concat(this.emitBuilderBidAndBid.selector, abi.encode(blockBid, builderBid));\n    }\n\n    function doBuild(\n        Suave.BuildBlockArgs memory blockArgs,\n        uint64 blockHeight,\n        Suave.DataId[] memory records,\n        string memory relayUrl\n    ) public view returns (Suave.DataRecord memory, bytes memory) {\n        address[] memory allowedPeekers = new address[](2);\n        allowedPeekers[0] = address(this);\n        allowedPeekers[1] = Suave.BUILD_ETH_BLOCK;\n\n        Suave.DataRecord memory blockBid =\n            Suave.newDataRecord(blockHeight, allowedPeekers, allowedPeekers, \"default:v0:mergedDataRecords\");\n        Suave.confidentialStore(blockBid.id, \"default:v0:mergedDataRecords\", abi.encode(records));\n\n        // todo: specify the builder - mainnet/holesky\n        (bytes memory builderBid, bytes memory payload) = Suave.buildEthBlock(blockArgs, blockBid.id, relayUrl);\n        Suave.confidentialStore(blockBid.id, \"default:v0:builderPayload\", payload); // only through this.unlock\n\n        return (blockBid, builderBid);\n    }\n\n    function emitBuilderBidAndBid(Suave.DataRecord memory dataRecord, bytes memory builderBid)\n        public\n        returns (Suave.DataRecord memory, bytes memory)\n    {\n        emit BuilderBoostBidEvent(dataRecord.id, builderBid);\n        emit DataRecordEvent(dataRecord.id, dataRecord.decryptionCondition, dataRecord.allowedPeekers);\n        return (dataRecord, builderBid);\n    }\n\n    function unlock(Suave.DataId dataId, bytes memory signedBlindedHeader) public view returns (bytes memory) {\n        require(Suave.isConfidential());\n\n        // TODO: verify the header is correct\n        // TODO: incorporate protocol name\n        bytes memory payload = Suave.confidentialRetrieve(dataId, \"default:v0:builderPayload\");\n        return payload;\n    }\n}\n\ncontract EthBlockBidSenderContract is EthBlockContract {\n    string boostRelayUrl;\n\n    constructor(string memory boostRelayUrl_) {\n        boostRelayUrl = boostRelayUrl_;\n    }\n\n    function buildAndEmit(\n        Suave.BuildBlockArgs memory blockArgs,\n        uint64 blockHeight,\n        Suave.DataId[] memory dataRecords,\n        string memory namespace\n    ) public virtual override returns (bytes memory) {\n        require(Suave.isConfidential());\n\n        (Suave.DataRecord memory blockDataRecord, bytes memory builderBid) =\n            this.doBuild(blockArgs, blockHeight, dataRecords, namespace);\n        Suave.submitEthBlockToRelay(boostRelayUrl, builderBid);\n\n        emit DataRecordEvent(blockDataRecord.id, blockDataRecord.decryptionCondition, blockDataRecord.allowedPeekers);\n        return bytes.concat(this.emitDataRecord.selector, abi.encode(blockDataRecord));\n    }\n}\n"
    },
    "solady/src/utils/JSONParserLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for parsing JSONs.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/JSONParserLib.sol)\nlibrary JSONParserLib {\n    /*Â´:Â°â€¢.Â°+.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°â€¢.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°+.*â€¢Â´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.â€¢Â°:Â°.Â´+Ëš.*Â°.Ëš:*.Â´â€¢*.+Â°.â€¢Â°:Â´*.Â´â€¢*.â€¢Â°.â€¢Â°:Â°.Â´:â€¢ËšÂ°.*Â°.Ëš:*.Â´+Â°.â€¢*/\n\n    /// @dev The input is invalid.\n    error ParsingFailed();\n\n    /*Â´:Â°â€¢.Â°+.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°â€¢.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°+.*â€¢Â´.*:*/\n    /*                         CONSTANTS                          */\n    /*.â€¢Â°:Â°.Â´+Ëš.*Â°.Ëš:*.Â´â€¢*.+Â°.â€¢Â°:Â´*.Â´â€¢*.â€¢Â°.â€¢Â°:Â°.Â´:â€¢ËšÂ°.*Â°.Ëš:*.Â´+Â°.â€¢*/\n\n    // There are 6 types of variables in JSON (excluding undefined).\n\n    /// @dev For denoting that an item has not been initialized.\n    /// A item returned from `parse` will never be of an undefined type.\n    /// Parsing a invalid JSON string will simply revert.\n    uint8 internal constant TYPE_UNDEFINED = 0;\n\n    /// @dev Type representing an array (e.g. `[1,2,3]`).\n    uint8 internal constant TYPE_ARRAY = 1;\n\n    /// @dev Type representing an object (e.g. `{\"a\":\"A\",\"b\":\"B\"}`).\n    uint8 internal constant TYPE_OBJECT = 2;\n\n    /// @dev Type representing a number (e.g. `-1.23e+21`).\n    uint8 internal constant TYPE_NUMBER = 3;\n\n    /// @dev Type representing a string (e.g. `\"hello\"`).\n    uint8 internal constant TYPE_STRING = 4;\n\n    /// @dev Type representing a boolean (i.e. `true` or `false`).\n    uint8 internal constant TYPE_BOOLEAN = 5;\n\n    /// @dev Type representing null (i.e. `null`).\n    uint8 internal constant TYPE_NULL = 6;\n\n    /*Â´:Â°â€¢.Â°+.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°â€¢.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°+.*â€¢Â´.*:*/\n    /*                          STRUCTS                           */\n    /*.â€¢Â°:Â°.Â´+Ëš.*Â°.Ëš:*.Â´â€¢*.+Â°.â€¢Â°:Â´*.Â´â€¢*.â€¢Â°.â€¢Â°:Â°.Â´:â€¢ËšÂ°.*Â°.Ëš:*.Â´+Â°.â€¢*/\n\n    /// @dev A pointer to a parsed JSON node.\n    struct Item {\n        // Do NOT modify the `_data` directly.\n        uint256 _data;\n    }\n\n    // Private constants for packing `_data`.\n\n    uint256 private constant _BITPOS_STRING = 32 * 7 - 8;\n    uint256 private constant _BITPOS_KEY_LENGTH = 32 * 6 - 8;\n    uint256 private constant _BITPOS_KEY = 32 * 5 - 8;\n    uint256 private constant _BITPOS_VALUE_LENGTH = 32 * 4 - 8;\n    uint256 private constant _BITPOS_VALUE = 32 * 3 - 8;\n    uint256 private constant _BITPOS_CHILD = 32 * 2 - 8;\n    uint256 private constant _BITPOS_SIBLING_OR_PARENT = 32 * 1 - 8;\n    uint256 private constant _BITMASK_POINTER = 0xffffffff;\n    uint256 private constant _BITMASK_TYPE = 7;\n    uint256 private constant _KEY_INITED = 1 << 3;\n    uint256 private constant _VALUE_INITED = 1 << 4;\n    uint256 private constant _CHILDREN_INITED = 1 << 5;\n    uint256 private constant _PARENT_IS_ARRAY = 1 << 6;\n    uint256 private constant _PARENT_IS_OBJECT = 1 << 7;\n\n    /*Â´:Â°â€¢.Â°+.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°â€¢.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°+.*â€¢Â´.*:*/\n    /*                   JSON PARSING OPERATION                   */\n    /*.â€¢Â°:Â°.Â´+Ëš.*Â°.Ëš:*.Â´â€¢*.+Â°.â€¢Â°:Â´*.Â´â€¢*.â€¢Â°.â€¢Â°:Â°.Â´:â€¢ËšÂ°.*Â°.Ëš:*.Â´+Â°.â€¢*/\n\n    /// @dev Parses the JSON string `s`, and returns the root.\n    /// Reverts if `s` is not a valid JSON as specified in RFC 8259.\n    /// Object items WILL simply contain all their children, inclusive of repeated keys,\n    /// in the same order which they appear in the JSON string.\n    ///\n    /// Note: For efficiency, this function WILL NOT make a copy of `s`.\n    /// The parsed tree WILL contain offsets to `s`.\n    /// Do NOT pass in a string that WILL be modified later on.\n    function parse(string memory s) internal pure returns (Item memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x40, result) // We will use our own allocation instead.\n        }\n        bytes32 r = _query(_toInput(s), 255);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := r\n        }\n    }\n\n    /*Â´:Â°â€¢.Â°+.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°â€¢.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°+.*â€¢Â´.*:*/\n    /*                    JSON ITEM OPERATIONS                    */\n    /*.â€¢Â°:Â°.Â´+Ëš.*Â°.Ëš:*.Â´â€¢*.+Â°.â€¢Â°:Â´*.Â´â€¢*.â€¢Â°.â€¢Â°:Â°.Â´:â€¢ËšÂ°.*Â°.Ëš:*.Â´+Â°.â€¢*/\n\n    // Note:\n    // - An item is a node in the JSON tree.\n    // - The value of a string item WILL be double-quoted, JSON encoded.\n    // - We make a distinction between `index` and `key`.\n    //   - Items in arrays are located by `index` (uint256).\n    //   - Items in objects are located by `key` (string).\n    // - Keys are always strings, double-quoted, JSON encoded.\n    //\n    // These design choices are made to balance between efficiency and ease-of-use.\n\n    /// @dev Returns the string value of the item.\n    /// This is its exact string representation in the original JSON string.\n    /// The returned string WILL have leading and trailing whitespace trimmed.\n    /// All inner whitespace WILL be preserved, exactly as it is in the original JSON string.\n    /// If the item's type is string, the returned string WILL be double-quoted, JSON encoded.\n    ///\n    /// Note: This function lazily instantiates and caches the returned string.\n    /// Do NOT modify the returned string.\n    function value(Item memory item) internal pure returns (string memory result) {\n        bytes32 r = _query(_toInput(item), 0);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := r\n        }\n    }\n\n    /// @dev Returns the index of the item in the array.\n    /// It the item's parent is not an array, returns 0.\n    function index(Item memory item) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if and(mload(item), _PARENT_IS_ARRAY) {\n                result := and(_BITMASK_POINTER, shr(_BITPOS_KEY, mload(item)))\n            }\n        }\n    }\n\n    /// @dev Returns the key of the item in the object.\n    /// It the item's parent is not an object, returns an empty string.\n    /// The returned string WILL be double-quoted, JSON encoded.\n    ///\n    /// Note: This function lazily instantiates and caches the returned string.\n    /// Do NOT modify the returned string.\n    function key(Item memory item) internal pure returns (string memory result) {\n        if (item._data & _PARENT_IS_OBJECT != 0) {\n            bytes32 r = _query(_toInput(item), 1);\n            /// @solidity memory-safe-assembly\n            assembly {\n                result := r\n            }\n        }\n    }\n\n    /// @dev Returns the key of the item in the object.\n    /// It the item is neither an array nor object, returns an empty array.\n    ///\n    /// Note: This function lazily instantiates and caches the returned array.\n    /// Do NOT modify the returned array.\n    function children(Item memory item) internal pure returns (Item[] memory result) {\n        bytes32 r = _query(_toInput(item), 3);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := r\n        }\n    }\n\n    /// @dev Returns the number of children.\n    /// It the item is neither an array nor object, returns zero.\n    function size(Item memory item) internal pure returns (uint256 result) {\n        bytes32 r = _query(_toInput(item), 3);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(r)\n        }\n    }\n\n    /// @dev Returns the item at index `i` for (array).\n    /// If `item` is not an array, the result's type WILL be undefined.\n    /// If there is no item with the index, the result's type WILL be undefined.\n    function at(Item memory item, uint256 i) internal pure returns (Item memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x40, result) // Free the default allocation. We'll allocate manually.\n        }\n        bytes32 r = _query(_toInput(item), 3);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(add(add(r, 0x20), shl(5, i)))\n            if iszero(and(lt(i, mload(r)), eq(and(mload(item), _BITMASK_TYPE), TYPE_ARRAY))) {\n                result := 0x60 // Reset to the zero pointer.\n            }\n        }\n    }\n\n    /// @dev Returns the item at key `k` for (object).\n    /// If `item` is not an object, the result's type WILL be undefined.\n    /// The key MUST be double-quoted, JSON encoded. This is for efficiency reasons.\n    /// - Correct : `item.at('\"k\"')`.\n    /// - Wrong   : `item.at(\"k\")`.\n    /// For duplicated keys, the last item with the key WILL be returned.\n    /// If there is no item with the key, the result's type WILL be undefined.\n    function at(Item memory item, string memory k) internal pure returns (Item memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x40, result) // Free the default allocation. We'll allocate manually.\n            result := 0x60 // Initialize to the zero pointer.\n        }\n        if (isObject(item)) {\n            bytes32 kHash = keccak256(bytes(k));\n            Item[] memory r = children(item);\n            // We'll just do a linear search. The alternatives are very bloated.\n            for (uint256 i = r.length << 5; i != 0;) {\n                /// @solidity memory-safe-assembly\n                assembly {\n                    item := mload(add(r, i))\n                    i := sub(i, 0x20)\n                }\n                if (keccak256(bytes(key(item))) != kHash) continue;\n                result = item;\n                break;\n            }\n        }\n    }\n\n    /// @dev Returns the item's type.\n    function getType(Item memory item) internal pure returns (uint8 result) {\n        result = uint8(item._data & _BITMASK_TYPE);\n    }\n\n    /// Note: All types are mutually exclusive.\n\n    /// @dev Returns whether the item is of type undefined.\n    function isUndefined(Item memory item) internal pure returns (bool result) {\n        result = item._data & _BITMASK_TYPE == TYPE_UNDEFINED;\n    }\n\n    /// @dev Returns whether the item is of type array.\n    function isArray(Item memory item) internal pure returns (bool result) {\n        result = item._data & _BITMASK_TYPE == TYPE_ARRAY;\n    }\n\n    /// @dev Returns whether the item is of type object.\n    function isObject(Item memory item) internal pure returns (bool result) {\n        result = item._data & _BITMASK_TYPE == TYPE_OBJECT;\n    }\n\n    /// @dev Returns whether the item is of type number.\n    function isNumber(Item memory item) internal pure returns (bool result) {\n        result = item._data & _BITMASK_TYPE == TYPE_NUMBER;\n    }\n\n    /// @dev Returns whether the item is of type string.\n    function isString(Item memory item) internal pure returns (bool result) {\n        result = item._data & _BITMASK_TYPE == TYPE_STRING;\n    }\n\n    /// @dev Returns whether the item is of type boolean.\n    function isBoolean(Item memory item) internal pure returns (bool result) {\n        result = item._data & _BITMASK_TYPE == TYPE_BOOLEAN;\n    }\n\n    /// @dev Returns whether the item is of type null.\n    function isNull(Item memory item) internal pure returns (bool result) {\n        result = item._data & _BITMASK_TYPE == TYPE_NULL;\n    }\n\n    /// @dev Returns the item's parent.\n    /// If the item does not have a parent, the result's type will be undefined.\n    function parent(Item memory item) internal pure returns (Item memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x40, result) // Free the default allocation. We've already allocated.\n            result := and(shr(_BITPOS_SIBLING_OR_PARENT, mload(item)), _BITMASK_POINTER)\n            if iszero(result) { result := 0x60 } // Reset to the zero pointer.\n        }\n    }\n\n    /*Â´:Â°â€¢.Â°+.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°â€¢.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°+.*â€¢Â´.*:*/\n    /*                     UTILITY FUNCTIONS                      */\n    /*.â€¢Â°:Â°.Â´+Ëš.*Â°.Ëš:*.Â´â€¢*.+Â°.â€¢Â°:Â´*.Â´â€¢*.â€¢Â°.â€¢Â°:Â°.Â´:â€¢ËšÂ°.*Â°.Ëš:*.Â´+Â°.â€¢*/\n\n    /// @dev Parses an unsigned integer from a string (in decimal, i.e. base 10).\n    /// Reverts if `s` is not a valid uint256 string matching the RegEx `^[0-9]+$`,\n    /// or if the parsed number is too big for a uint256.\n    function parseUint(string memory s) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(s)\n            let preMulOverflowThres := div(not(0), 10)\n            for { let i := 0 } 1 {} {\n                i := add(i, 1)\n                let digit := sub(and(mload(add(s, i)), 0xff), 48)\n                let mulOverflowed := gt(result, preMulOverflowThres)\n                let product := mul(10, result)\n                result := add(product, digit)\n                n := mul(n, iszero(or(or(mulOverflowed, lt(result, product)), gt(digit, 9))))\n                if iszero(lt(i, n)) { break }\n            }\n            if iszero(n) {\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Parses a signed integer from a string (in decimal, i.e. base 10).\n    /// Reverts if `s` is not a valid int256 string matching the RegEx `^[+-]?[0-9]+$`,\n    /// or if the parsed number cannot fit within `[-2**255 .. 2**255 - 1]`.\n    function parseInt(string memory s) internal pure returns (int256 result) {\n        uint256 n = bytes(s).length;\n        uint256 sign;\n        uint256 isNegative;\n        /// @solidity memory-safe-assembly\n        assembly {\n            if n {\n                let c := and(mload(add(s, 1)), 0xff)\n                isNegative := eq(c, 45)\n                if or(eq(c, 43), isNegative) {\n                    sign := c\n                    s := add(s, 1)\n                    mstore(s, sub(n, 1))\n                }\n                if iszero(or(sign, lt(sub(c, 48), 10))) { s := 0x60 }\n            }\n        }\n        uint256 x = parseUint(s);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(lt(x, add(shl(255, 1), isNegative))) {\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\n                revert(0x1c, 0x04)\n            }\n            if sign {\n                mstore(s, sign)\n                s := sub(s, 1)\n                mstore(s, n)\n            }\n            result := xor(x, mul(xor(x, add(not(x), 1)), isNegative))\n        }\n    }\n\n    /// @dev Parses an unsigned integer from a string (in hexadecimal, i.e. base 16).\n    /// Reverts if `s` is not a valid uint256 hex string matching the RegEx\n    /// `^(0[xX])?[0-9a-fA-F]+$`, or if the parsed number cannot fit within `[0 .. 2**256 - 1]`.\n    function parseUintFromHex(string memory s) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(s)\n            // Skip two if starts with '0x' or '0X'.\n            let i := shl(1, and(eq(0x3078, or(shr(240, mload(add(s, 0x20))), 0x20)), gt(n, 1)))\n            for {} 1 {} {\n                i := add(i, 1)\n                let c :=\n                    byte(\n                        and(0x1f, shr(and(mload(add(s, i)), 0xff), 0x3e4088843e41bac000000000000)),\n                        0x3010a071000000b0104040208000c05090d060e0f\n                    )\n                n := mul(n, iszero(or(iszero(c), shr(252, result))))\n                result := add(shl(4, result), sub(c, 1))\n                if iszero(lt(i, n)) { break }\n            }\n            if iszero(n) {\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Decodes a JSON encoded string.\n    /// The string MUST be double-quoted, JSON encoded.\n    /// Reverts if the string is invalid.\n    /// As you can see, it's pretty complex for a deceptively simple looking task.\n    function decodeString(string memory s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function fail() {\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\n                revert(0x1c, 0x04)\n            }\n\n            function decodeUnicodeEscapeSequence(pIn_, end_) -> _unicode, _pOut {\n                _pOut := add(pIn_, 4)\n                let b_ := iszero(gt(_pOut, end_))\n                let t_ := mload(pIn_) // Load the whole word.\n                for { let i_ := 0 } iszero(eq(i_, 4)) { i_ := add(i_, 1) } {\n                    let c_ := sub(byte(i_, t_), 48)\n                    if iszero(and(shr(c_, 0x7e0000007e03ff), b_)) { fail() } // Not hexadecimal.\n                    c_ := sub(c_, add(mul(gt(c_, 16), 7), shl(5, gt(c_, 48))))\n                    _unicode := add(shl(4, _unicode), c_)\n                }\n            }\n\n            function decodeUnicodeCodePoint(pIn_, end_) -> _unicode, _pOut {\n                _unicode, _pOut := decodeUnicodeEscapeSequence(pIn_, end_)\n                if iszero(or(lt(_unicode, 0xd800), gt(_unicode, 0xdbff))) {\n                    let t_ := mload(_pOut) // Load the whole word.\n                    end_ := mul(end_, eq(shr(240, t_), 0x5c75)) // Fail if not starting with '\\\\u'.\n                    t_, _pOut := decodeUnicodeEscapeSequence(add(_pOut, 2), end_)\n                    _unicode := add(0x10000, add(shl(10, and(0x3ff, _unicode)), and(0x3ff, t_)))\n                }\n            }\n\n            function appendCodePointAsUTF8(pIn_, c_) -> _pOut {\n                if iszero(gt(c_, 0x7f)) {\n                    mstore8(pIn_, c_)\n                    _pOut := add(pIn_, 1)\n                    leave\n                }\n                mstore8(0x1f, c_)\n                mstore8(0x1e, shr(6, c_))\n                if iszero(gt(c_, 0x7ff)) {\n                    mstore(pIn_, shl(240, or(0xc080, and(0x1f3f, mload(0x00)))))\n                    _pOut := add(pIn_, 2)\n                    leave\n                }\n                mstore8(0x1d, shr(12, c_))\n                if iszero(gt(c_, 0xffff)) {\n                    mstore(pIn_, shl(232, or(0xe08080, and(0x0f3f3f, mload(0x00)))))\n                    _pOut := add(pIn_, 3)\n                    leave\n                }\n                mstore8(0x1c, shr(18, c_))\n                mstore(pIn_, shl(224, or(0xf0808080, and(0x073f3f3f, mload(0x00)))))\n                _pOut := add(pIn_, shl(2, lt(c_, 0x110000)))\n            }\n\n            function chr(p_) -> _c {\n                _c := byte(0, mload(p_))\n            }\n\n            let n := mload(s)\n            let end := add(add(s, n), 0x1f)\n            if iszero(and(gt(n, 1), eq(0x2222, or(and(0xff00, mload(add(s, 2))), chr(end))))) {\n                fail() // Fail if not double-quoted.\n            }\n            let out := add(mload(0x40), 0x20)\n            for { let curr := add(s, 0x21) } iszero(eq(curr, end)) {} {\n                let c := chr(curr)\n                curr := add(curr, 1)\n                // Not '\\\\'.\n                if iszero(eq(c, 92)) {\n                    // Not '\"'.\n                    if iszero(eq(c, 34)) {\n                        mstore8(out, c)\n                        out := add(out, 1)\n                        continue\n                    }\n                    curr := end\n                }\n                if iszero(eq(curr, end)) {\n                    let escape := chr(curr)\n                    curr := add(curr, 1)\n                    // '\"', '/', '\\\\'.\n                    if and(shr(escape, 0x100000000000800400000000), 1) {\n                        mstore8(out, escape)\n                        out := add(out, 1)\n                        continue\n                    }\n                    // 'u'.\n                    if eq(escape, 117) {\n                        escape, curr := decodeUnicodeCodePoint(curr, end)\n                        out := appendCodePointAsUTF8(out, escape)\n                        continue\n                    }\n                    // `{'b':'\\b', 'f':'\\f', 'n':'\\n', 'r':'\\r', 't':'\\t'}`.\n                    escape := byte(sub(escape, 85), 0x080000000c000000000000000a0000000d0009)\n                    if escape {\n                        mstore8(out, escape)\n                        out := add(out, 1)\n                        continue\n                    }\n                }\n                fail()\n                break\n            }\n            mstore(out, 0) // Zeroize the last slot.\n            result := mload(0x40)\n            mstore(result, sub(out, add(result, 0x20))) // Store the length.\n            mstore(0x40, add(out, 0x20)) // Allocate the memory.\n        }\n    }\n\n    /*Â´:Â°â€¢.Â°+.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°â€¢.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°+.*â€¢Â´.*:*/\n    /*                      PRIVATE HELPERS                       */\n    /*.â€¢Â°:Â°.Â´+Ëš.*Â°.Ëš:*.Â´â€¢*.+Â°.â€¢Â°:Â´*.Â´â€¢*.â€¢Â°.â€¢Â°:Â°.Â´:â€¢ËšÂ°.*Â°.Ëš:*.Â´+Â°.â€¢*/\n\n    /// @dev Performs a query on the input with the given mode.\n    function _query(bytes32 input, uint256 mode) private pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function fail() {\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\n                revert(0x1c, 0x04)\n            }\n\n            function chr(p_) -> _c {\n                _c := byte(0, mload(p_))\n            }\n\n            function skipWhitespace(pIn_, end_) -> _pOut {\n                for { _pOut := pIn_ } 1 { _pOut := add(_pOut, 1) } {\n                    if iszero(and(shr(chr(_pOut), 0x100002600), 1)) { leave } // Not in ' \\n\\r\\t'.\n                }\n            }\n\n            function setP(packed_, bitpos_, p_) -> _packed {\n                // Perform an out-of-gas revert if `p_` exceeds `_BITMASK_POINTER`.\n                returndatacopy(returndatasize(), returndatasize(), gt(p_, _BITMASK_POINTER))\n                _packed := or(and(not(shl(bitpos_, _BITMASK_POINTER)), packed_), shl(bitpos_, p_))\n            }\n\n            function getP(packed_, bitpos_) -> _p {\n                _p := and(_BITMASK_POINTER, shr(bitpos_, packed_))\n            }\n\n            function mallocItem(s_, packed_, pStart_, pCurr_, type_) -> _item {\n                _item := mload(0x40)\n                // forgefmt: disable-next-item\n                packed_ := setP(setP(packed_, _BITPOS_VALUE, sub(pStart_, add(s_, 0x20))),\n                    _BITPOS_VALUE_LENGTH, sub(pCurr_, pStart_))\n                mstore(_item, or(packed_, type_))\n                mstore(0x40, add(_item, 0x20)) // Allocate memory.\n            }\n\n            function parseValue(s_, sibling_, pIn_, end_) -> _item, _pOut {\n                let packed_ := setP(mload(0x00), _BITPOS_SIBLING_OR_PARENT, sibling_)\n                _pOut := skipWhitespace(pIn_, end_)\n                if iszero(lt(_pOut, end_)) { leave }\n                for { let c_ := chr(_pOut) } 1 {} {\n                    // If starts with '\"'.\n                    if eq(c_, 34) {\n                        let pStart_ := _pOut\n                        _pOut := parseStringSub(s_, packed_, _pOut, end_)\n                        _item := mallocItem(s_, packed_, pStart_, _pOut, TYPE_STRING)\n                        break\n                    }\n                    // If starts with '['.\n                    if eq(c_, 91) {\n                        _item, _pOut := parseArray(s_, packed_, _pOut, end_)\n                        break\n                    }\n                    // If starts with '{'.\n                    if eq(c_, 123) {\n                        _item, _pOut := parseObject(s_, packed_, _pOut, end_)\n                        break\n                    }\n                    // If starts with any in '0123456789-'.\n                    if and(shr(c_, shl(45, 0x1ff9)), 1) {\n                        _item, _pOut := parseNumber(s_, packed_, _pOut, end_)\n                        break\n                    }\n                    if iszero(gt(add(_pOut, 4), end_)) {\n                        let pStart_ := _pOut\n                        let w_ := shr(224, mload(_pOut))\n                        // 'true' in hex format.\n                        if eq(w_, 0x74727565) {\n                            _pOut := add(_pOut, 4)\n                            _item := mallocItem(s_, packed_, pStart_, _pOut, TYPE_BOOLEAN)\n                            break\n                        }\n                        // 'null' in hex format.\n                        if eq(w_, 0x6e756c6c) {\n                            _pOut := add(_pOut, 4)\n                            _item := mallocItem(s_, packed_, pStart_, _pOut, TYPE_NULL)\n                            break\n                        }\n                    }\n                    if iszero(gt(add(_pOut, 5), end_)) {\n                        let pStart_ := _pOut\n                        let w_ := shr(216, mload(_pOut))\n                        // 'false' in hex format.\n                        if eq(w_, 0x66616c7365) {\n                            _pOut := add(_pOut, 5)\n                            _item := mallocItem(s_, packed_, pStart_, _pOut, TYPE_BOOLEAN)\n                            break\n                        }\n                    }\n                    fail()\n                    break\n                }\n                _pOut := skipWhitespace(_pOut, end_)\n            }\n\n            function parseArray(s_, packed_, pIn_, end_) -> _item, _pOut {\n                let j_ := 0\n                for { _pOut := add(pIn_, 1) } 1 { _pOut := add(_pOut, 1) } {\n                    if iszero(lt(_pOut, end_)) { fail() }\n                    if iszero(_item) {\n                        _pOut := skipWhitespace(_pOut, end_)\n                        if eq(chr(_pOut), 93) { break } // ']'.\n                    }\n                    _item, _pOut := parseValue(s_, _item, _pOut, end_)\n                    if _item {\n                        // forgefmt: disable-next-item\n                        mstore(_item, setP(or(_PARENT_IS_ARRAY, mload(_item)),\n                            _BITPOS_KEY, j_))\n                        j_ := add(j_, 1)\n                        let c_ := chr(_pOut)\n                        if eq(c_, 93) { break } // ']'.\n                        if eq(c_, 44) { continue } // ','.\n                    }\n                    _pOut := end_\n                }\n                _pOut := add(_pOut, 1)\n                packed_ := setP(packed_, _BITPOS_CHILD, _item)\n                _item := mallocItem(s_, packed_, pIn_, _pOut, TYPE_ARRAY)\n            }\n\n            function parseObject(s_, packed_, pIn_, end_) -> _item, _pOut {\n                for { _pOut := add(pIn_, 1) } 1 { _pOut := add(_pOut, 1) } {\n                    if iszero(lt(_pOut, end_)) { fail() }\n                    if iszero(_item) {\n                        _pOut := skipWhitespace(_pOut, end_)\n                        if eq(chr(_pOut), 125) { break } // '}'.\n                    }\n                    _pOut := skipWhitespace(_pOut, end_)\n                    let pKeyStart_ := _pOut\n                    let pKeyEnd_ := parseStringSub(s_, _item, _pOut, end_)\n                    _pOut := skipWhitespace(pKeyEnd_, end_)\n                    // If ':'.\n                    if eq(chr(_pOut), 58) {\n                        _item, _pOut := parseValue(s_, _item, add(_pOut, 1), end_)\n                        if _item {\n                            // forgefmt: disable-next-item\n                            mstore(_item, setP(setP(or(_PARENT_IS_OBJECT, mload(_item)),\n                                _BITPOS_KEY_LENGTH, sub(pKeyEnd_, pKeyStart_)),\n                                    _BITPOS_KEY, sub(pKeyStart_, add(s_, 0x20))))\n                            let c_ := chr(_pOut)\n                            if eq(c_, 125) { break } // '}'.\n                            if eq(c_, 44) { continue } // ','.\n                        }\n                    }\n                    _pOut := end_\n                }\n                _pOut := add(_pOut, 1)\n                packed_ := setP(packed_, _BITPOS_CHILD, _item)\n                _item := mallocItem(s_, packed_, pIn_, _pOut, TYPE_OBJECT)\n            }\n\n            function checkStringU(p_, o_) {\n                // If not in '0123456789abcdefABCDEF', revert.\n                if iszero(and(shr(sub(chr(add(p_, o_)), 48), 0x7e0000007e03ff), 1)) { fail() }\n                if iszero(eq(o_, 5)) { checkStringU(p_, add(o_, 1)) }\n            }\n\n            function parseStringSub(s_, packed_, pIn_, end_) -> _pOut {\n                if iszero(lt(pIn_, end_)) { fail() }\n                for { _pOut := add(pIn_, 1) } 1 {} {\n                    let c_ := chr(_pOut)\n                    if eq(c_, 34) { break } // '\"'.\n                    // Not '\\'.\n                    if iszero(eq(c_, 92)) {\n                        _pOut := add(_pOut, 1)\n                        continue\n                    }\n                    c_ := chr(add(_pOut, 1))\n                    // '\"', '\\', '//', 'b', 'f', 'n', 'r', 't'.\n                    if and(shr(sub(c_, 34), 0x510110400000000002001), 1) {\n                        _pOut := add(_pOut, 2)\n                        continue\n                    }\n                    // 'u'.\n                    if eq(c_, 117) {\n                        checkStringU(_pOut, 2)\n                        _pOut := add(_pOut, 6)\n                        continue\n                    }\n                    _pOut := end_\n                    break\n                }\n                if iszero(lt(_pOut, end_)) { fail() }\n                _pOut := add(_pOut, 1)\n            }\n\n            function skip0To9s(pIn_, end_, atLeastOne_) -> _pOut {\n                for { _pOut := pIn_ } 1 { _pOut := add(_pOut, 1) } {\n                    if iszero(lt(sub(chr(_pOut), 48), 10)) { break } // Not '0'..'9'.\n                }\n                if and(atLeastOne_, eq(pIn_, _pOut)) { fail() }\n            }\n\n            function parseNumber(s_, packed_, pIn_, end_) -> _item, _pOut {\n                _pOut := pIn_\n                if eq(chr(_pOut), 45) { _pOut := add(_pOut, 1) } // '-'.\n                if iszero(lt(sub(chr(_pOut), 48), 10)) { fail() } // Not '0'..'9'.\n                let c_ := chr(_pOut)\n                _pOut := add(_pOut, 1)\n                if iszero(eq(c_, 48)) { _pOut := skip0To9s(_pOut, end_, 0) } // Not '0'.\n                if eq(chr(_pOut), 46) { _pOut := skip0To9s(add(_pOut, 1), end_, 1) } // '.'.\n                let t_ := mload(_pOut)\n                // 'E', 'e'.\n                if eq(or(0x20, byte(0, t_)), 101) {\n                    // forgefmt: disable-next-item\n                    _pOut := skip0To9s(add(byte(sub(byte(1, t_), 14), 0x010001), // '+', '-'.\n                        add(_pOut, 1)), end_, 1)\n                }\n                _item := mallocItem(s_, packed_, pIn_, _pOut, TYPE_NUMBER)\n            }\n\n            function copyStr(s_, offset_, len_) -> _sCopy {\n                _sCopy := mload(0x40)\n                s_ := add(s_, offset_)\n                let w_ := not(0x1f)\n                for { let i_ := and(add(len_, 0x1f), w_) } 1 {} {\n                    mstore(add(_sCopy, i_), mload(add(s_, i_)))\n                    i_ := add(i_, w_) // `sub(i_, 0x20)`.\n                    if iszero(i_) { break }\n                }\n                mstore(_sCopy, len_) // Copy the length.\n                mstore(add(add(_sCopy, 0x20), len_), 0) // Zeroize the last slot.\n                mstore(0x40, add(add(_sCopy, 0x40), len_)) // Allocate memory.\n            }\n\n            function value(item_) -> _value {\n                let packed_ := mload(item_)\n                _value := getP(packed_, _BITPOS_VALUE) // The offset in the string.\n                if iszero(and(_VALUE_INITED, packed_)) {\n                    let s_ := getP(packed_, _BITPOS_STRING)\n                    _value := copyStr(s_, _value, getP(packed_, _BITPOS_VALUE_LENGTH))\n                    packed_ := setP(packed_, _BITPOS_VALUE, _value)\n                    mstore(s_, or(_VALUE_INITED, packed_))\n                }\n            }\n\n            function children(item_) -> _arr {\n                _arr := 0x60 // Initialize to the zero pointer.\n                let packed_ := mload(item_)\n                for {} iszero(gt(and(_BITMASK_TYPE, packed_), TYPE_OBJECT)) {} {\n                    if or(iszero(packed_), iszero(item_)) { break }\n                    if and(packed_, _CHILDREN_INITED) {\n                        _arr := getP(packed_, _BITPOS_CHILD)\n                        break\n                    }\n                    _arr := mload(0x40)\n                    let o_ := add(_arr, 0x20)\n                    for { let h_ := getP(packed_, _BITPOS_CHILD) } h_ {} {\n                        mstore(o_, h_)\n                        let q_ := mload(h_)\n                        let y_ := getP(q_, _BITPOS_SIBLING_OR_PARENT)\n                        mstore(h_, setP(q_, _BITPOS_SIBLING_OR_PARENT, item_))\n                        h_ := y_\n                        o_ := add(o_, 0x20)\n                    }\n                    let w_ := not(0x1f)\n                    let n_ := add(w_, sub(o_, _arr))\n                    mstore(_arr, shr(5, n_))\n                    mstore(0x40, o_) // Allocate memory.\n                    packed_ := setP(packed_, _BITPOS_CHILD, _arr)\n                    mstore(item_, or(_CHILDREN_INITED, packed_))\n                    // Reverse the array.\n                    if iszero(lt(n_, 0x40)) {\n                        let lo_ := add(_arr, 0x20)\n                        let hi_ := add(_arr, n_)\n                        for {} 1 {} {\n                            let temp_ := mload(lo_)\n                            mstore(lo_, mload(hi_))\n                            mstore(hi_, temp_)\n                            hi_ := add(hi_, w_)\n                            lo_ := add(lo_, 0x20)\n                            if iszero(lt(lo_, hi_)) { break }\n                        }\n                    }\n                    break\n                }\n            }\n\n            function getStr(item_, bitpos_, bitposLength_, bitmaskInited_) -> _result {\n                _result := 0x60 // Initialize to the zero pointer.\n                let packed_ := mload(item_)\n                if or(iszero(item_), iszero(packed_)) { leave }\n                _result := getP(packed_, bitpos_)\n                if iszero(and(bitmaskInited_, packed_)) {\n                    let s_ := getP(packed_, _BITPOS_STRING)\n                    _result := copyStr(s_, _result, getP(packed_, bitposLength_))\n                    mstore(item_, or(bitmaskInited_, setP(packed_, bitpos_, _result)))\n                }\n            }\n\n            switch mode\n            // Get value.\n            case 0 { result := getStr(input, _BITPOS_VALUE, _BITPOS_VALUE_LENGTH, _VALUE_INITED) }\n            // Get key.\n            case 1 { result := getStr(input, _BITPOS_KEY, _BITPOS_KEY_LENGTH, _KEY_INITED) }\n            // Get children.\n            case 3 { result := children(input) }\n            // Parse.\n            default {\n                let p := add(input, 0x20)\n                let e := add(p, mload(input))\n                if iszero(eq(p, e)) {\n                    let c := chr(e)\n                    mstore8(e, 34) // Place a '\"' at the end to speed up parsing.\n                    // The `34 << 248` makes `mallocItem` preserve '\"' at the end.\n                    mstore(0x00, setP(shl(248, 34), _BITPOS_STRING, input))\n                    result, p := parseValue(input, 0, p, e)\n                    mstore8(e, c) // Restore the original char at the end.\n                }\n                if or(lt(p, e), iszero(result)) { fail() }\n            }\n        }\n    }\n\n    /// @dev Casts the input to a bytes32.\n    function _toInput(string memory input) private pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := input\n        }\n    }\n\n    /// @dev Casts the input to a bytes32.\n    function _toInput(Item memory input) private pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := input\n        }\n    }\n}\n"
    },
    "solady/src/utils/LibString.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for converting numbers into strings and other string operations.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibString.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)\n///\n/// Note:\n/// For performance and bytecode compactness, most of the string operations are restricted to\n/// byte strings (7-bit ASCII), except where otherwise specified.\n/// Usage of byte string operations on charsets with runes spanning two or more bytes\n/// can lead to undefined behavior.\nlibrary LibString {\n    /*Â´:Â°â€¢.Â°+.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°â€¢.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°+.*â€¢Â´.*:*/\n    /*                        CUSTOM ERRORS                       */\n    /*.â€¢Â°:Â°.Â´+Ëš.*Â°.Ëš:*.Â´â€¢*.+Â°.â€¢Â°:Â´*.Â´â€¢*.â€¢Â°.â€¢Â°:Â°.Â´:â€¢ËšÂ°.*Â°.Ëš:*.Â´+Â°.â€¢*/\n\n    /// @dev The length of the output is too small to contain all the hex digits.\n    error HexLengthInsufficient();\n\n    /// @dev The length of the string is more than 32 bytes.\n    error TooBigForSmallString();\n\n    /*Â´:Â°â€¢.Â°+.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°â€¢.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°+.*â€¢Â´.*:*/\n    /*                         CONSTANTS                          */\n    /*.â€¢Â°:Â°.Â´+Ëš.*Â°.Ëš:*.Â´â€¢*.+Â°.â€¢Â°:Â´*.Â´â€¢*.â€¢Â°.â€¢Â°:Â°.Â´:â€¢ËšÂ°.*Â°.Ëš:*.Â´+Â°.â€¢*/\n\n    /// @dev The constant returned when the `search` is not found in the string.\n    uint256 internal constant NOT_FOUND = type(uint256).max;\n\n    /*Â´:Â°â€¢.Â°+.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°â€¢.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°+.*â€¢Â´.*:*/\n    /*                     DECIMAL OPERATIONS                     */\n    /*.â€¢Â°:Â°.Â´+Ëš.*Â°.Ëš:*.Â´â€¢*.+Â°.â€¢Â°:Â´*.Â´â€¢*.â€¢Â°.â€¢Â°:Â°.Â´:â€¢ËšÂ°.*Â°.Ëš:*.Â´+Â°.â€¢*/\n\n    /// @dev Returns the base 10 decimal representation of `value`.\n    function toString(uint256 value) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\n            // and 3 words for a maximum of 78 digits.\n            str := add(mload(0x40), 0x80)\n            // Update the free memory pointer to allocate.\n            mstore(0x40, add(str, 0x20))\n            // Zeroize the slot after the string.\n            mstore(str, 0)\n\n            // Cache the end of the memory to calculate the length later.\n            let end := str\n\n            let w := not(0) // Tsk.\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let temp := value } 1 {} {\n                str := add(str, w) // `sub(str, 1)`.\n                // Write the character to the pointer.\n                // The ASCII index of the '0' character is 48.\n                mstore8(str, add(48, mod(temp, 10)))\n                // Keep dividing `temp` until zero.\n                temp := div(temp, 10)\n                if iszero(temp) { break }\n            }\n\n            let length := sub(end, str)\n            // Move the pointer 32 bytes leftwards to make room for the length.\n            str := sub(str, 0x20)\n            // Store the length.\n            mstore(str, length)\n        }\n    }\n\n    /// @dev Returns the base 10 decimal representation of `value`.\n    function toString(int256 value) internal pure returns (string memory str) {\n        if (value >= 0) {\n            return toString(uint256(value));\n        }\n        unchecked {\n            str = toString(~uint256(value) + 1);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We still have some spare memory space on the left,\n            // as we have allocated 3 words (96 bytes) for up to 78 digits.\n            let length := mload(str) // Load the string length.\n            mstore(str, 0x2d) // Store the '-' character.\n            str := sub(str, 1) // Move back the string pointer by a byte.\n            mstore(str, add(length, 1)) // Update the string length.\n        }\n    }\n\n    /*Â´:Â°â€¢.Â°+.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°â€¢.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°+.*â€¢Â´.*:*/\n    /*                   HEXADECIMAL OPERATIONS                   */\n    /*.â€¢Â°:Â°.Â´+Ëš.*Â°.Ëš:*.Â´â€¢*.+Â°.â€¢Â°:Â´*.Â´â€¢*.â€¢Â°.â€¢Â°:Â°.Â´:â€¢ËšÂ°.*Â°.Ëš:*.Â´+Â°.â€¢*/\n\n    /// @dev Returns the hexadecimal representation of `value`,\n    /// left-padded to an input length of `length` bytes.\n    /// The output is prefixed with \"0x\" encoded using 2 hexadecimal digits per byte,\n    /// giving a total length of `length * 2 + 2` bytes.\n    /// Reverts if `length` is too small for the output to contain all the digits.\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value, length);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Write the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`,\n    /// left-padded to an input length of `length` bytes.\n    /// The output is prefixed with \"0x\" encoded using 2 hexadecimal digits per byte,\n    /// giving a total length of `length * 2` bytes.\n    /// Reverts if `length` is too small for the output to contain all the digits.\n    function toHexStringNoPrefix(uint256 value, uint256 length)\n        internal\n        pure\n        returns (string memory str)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes\n            // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.\n            // We add 0x20 to the total and round down to a multiple of 0x20.\n            // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.\n            str := add(mload(0x40), and(add(shl(1, length), 0x42), not(0x1f)))\n            // Allocate the memory.\n            mstore(0x40, add(str, 0x20))\n            // Zeroize the slot after the string.\n            mstore(str, 0)\n\n            // Cache the end to calculate the length later.\n            let end := str\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            let start := sub(str, add(length, length))\n            let w := not(1) // Tsk.\n            let temp := value\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for {} 1 {} {\n                str := add(str, w) // `sub(str, 2)`.\n                mstore8(add(str, 1), mload(and(temp, 15)))\n                mstore8(str, mload(and(shr(4, temp), 15)))\n                temp := shr(8, temp)\n                if iszero(xor(str, start)) { break }\n            }\n\n            if temp {\n                mstore(0x00, 0x2194895a) // `HexLengthInsufficient()`.\n                revert(0x1c, 0x04)\n            }\n\n            // Compute the string's length.\n            let strLength := sub(end, str)\n            // Move the pointer and write the length.\n            str := sub(str, 0x20)\n            mstore(str, strLength)\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.\n    /// As address are 20 bytes long, the output will left-padded to have\n    /// a length of `20 * 2 + 2` bytes.\n    function toHexString(uint256 value) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Write the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\".\n    /// The output excludes leading \"0\" from the `toHexString` output.\n    /// `0x00: \"0x0\", 0x01: \"0x1\", 0x12: \"0x12\", 0x123: \"0x123\"`.\n    function toMinimalHexString(uint256 value) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(add(str, o), 0x3078) // Write the \"0x\" prefix, accounting for leading zero.\n            str := sub(add(str, o), 2) // Move the pointer, accounting for leading zero.\n            mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output excludes leading \"0\" from the `toHexStringNoPrefix` output.\n    /// `0x00: \"0\", 0x01: \"1\", 0x12: \"12\", 0x123: \"123\"`.\n    function toMinimalHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\n            let strLength := mload(str) // Get the length.\n            str := add(str, o) // Move the pointer, accounting for leading zero.\n            mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    /// As address are 20 bytes long, the output will left-padded to have\n    /// a length of `20 * 2` bytes.\n    function toHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\n            // 0x02 bytes for the prefix, and 0x40 bytes for the digits.\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.\n            str := add(mload(0x40), 0x80)\n            // Allocate the memory.\n            mstore(0x40, add(str, 0x20))\n            // Zeroize the slot after the string.\n            mstore(str, 0)\n\n            // Cache the end to calculate the length later.\n            let end := str\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            let w := not(1) // Tsk.\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let temp := value } 1 {} {\n                str := add(str, w) // `sub(str, 2)`.\n                mstore8(add(str, 1), mload(and(temp, 15)))\n                mstore8(str, mload(and(shr(4, temp), 15)))\n                temp := shr(8, temp)\n                if iszero(temp) { break }\n            }\n\n            // Compute the string's length.\n            let strLength := sub(end, str)\n            // Move the pointer and write the length.\n            str := sub(str, 0x20)\n            mstore(str, strLength)\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\", encoded using 2 hexadecimal digits per byte,\n    /// and the alphabets are capitalized conditionally according to\n    /// https://eips.ethereum.org/EIPS/eip-55\n    function toHexStringChecksummed(address value) internal pure returns (string memory str) {\n        str = toHexString(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`\n            let o := add(str, 0x22)\n            let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `\n            let t := shl(240, 136) // `0b10001000 << 240`\n            for { let i := 0 } 1 {} {\n                mstore(add(i, i), mul(t, byte(i, hashed)))\n                i := add(i, 1)\n                if eq(i, 20) { break }\n            }\n            mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))\n            o := add(o, 0x20)\n            mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.\n    function toHexString(address value) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Write the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    function toHexStringNoPrefix(address value) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            str := mload(0x40)\n\n            // Allocate the memory.\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\n            // 0x02 bytes for the prefix, and 0x28 bytes for the digits.\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.\n            mstore(0x40, add(str, 0x80))\n\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            str := add(str, 2)\n            mstore(str, 40)\n\n            let o := add(str, 0x20)\n            mstore(add(o, 40), 0)\n\n            value := shl(96, value)\n\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let i := 0 } 1 {} {\n                let p := add(o, add(i, i))\n                let temp := byte(i, value)\n                mstore8(add(p, 1), mload(and(temp, 15)))\n                mstore8(p, mload(shr(4, temp)))\n                i := add(i, 1)\n                if eq(i, 20) { break }\n            }\n        }\n    }\n\n    /// @dev Returns the hex encoded string from the raw bytes.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    function toHexString(bytes memory raw) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(raw);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Write the length.\n        }\n    }\n\n    /// @dev Returns the hex encoded string from the raw bytes.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    function toHexStringNoPrefix(bytes memory raw) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let length := mload(raw)\n            str := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.\n            mstore(str, add(length, length)) // Store the length of the output.\n\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            let o := add(str, 0x20)\n            let end := add(raw, length)\n\n            for {} iszero(eq(raw, end)) {} {\n                raw := add(raw, 1)\n                mstore8(add(o, 1), mload(and(mload(raw), 15)))\n                mstore8(o, mload(and(shr(4, mload(raw)), 15)))\n                o := add(o, 2)\n            }\n            mstore(o, 0) // Zeroize the slot after the string.\n            mstore(0x40, add(o, 0x20)) // Allocate the memory.\n        }\n    }\n\n    /*Â´:Â°â€¢.Â°+.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°â€¢.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°+.*â€¢Â´.*:*/\n    /*                   RUNE STRING OPERATIONS                   */\n    /*.â€¢Â°:Â°.Â´+Ëš.*Â°.Ëš:*.Â´â€¢*.+Â°.â€¢Â°:Â´*.Â´â€¢*.â€¢Â°.â€¢Â°:Â°.Â´:â€¢ËšÂ°.*Â°.Ëš:*.Â´+Â°.â€¢*/\n\n    /// @dev Returns the number of UTF characters in the string.\n    function runeCount(string memory s) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mload(s) {\n                mstore(0x00, div(not(0), 255))\n                mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)\n                let o := add(s, 0x20)\n                let end := add(o, mload(s))\n                for { result := 1 } 1 { result := add(result, 1) } {\n                    o := add(o, byte(0, mload(shr(250, mload(o)))))\n                    if iszero(lt(o, end)) { break }\n                }\n            }\n        }\n    }\n\n    /// @dev Returns if this string is a 7-bit ASCII string.\n    /// (i.e. all characters codes are in [0..127])\n    function is7BitASCII(string memory s) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let mask := shl(7, div(not(0), 255))\n            result := 1\n            let n := mload(s)\n            if n {\n                let o := add(s, 0x20)\n                let end := add(o, n)\n                let last := mload(end)\n                mstore(end, 0)\n                for {} 1 {} {\n                    if and(mask, mload(o)) {\n                        result := 0\n                        break\n                    }\n                    o := add(o, 0x20)\n                    if iszero(lt(o, end)) { break }\n                }\n                mstore(end, last)\n            }\n        }\n    }\n\n    /*Â´:Â°â€¢.Â°+.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°â€¢.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°+.*â€¢Â´.*:*/\n    /*                   BYTE STRING OPERATIONS                   */\n    /*.â€¢Â°:Â°.Â´+Ëš.*Â°.Ëš:*.Â´â€¢*.+Â°.â€¢Â°:Â´*.Â´â€¢*.â€¢Â°.â€¢Â°:Â°.Â´:â€¢ËšÂ°.*Â°.Ëš:*.Â´+Â°.â€¢*/\n\n    // For performance and bytecode compactness, byte string operations are restricted\n    // to 7-bit ASCII strings. All offsets are byte offsets, not UTF character offsets.\n    // Usage of byte string operations on charsets with runes spanning two or more bytes\n    // can lead to undefined behavior.\n\n    /// @dev Returns `subject` all occurrences of `search` replaced with `replacement`.\n    function replace(string memory subject, string memory search, string memory replacement)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            let searchLength := mload(search)\n            let replacementLength := mload(replacement)\n\n            subject := add(subject, 0x20)\n            search := add(search, 0x20)\n            replacement := add(replacement, 0x20)\n            result := add(mload(0x40), 0x20)\n\n            let subjectEnd := add(subject, subjectLength)\n            if iszero(gt(searchLength, subjectLength)) {\n                let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)\n                let h := 0\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\n                let s := mload(search)\n                for {} 1 {} {\n                    let t := mload(subject)\n                    // Whether the first `searchLength % 32` bytes of\n                    // `subject` and `search` matches.\n                    if iszero(shr(m, xor(t, s))) {\n                        if h {\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\n                                mstore(result, t)\n                                result := add(result, 1)\n                                subject := add(subject, 1)\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\n                                continue\n                            }\n                        }\n                        // Copy the `replacement` one word at a time.\n                        for { let o := 0 } 1 {} {\n                            mstore(add(result, o), mload(add(replacement, o)))\n                            o := add(o, 0x20)\n                            if iszero(lt(o, replacementLength)) { break }\n                        }\n                        result := add(result, replacementLength)\n                        subject := add(subject, searchLength)\n                        if searchLength {\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\n                            continue\n                        }\n                    }\n                    mstore(result, t)\n                    result := add(result, 1)\n                    subject := add(subject, 1)\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\n                }\n            }\n\n            let resultRemainder := result\n            result := add(mload(0x40), 0x20)\n            let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))\n            // Copy the rest of the string one word at a time.\n            for {} lt(subject, subjectEnd) {} {\n                mstore(resultRemainder, mload(subject))\n                resultRemainder := add(resultRemainder, 0x20)\n                subject := add(subject, 0x20)\n            }\n            result := sub(result, 0x20)\n            let last := add(add(result, 0x20), k) // Zeroize the slot after the string.\n            mstore(last, 0)\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\n            mstore(result, k) // Store the length.\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from left to right, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function indexOf(string memory subject, string memory search, uint256 from)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { let subjectLength := mload(subject) } 1 {} {\n                if iszero(mload(search)) {\n                    if iszero(gt(from, subjectLength)) {\n                        result := from\n                        break\n                    }\n                    result := subjectLength\n                    break\n                }\n                let searchLength := mload(search)\n                let subjectStart := add(subject, 0x20)\n\n                result := not(0) // Initialize to `NOT_FOUND`.\n\n                subject := add(subjectStart, from)\n                let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)\n\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\n                let s := mload(add(search, 0x20))\n\n                if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }\n\n                if iszero(lt(searchLength, 0x20)) {\n                    for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\n                        if iszero(shr(m, xor(mload(subject), s))) {\n                            if eq(keccak256(subject, searchLength), h) {\n                                result := sub(subject, subjectStart)\n                                break\n                            }\n                        }\n                        subject := add(subject, 1)\n                        if iszero(lt(subject, end)) { break }\n                    }\n                    break\n                }\n                for {} 1 {} {\n                    if iszero(shr(m, xor(mload(subject), s))) {\n                        result := sub(subject, subjectStart)\n                        break\n                    }\n                    subject := add(subject, 1)\n                    if iszero(lt(subject, end)) { break }\n                }\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from left to right.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function indexOf(string memory subject, string memory search)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = indexOf(subject, search, 0);\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from right to left, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function lastIndexOf(string memory subject, string memory search, uint256 from)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} 1 {} {\n                result := not(0) // Initialize to `NOT_FOUND`.\n                let searchLength := mload(search)\n                if gt(searchLength, mload(subject)) { break }\n                let w := result\n\n                let fromMax := sub(mload(subject), searchLength)\n                if iszero(gt(fromMax, from)) { from := fromMax }\n\n                let end := add(add(subject, 0x20), w)\n                subject := add(add(subject, 0x20), from)\n                if iszero(gt(subject, end)) { break }\n                // As this function is not too often used,\n                // we shall simply use keccak256 for smaller bytecode size.\n                for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\n                    if eq(keccak256(subject, searchLength), h) {\n                        result := sub(subject, add(end, 1))\n                        break\n                    }\n                    subject := add(subject, w) // `sub(subject, 1)`.\n                    if iszero(gt(subject, end)) { break }\n                }\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from right to left.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function lastIndexOf(string memory subject, string memory search)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = lastIndexOf(subject, search, uint256(int256(-1)));\n    }\n\n    /// @dev Returns true if `search` is found in `subject`, false otherwise.\n    function contains(string memory subject, string memory search) internal pure returns (bool) {\n        return indexOf(subject, search) != NOT_FOUND;\n    }\n\n    /// @dev Returns whether `subject` starts with `search`.\n    function startsWith(string memory subject, string memory search)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let searchLength := mload(search)\n            // Just using keccak256 directly is actually cheaper.\n            // forgefmt: disable-next-item\n            result := and(\n                iszero(gt(searchLength, mload(subject))),\n                eq(\n                    keccak256(add(subject, 0x20), searchLength),\n                    keccak256(add(search, 0x20), searchLength)\n                )\n            )\n        }\n    }\n\n    /// @dev Returns whether `subject` ends with `search`.\n    function endsWith(string memory subject, string memory search)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let searchLength := mload(search)\n            let subjectLength := mload(subject)\n            // Whether `search` is not longer than `subject`.\n            let withinRange := iszero(gt(searchLength, subjectLength))\n            // Just using keccak256 directly is actually cheaper.\n            // forgefmt: disable-next-item\n            result := and(\n                withinRange,\n                eq(\n                    keccak256(\n                        // `subject + 0x20 + max(subjectLength - searchLength, 0)`.\n                        add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),\n                        searchLength\n                    ),\n                    keccak256(add(search, 0x20), searchLength)\n                )\n            )\n        }\n    }\n\n    /// @dev Returns `subject` repeated `times`.\n    function repeat(string memory subject, uint256 times)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            if iszero(or(iszero(times), iszero(subjectLength))) {\n                subject := add(subject, 0x20)\n                result := mload(0x40)\n                let output := add(result, 0x20)\n                for {} 1 {} {\n                    // Copy the `subject` one word at a time.\n                    for { let o := 0 } 1 {} {\n                        mstore(add(output, o), mload(add(subject, o)))\n                        o := add(o, 0x20)\n                        if iszero(lt(o, subjectLength)) { break }\n                    }\n                    output := add(output, subjectLength)\n                    times := sub(times, 1)\n                    if iszero(times) { break }\n                }\n                mstore(output, 0) // Zeroize the slot after the string.\n                let resultLength := sub(output, add(result, 0x20))\n                mstore(result, resultLength) // Store the length.\n                // Allocate the memory.\n                mstore(0x40, add(result, add(resultLength, 0x20)))\n            }\n        }\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets.\n    function slice(string memory subject, uint256 start, uint256 end)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            if iszero(gt(subjectLength, end)) { end := subjectLength }\n            if iszero(gt(subjectLength, start)) { start := subjectLength }\n            if lt(start, end) {\n                result := mload(0x40)\n                let resultLength := sub(end, start)\n                mstore(result, resultLength)\n                subject := add(subject, start)\n                let w := not(0x1f)\n                // Copy the `subject` one word at a time, backwards.\n                for { let o := and(add(resultLength, 0x1f), w) } 1 {} {\n                    mstore(add(result, o), mload(add(subject, o)))\n                    o := add(o, w) // `sub(o, 0x20)`.\n                    if iszero(o) { break }\n                }\n                // Zeroize the slot after the string.\n                mstore(add(add(result, 0x20), resultLength), 0)\n                // Allocate memory for the length and the bytes,\n                // rounded up to a multiple of 32.\n                mstore(0x40, add(result, and(add(resultLength, 0x3f), w)))\n            }\n        }\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the string.\n    /// `start` is a byte offset.\n    function slice(string memory subject, uint256 start)\n        internal\n        pure\n        returns (string memory result)\n    {\n        result = slice(subject, start, uint256(int256(-1)));\n    }\n\n    /// @dev Returns all the indices of `search` in `subject`.\n    /// The indices are byte offsets.\n    function indicesOf(string memory subject, string memory search)\n        internal\n        pure\n        returns (uint256[] memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            let searchLength := mload(search)\n\n            if iszero(gt(searchLength, subjectLength)) {\n                subject := add(subject, 0x20)\n                search := add(search, 0x20)\n                result := add(mload(0x40), 0x20)\n\n                let subjectStart := subject\n                let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)\n                let h := 0\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\n                let s := mload(search)\n                for {} 1 {} {\n                    let t := mload(subject)\n                    // Whether the first `searchLength % 32` bytes of\n                    // `subject` and `search` matches.\n                    if iszero(shr(m, xor(t, s))) {\n                        if h {\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\n                                subject := add(subject, 1)\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\n                                continue\n                            }\n                        }\n                        // Append to `result`.\n                        mstore(result, sub(subject, subjectStart))\n                        result := add(result, 0x20)\n                        // Advance `subject` by `searchLength`.\n                        subject := add(subject, searchLength)\n                        if searchLength {\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\n                            continue\n                        }\n                    }\n                    subject := add(subject, 1)\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\n                }\n                let resultEnd := result\n                // Assign `result` to the free memory pointer.\n                result := mload(0x40)\n                // Store the length of `result`.\n                mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))\n                // Allocate memory for result.\n                // We allocate one more word, so this array can be recycled for {split}.\n                mstore(0x40, add(resultEnd, 0x20))\n            }\n        }\n    }\n\n    /// @dev Returns a arrays of strings based on the `delimiter` inside of the `subject` string.\n    function split(string memory subject, string memory delimiter)\n        internal\n        pure\n        returns (string[] memory result)\n    {\n        uint256[] memory indices = indicesOf(subject, delimiter);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(0x1f)\n            let indexPtr := add(indices, 0x20)\n            let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))\n            mstore(add(indicesEnd, w), mload(subject))\n            mstore(indices, add(mload(indices), 1))\n            let prevIndex := 0\n            for {} 1 {} {\n                let index := mload(indexPtr)\n                mstore(indexPtr, 0x60)\n                if iszero(eq(index, prevIndex)) {\n                    let element := mload(0x40)\n                    let elementLength := sub(index, prevIndex)\n                    mstore(element, elementLength)\n                    // Copy the `subject` one word at a time, backwards.\n                    for { let o := and(add(elementLength, 0x1f), w) } 1 {} {\n                        mstore(add(element, o), mload(add(add(subject, prevIndex), o)))\n                        o := add(o, w) // `sub(o, 0x20)`.\n                        if iszero(o) { break }\n                    }\n                    // Zeroize the slot after the string.\n                    mstore(add(add(element, 0x20), elementLength), 0)\n                    // Allocate memory for the length and the bytes,\n                    // rounded up to a multiple of 32.\n                    mstore(0x40, add(element, and(add(elementLength, 0x3f), w)))\n                    // Store the `element` into the array.\n                    mstore(indexPtr, element)\n                }\n                prevIndex := add(index, mload(delimiter))\n                indexPtr := add(indexPtr, 0x20)\n                if iszero(lt(indexPtr, indicesEnd)) { break }\n            }\n            result := indices\n            if iszero(mload(delimiter)) {\n                result := add(indices, 0x20)\n                mstore(result, sub(mload(indices), 2))\n            }\n        }\n    }\n\n    /// @dev Returns a concatenated string of `a` and `b`.\n    /// Cheaper than `string.concat()` and does not de-align the free memory pointer.\n    function concat(string memory a, string memory b)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(0x1f)\n            result := mload(0x40)\n            let aLength := mload(a)\n            // Copy `a` one word at a time, backwards.\n            for { let o := and(add(aLength, 0x20), w) } 1 {} {\n                mstore(add(result, o), mload(add(a, o)))\n                o := add(o, w) // `sub(o, 0x20)`.\n                if iszero(o) { break }\n            }\n            let bLength := mload(b)\n            let output := add(result, aLength)\n            // Copy `b` one word at a time, backwards.\n            for { let o := and(add(bLength, 0x20), w) } 1 {} {\n                mstore(add(output, o), mload(add(b, o)))\n                o := add(o, w) // `sub(o, 0x20)`.\n                if iszero(o) { break }\n            }\n            let totalLength := add(aLength, bLength)\n            let last := add(add(result, 0x20), totalLength)\n            // Zeroize the slot after the string.\n            mstore(last, 0)\n            // Stores the length.\n            mstore(result, totalLength)\n            // Allocate memory for the length and the bytes,\n            // rounded up to a multiple of 32.\n            mstore(0x40, and(add(last, 0x1f), w))\n        }\n    }\n\n    /// @dev Returns a copy of the string in either lowercase or UPPERCASE.\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\n    function toCase(string memory subject, bool toUpper)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let length := mload(subject)\n            if length {\n                result := add(mload(0x40), 0x20)\n                subject := add(subject, 1)\n                let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)\n                let w := not(0)\n                for { let o := length } 1 {} {\n                    o := add(o, w)\n                    let b := and(0xff, mload(add(subject, o)))\n                    mstore8(add(result, o), xor(b, and(shr(b, flags), 0x20)))\n                    if iszero(o) { break }\n                }\n                result := mload(0x40)\n                mstore(result, length) // Store the length.\n                let last := add(add(result, 0x20), length)\n                mstore(last, 0) // Zeroize the slot after the string.\n                mstore(0x40, add(last, 0x20)) // Allocate the memory.\n            }\n        }\n    }\n\n    /// @dev Returns a string from a small bytes32 string.\n    /// `s` must be null-terminated, or behavior will be undefined.\n    function fromSmallString(bytes32 s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let n := 0\n            for {} byte(n, s) { n := add(n, 1) } {} // Scan for '\\0'.\n            mstore(result, n)\n            let o := add(result, 0x20)\n            mstore(o, s)\n            mstore(add(o, n), 0)\n            mstore(0x40, add(result, 0x40))\n        }\n    }\n\n    /// @dev Returns the small string, with all bytes after the first null byte zeroized.\n    function normalizeSmallString(bytes32 s) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} byte(result, s) { result := add(result, 1) } {} // Scan for '\\0'.\n            mstore(0x00, s)\n            mstore(result, 0x00)\n            result := mload(0x00)\n        }\n    }\n\n    /// @dev Returns the string as a normalized null-terminated small string.\n    function toSmallString(string memory s) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(s)\n            if iszero(lt(result, 33)) {\n                mstore(0x00, 0xec92f9a3) // `TooBigForSmallString()`.\n                revert(0x1c, 0x04)\n            }\n            result := shl(shl(3, sub(32, result)), mload(add(s, result)))\n        }\n    }\n\n    /// @dev Returns a lowercased copy of the string.\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\n    function lower(string memory subject) internal pure returns (string memory result) {\n        result = toCase(subject, false);\n    }\n\n    /// @dev Returns an UPPERCASED copy of the string.\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\n    function upper(string memory subject) internal pure returns (string memory result) {\n        result = toCase(subject, true);\n    }\n\n    /// @dev Escapes the string to be used within HTML tags.\n    function escapeHTML(string memory s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let end := add(s, mload(s))\n            result := add(mload(0x40), 0x20)\n            // Store the bytes of the packed offsets and strides into the scratch space.\n            // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.\n            mstore(0x1f, 0x900094)\n            mstore(0x08, 0xc0000000a6ab)\n            // Store \"&quot;&amp;&#39;&lt;&gt;\" into the scratch space.\n            mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))\n            for {} iszero(eq(s, end)) {} {\n                s := add(s, 1)\n                let c := and(mload(s), 0xff)\n                // Not in `[\"\\\"\",\"'\",\"&\",\"<\",\">\"]`.\n                if iszero(and(shl(c, 1), 0x500000c400000000)) {\n                    mstore8(result, c)\n                    result := add(result, 1)\n                    continue\n                }\n                let t := shr(248, mload(c))\n                mstore(result, mload(and(t, 0x1f)))\n                result := add(result, shr(5, t))\n            }\n            let last := result\n            mstore(last, 0) // Zeroize the slot after the string.\n            result := mload(0x40)\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\n        }\n    }\n\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\n    /// If `addDoubleQuotes` is true, the result will be enclosed in double-quotes.\n    function escapeJSON(string memory s, bool addDoubleQuotes)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let end := add(s, mload(s))\n            result := add(mload(0x40), 0x20)\n            if addDoubleQuotes {\n                mstore8(result, 34)\n                result := add(1, result)\n            }\n            // Store \"\\\\u0000\" in scratch space.\n            // Store \"0123456789abcdef\" in scratch space.\n            // Also, store `{0x08:\"b\", 0x09:\"t\", 0x0a:\"n\", 0x0c:\"f\", 0x0d:\"r\"}`.\n            // into the scratch space.\n            mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)\n            // Bitmask for detecting `[\"\\\"\",\"\\\\\"]`.\n            let e := or(shl(0x22, 1), shl(0x5c, 1))\n            for {} iszero(eq(s, end)) {} {\n                s := add(s, 1)\n                let c := and(mload(s), 0xff)\n                if iszero(lt(c, 0x20)) {\n                    if iszero(and(shl(c, 1), e)) {\n                        // Not in `[\"\\\"\",\"\\\\\"]`.\n                        mstore8(result, c)\n                        result := add(result, 1)\n                        continue\n                    }\n                    mstore8(result, 0x5c) // \"\\\\\".\n                    mstore8(add(result, 1), c)\n                    result := add(result, 2)\n                    continue\n                }\n                if iszero(and(shl(c, 1), 0x3700)) {\n                    // Not in `[\"\\b\",\"\\t\",\"\\n\",\"\\f\",\"\\d\"]`.\n                    mstore8(0x1d, mload(shr(4, c))) // Hex value.\n                    mstore8(0x1e, mload(and(c, 15))) // Hex value.\n                    mstore(result, mload(0x19)) // \"\\\\u00XX\".\n                    result := add(result, 6)\n                    continue\n                }\n                mstore8(result, 0x5c) // \"\\\\\".\n                mstore8(add(result, 1), mload(add(c, 8)))\n                result := add(result, 2)\n            }\n            if addDoubleQuotes {\n                mstore8(result, 34)\n                result := add(1, result)\n            }\n            let last := result\n            mstore(last, 0) // Zeroize the slot after the string.\n            result := mload(0x40)\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\n        }\n    }\n\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\n    function escapeJSON(string memory s) internal pure returns (string memory result) {\n        result = escapeJSON(s, false);\n    }\n\n    /// @dev Returns whether `a` equals `b`.\n    function eq(string memory a, string memory b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))\n        }\n    }\n\n    /// @dev Returns whether `a` equals `b`, where `b` is a null-terminated small string.\n    function eqs(string memory a, bytes32 b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // These should be evaluated on compile time, as far as possible.\n            let m := not(shl(7, div(not(iszero(b)), 255))) // `0x7f7f ...`.\n            let x := not(or(m, or(b, add(m, and(b, m)))))\n            let r := shl(7, iszero(iszero(shr(128, x))))\n            r := or(r, shl(6, iszero(iszero(shr(64, shr(r, x))))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            result := gt(eq(mload(a), add(iszero(x), xor(31, shr(3, r)))),\n                xor(shr(add(8, r), b), shr(add(8, r), mload(add(a, 0x20)))))\n        }\n    }\n\n    /// @dev Packs a single string with its length into a single word.\n    /// Returns `bytes32(0)` if the length is zero or greater than 31.\n    function packOne(string memory a) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We don't need to zero right pad the string,\n            // since this is our own custom non-standard packing scheme.\n            result :=\n                mul(\n                    // Load the length and the bytes.\n                    mload(add(a, 0x1f)),\n                    // `length != 0 && length < 32`. Abuses underflow.\n                    // Assumes that the length is valid and within the block gas limit.\n                    lt(sub(mload(a), 1), 0x1f)\n                )\n        }\n    }\n\n    /// @dev Unpacks a string packed using {packOne}.\n    /// Returns the empty string if `packed` is `bytes32(0)`.\n    /// If `packed` is not an output of {packOne}, the output behavior is undefined.\n    function unpackOne(bytes32 packed) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Grab the free memory pointer.\n            result := mload(0x40)\n            // Allocate 2 words (1 for the length, 1 for the bytes).\n            mstore(0x40, add(result, 0x40))\n            // Zeroize the length slot.\n            mstore(result, 0)\n            // Store the length and bytes.\n            mstore(add(result, 0x1f), packed)\n            // Right pad with zeroes.\n            mstore(add(add(result, 0x20), mload(result)), 0)\n        }\n    }\n\n    /// @dev Packs two strings with their lengths into a single word.\n    /// Returns `bytes32(0)` if combined length is zero or greater than 30.\n    function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let aLength := mload(a)\n            // We don't need to zero right pad the strings,\n            // since this is our own custom non-standard packing scheme.\n            result :=\n                mul(\n                    // Load the length and the bytes of `a` and `b`.\n                    or(\n                        shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))),\n                        mload(sub(add(b, 0x1e), aLength))\n                    ),\n                    // `totalLength != 0 && totalLength < 31`. Abuses underflow.\n                    // Assumes that the lengths are valid and within the block gas limit.\n                    lt(sub(add(aLength, mload(b)), 1), 0x1e)\n                )\n        }\n    }\n\n    /// @dev Unpacks strings packed using {packTwo}.\n    /// Returns the empty strings if `packed` is `bytes32(0)`.\n    /// If `packed` is not an output of {packTwo}, the output behavior is undefined.\n    function unpackTwo(bytes32 packed)\n        internal\n        pure\n        returns (string memory resultA, string memory resultB)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Grab the free memory pointer.\n            resultA := mload(0x40)\n            resultB := add(resultA, 0x40)\n            // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.\n            mstore(0x40, add(resultB, 0x40))\n            // Zeroize the length slots.\n            mstore(resultA, 0)\n            mstore(resultB, 0)\n            // Store the lengths and bytes.\n            mstore(add(resultA, 0x1f), packed)\n            mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))\n            // Right pad with zeroes.\n            mstore(add(add(resultA, 0x20), mload(resultA)), 0)\n            mstore(add(add(resultB, 0x20), mload(resultB)), 0)\n        }\n    }\n\n    /// @dev Directly returns `a` without copying.\n    function directReturn(string memory a) internal pure {\n        assembly {\n            // Assumes that the string does not start from the scratch space.\n            let retStart := sub(a, 0x20)\n            let retSize := add(mload(a), 0x40)\n            // Right pad with zeroes. Just in case the string is produced\n            // by a method that doesn't zero right pad.\n            mstore(add(retStart, retSize), 0)\n            // Store the return offset.\n            mstore(retStart, 0x20)\n            // End the transaction, returning the string.\n            return(retStart, retSize)\n        }\n    }\n}\n"
    },
    "solidity-rlp/contracts/RLPReader.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * @author Hamdi Allam hamdi.allam97@gmail.com\n * Please reach out with any questions or concerns\n */\npragma solidity >=0.5.10 <0.9.0;\n\nlibrary RLPReader {\n    uint8 constant STRING_SHORT_START = 0x80;\n    uint8 constant STRING_LONG_START = 0xb8;\n    uint8 constant LIST_SHORT_START = 0xc0;\n    uint8 constant LIST_LONG_START = 0xf8;\n    uint8 constant WORD_SIZE = 32;\n\n    struct RLPItem {\n        uint256 len;\n        uint256 memPtr;\n    }\n\n    struct Iterator {\n        RLPItem item; // Item that's being iterated over.\n        uint256 nextPtr; // Position of the next item in the list.\n    }\n\n    /*\n     * @dev Returns the next element in the iteration. Reverts if it has not next element.\n     * @param self The iterator.\n     * @return The next element in the iteration.\n     */\n    function next(Iterator memory self) internal pure returns (RLPItem memory) {\n        require(hasNext(self));\n\n        uint256 ptr = self.nextPtr;\n        uint256 itemLength = _itemLength(ptr);\n        self.nextPtr = ptr + itemLength;\n\n        return RLPItem(itemLength, ptr);\n    }\n\n    /*\n     * @dev Returns true if the iteration has more elements.\n     * @param self The iterator.\n     * @return true if the iteration has more elements.\n     */\n    function hasNext(Iterator memory self) internal pure returns (bool) {\n        RLPItem memory item = self.item;\n        return self.nextPtr < item.memPtr + item.len;\n    }\n\n    /*\n     * @param item RLP encoded bytes\n     */\n    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\n        uint256 memPtr;\n        assembly {\n            memPtr := add(item, 0x20)\n        }\n\n        return RLPItem(item.length, memPtr);\n    }\n\n    /*\n     * @dev Create an iterator. Reverts if item is not a list.\n     * @param self The RLP item.\n     * @return An 'Iterator' over the item.\n     */\n    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {\n        require(isList(self));\n\n        uint256 ptr = self.memPtr + _payloadOffset(self.memPtr);\n        return Iterator(self, ptr);\n    }\n\n    /*\n     * @param the RLP item.\n     */\n    function rlpLen(RLPItem memory item) internal pure returns (uint256) {\n        return item.len;\n    }\n\n    /*\n     * @param the RLP item.\n     * @return (memPtr, len) pair: location of the item's payload in memory.\n     */\n    function payloadLocation(RLPItem memory item) internal pure returns (uint256, uint256) {\n        uint256 offset = _payloadOffset(item.memPtr);\n        uint256 memPtr = item.memPtr + offset;\n        uint256 len = item.len - offset; // data length\n        return (memPtr, len);\n    }\n\n    /*\n     * @param the RLP item.\n     */\n    function payloadLen(RLPItem memory item) internal pure returns (uint256) {\n        (, uint256 len) = payloadLocation(item);\n        return len;\n    }\n\n    /*\n     * @param the RLP item containing the encoded list.\n     */\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {\n        require(isList(item));\n\n        uint256 items = numItems(item);\n        RLPItem[] memory result = new RLPItem[](items);\n\n        uint256 memPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint256 dataLen;\n        for (uint256 i = 0; i < items; i++) {\n            dataLen = _itemLength(memPtr);\n            result[i] = RLPItem(dataLen, memPtr);\n            memPtr = memPtr + dataLen;\n        }\n\n        return result;\n    }\n\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\n    function isList(RLPItem memory item) internal pure returns (bool) {\n        if (item.len == 0) return false;\n\n        uint8 byte0;\n        uint256 memPtr = item.memPtr;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < LIST_SHORT_START) return false;\n        return true;\n    }\n\n    /*\n     * @dev A cheaper version of keccak256(toRlpBytes(item)) that avoids copying memory.\n     * @return keccak256 hash of RLP encoded bytes.\n     */\n    function rlpBytesKeccak256(RLPItem memory item) internal pure returns (bytes32) {\n        uint256 ptr = item.memPtr;\n        uint256 len = item.len;\n        bytes32 result;\n        assembly {\n            result := keccak256(ptr, len)\n        }\n        return result;\n    }\n\n    /*\n     * @dev A cheaper version of keccak256(toBytes(item)) that avoids copying memory.\n     * @return keccak256 hash of the item payload.\n     */\n    function payloadKeccak256(RLPItem memory item) internal pure returns (bytes32) {\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\n        bytes32 result;\n        assembly {\n            result := keccak256(memPtr, len)\n        }\n        return result;\n    }\n\n    /** RLPItem conversions into data types **/\n\n    // @returns raw rlp encoding in bytes\n    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {\n        bytes memory result = new bytes(item.len);\n        if (result.length == 0) return result;\n\n        uint256 ptr;\n        assembly {\n            ptr := add(0x20, result)\n        }\n\n        copy(item.memPtr, ptr, item.len);\n        return result;\n    }\n\n    // any non-zero byte except \"0x80\" is considered true\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\n        require(item.len == 1);\n        uint256 result;\n        uint256 memPtr = item.memPtr;\n        assembly {\n            result := byte(0, mload(memPtr))\n        }\n\n        // SEE Github Issue #5.\n        // Summary: Most commonly used RLP libraries (i.e Geth) will encode\n        // \"0\" as \"0x80\" instead of as \"0\". We handle this edge case explicitly\n        // here.\n        if (result == 0 || result == STRING_SHORT_START) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    function toAddress(RLPItem memory item) internal pure returns (address) {\n        // 1 byte for the length prefix\n        require(item.len == 21);\n\n        return address(uint160(toUint(item)));\n    }\n\n    function toUint(RLPItem memory item) internal pure returns (uint256) {\n        require(item.len > 0 && item.len <= 33);\n\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\n\n        uint256 result;\n        assembly {\n            result := mload(memPtr)\n\n            // shift to the correct location if neccesary\n            if lt(len, 32) {\n                result := div(result, exp(256, sub(32, len)))\n            }\n        }\n\n        return result;\n    }\n\n    // enforces 32 byte length\n    function toUintStrict(RLPItem memory item) internal pure returns (uint256) {\n        // one byte prefix\n        require(item.len == 33);\n\n        uint256 result;\n        uint256 memPtr = item.memPtr + 1;\n        assembly {\n            result := mload(memPtr)\n        }\n\n        return result;\n    }\n\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\n        require(item.len > 0);\n\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\n        bytes memory result = new bytes(len);\n\n        uint256 destPtr;\n        assembly {\n            destPtr := add(0x20, result)\n        }\n\n        copy(memPtr, destPtr, len);\n        return result;\n    }\n\n    /*\n     * Private Helpers\n     */\n\n    // @return number of payload items inside an encoded list.\n    function numItems(RLPItem memory item) private pure returns (uint256) {\n        if (item.len == 0) return 0;\n\n        uint256 count = 0;\n        uint256 currPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint256 endPtr = item.memPtr + item.len;\n        while (currPtr < endPtr) {\n            currPtr = currPtr + _itemLength(currPtr); // skip over an item\n            count++;\n        }\n\n        return count;\n    }\n\n    // @return entire rlp item byte length\n    function _itemLength(uint256 memPtr) private pure returns (uint256) {\n        uint256 itemLen;\n        uint256 byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START) {\n            itemLen = 1;\n        } else if (byte0 < STRING_LONG_START) {\n            itemLen = byte0 - STRING_SHORT_START + 1;\n        } else if (byte0 < LIST_SHORT_START) {\n            assembly {\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\n                memPtr := add(memPtr, 1) // skip over the first byte\n\n                /* 32 byte word size */\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\n                itemLen := add(dataLen, add(byteLen, 1))\n            }\n        } else if (byte0 < LIST_LONG_START) {\n            itemLen = byte0 - LIST_SHORT_START + 1;\n        } else {\n            assembly {\n                let byteLen := sub(byte0, 0xf7)\n                memPtr := add(memPtr, 1)\n\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\n                itemLen := add(dataLen, add(byteLen, 1))\n            }\n        }\n\n        return itemLen;\n    }\n\n    // @return number of bytes until the data\n    function _payloadOffset(uint256 memPtr) private pure returns (uint256) {\n        uint256 byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START) {\n            return 0;\n        } else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START)) {\n            return 1;\n        } else if (byte0 < LIST_SHORT_START) {\n            // being explicit\n            return byte0 - (STRING_LONG_START - 1) + 1;\n        } else {\n            return byte0 - (LIST_LONG_START - 1) + 1;\n        }\n    }\n\n    /*\n     * @param src Pointer to source\n     * @param dest Pointer to destination\n     * @param len Amount of memory to copy from the source\n     */\n    function copy(uint256 src, uint256 dest, uint256 len) private pure {\n        if (len == 0) return;\n\n        // copy as many word sizes as possible\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n\n            src += WORD_SIZE;\n            dest += WORD_SIZE;\n        }\n\n        if (len > 0) {\n            // left over bytes. Mask is used to remove unwanted bytes from the word\n            uint256 mask = 256**(WORD_SIZE - len) - 1;\n            assembly {\n                let srcpart := and(mload(src), not(mask)) // zero out src\n                let destpart := and(mload(dest), mask) // retrieve the bytes\n                mstore(dest, or(destpart, srcpart))\n            }\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}