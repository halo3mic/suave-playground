{
  "address": "0xC5d9f644c6F8A1B3EE9504E2D8E1D19dBa592cC6",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "name": "PeekerReverted",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "message",
          "type": "string"
        }
      ],
      "name": "SuaveError",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "message",
          "type": "string"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "SuaveErrorWithData",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "string",
          "name": "ticker",
          "type": "string"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "price",
          "type": "uint256"
        }
      ],
      "name": "PriceSubmission",
      "type": "event"
    },
    {
      "stateMutability": "payable",
      "type": "fallback"
    },
    {
      "inputs": [],
      "name": "DECIMALS",
      "outputs": [
        {
          "internalType": "uint8",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "HOLESKY_BUNDLE_ENDPOINT",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "HOLESKY_CHAINID",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "HOLESKY_CHAINID_STR",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "REMOTE_HOLESKY_RPC",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "S_NAMESPACE",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "URL_PARTIAL",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "confidentialConstructor",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "Suave.DataId",
          "name": "_pkBidId",
          "type": "bytes16"
        },
        {
          "internalType": "address",
          "name": "pkAddress",
          "type": "address"
        }
      ],
      "name": "confidentialConstructorCallback",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "controller",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "isInitialized",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "pkBidId",
      "outputs": [
        {
          "internalType": "Suave.DataId",
          "name": "",
          "type": "bytes16"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "ticker",
          "type": "string"
        },
        {
          "internalType": "uint256",
          "name": "nonce",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "gasPrice",
          "type": "uint256"
        },
        {
          "internalType": "uint64",
          "name": "settlementBlockNum",
          "type": "uint64"
        },
        {
          "internalType": "bool",
          "name": "privateSubmission",
          "type": "bool"
        }
      ],
      "name": "queryAndSubmit",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "ticker",
          "type": "string"
        },
        {
          "internalType": "uint256",
          "name": "price",
          "type": "uint256"
        }
      ],
      "name": "queryAndSubmitCallback",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "ticker",
          "type": "string"
        }
      ],
      "name": "queryLatestPrice",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "price",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_settlementContract",
          "type": "address"
        }
      ],
      "name": "registerCallback",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_settlementContract",
          "type": "address"
        }
      ],
      "name": "registerSettlementContract",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "txSigned",
          "type": "bytes"
        }
      ],
      "name": "sendRawTx",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "settlementContract",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xd5a3a935031df1f9439b41751c7ccfa38cb567486d71f8ee7b53ea2f72e349e5",
  "receipt": {
    "to": null,
    "from": "0x16f2Aa8dF055b6e672b93Ded41FecCCabAB565B0",
    "contractAddress": "0xC5d9f644c6F8A1B3EE9504E2D8E1D19dBa592cC6",
    "transactionIndex": 0,
    "gasUsed": "4962745",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x2ce12b081e9048e6ff8b38e2f61735d518965a156baed3a4f4dc32501bf4a989",
    "transactionHash": "0xd5a3a935031df1f9439b41751c7ccfa38cb567486d71f8ee7b53ea2f72e349e5",
    "logs": [],
    "blockNumber": 682073,
    "cumulativeGasUsed": "4962745",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 2,
  "solcInputHash": "4c778da75e5522cbbc932758b3927517",
  "metadata": "{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"PeekerReverted\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"SuaveError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SuaveErrorWithData\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"ticker\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"PriceSubmission\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"DECIMALS\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"HOLESKY_BUNDLE_ENDPOINT\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"HOLESKY_CHAINID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"HOLESKY_CHAINID_STR\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REMOTE_HOLESKY_RPC\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"S_NAMESPACE\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"URL_PARTIAL\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"confidentialConstructor\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"Suave.DataId\",\"name\":\"_pkBidId\",\"type\":\"bytes16\"},{\"internalType\":\"address\",\"name\":\"pkAddress\",\"type\":\"address\"}],\"name\":\"confidentialConstructorCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isInitialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pkBidId\",\"outputs\":[{\"internalType\":\"Suave.DataId\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"ticker\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"settlementBlockNum\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"privateSubmission\",\"type\":\"bool\"}],\"name\":\"queryAndSubmit\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"ticker\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"queryAndSubmitCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"ticker\",\"type\":\"string\"}],\"name\":\"queryLatestPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_settlementContract\",\"type\":\"address\"}],\"name\":\"registerCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_settlementContract\",\"type\":\"address\"}],\"name\":\"registerSettlementContract\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"txSigned\",\"type\":\"bytes\"}],\"name\":\"sendRawTx\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"settlementContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/oracle/BinanceOracle.sol\":\"BinanceOracle\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/blockad/lib/SuaveContract.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// Author: Miha Lotric (halo3mic)\\n\\npragma solidity ^0.8.8;\\n\\nimport { Suave } from \\\"../../standard_peekers/bids.sol\\\";\\n\\n\\nabstract contract SuaveContract {\\n\\terror SuaveError(string message);\\n\\terror SuaveErrorWithData(string message, bytes data);\\n\\n\\tmodifier onlyConfidential() {\\n\\t\\tcrequire(Suave.isConfidential(), \\\"Not confidential\\\");\\n\\t\\t_;\\n\\t}\\n\\n\\tfunction simulateBundleSafe(bytes memory bundle, bool doRevert) internal view returns (bool valid, uint64 egp) {\\n\\t\\t(bool success, bytes memory d) = Suave.SIMULATE_BUNDLE.staticcall{ gas: 20_000 }(abi.encode(bundle));\\n\\t\\tcrequire(!doRevert || success, string(d));\\n\\t\\tif (success) {\\n\\t\\t\\treturn (true, abi.decode(d, (uint64)));\\n\\t\\t}\\n\\t}\\n\\n\\tfunction crequire(bool condition, string memory message) internal pure {\\n\\t\\tif (!condition) {\\n\\t\\t\\trevert SuaveError(message);\\n\\t\\t}\\n\\t}\\n}\\n\",\"keccak256\":\"0x64eb01469afe18f29050571acd52ee35faca1da2c00a87e01d5ea0fdbcdf4bec\",\"license\":\"MIT\"},\"contracts/libraries/Bundle.sol\":{\"content\":\"// Source: https://github.com/flashbots/suave-std/blob/main/src/protocols/Bundle.sol\\n\\n\\n// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\nimport \\\"./Suave.sol\\\";\\nimport \\\"solady/src/utils/LibString.sol\\\";\\n\\n// https://docs.flashbots.net/flashbots-auction/advanced/rpc-endpoint#eth_sendbundle\\nlibrary Bundle {\\n    struct BundleObj {\\n        uint64 blockNumber;\\n        uint64 minTimestamp;\\n        uint64 maxTimestamp;\\n        bytes[] txns;\\n    }\\n\\n    function sendBundle(string memory url, BundleObj memory bundle) internal returns (bytes memory) {\\n        Suave.HttpRequest memory request = encodeBundle(bundle);\\n        request.url = url;\\n        return Suave.doHTTPRequest(request);\\n    }\\n\\n    function encodeBundle(BundleObj memory args) internal pure returns (Suave.HttpRequest memory) {\\n        require(args.txns.length > 0, \\\"Bundle: no txns\\\");\\n\\n        bytes memory params =\\n            abi.encodePacked('{\\\"blockNumber\\\": \\\"', LibString.toHexString(args.blockNumber), '\\\", \\\"txs\\\": [');\\n        for (uint256 i = 0; i < args.txns.length; i++) {\\n            params = abi.encodePacked(params, '\\\"', LibString.toHexString(args.txns[i]), '\\\"');\\n            if (i < args.txns.length - 1) {\\n                params = abi.encodePacked(params, \\\",\\\");\\n            } else {\\n                params = abi.encodePacked(params, \\\"]\\\");\\n            }\\n        }\\n        if (args.minTimestamp > 0) {\\n            params = abi.encodePacked(params, ', \\\"minTimestamp\\\": ', LibString.toString(args.minTimestamp));\\n        }\\n        if (args.maxTimestamp > 0) {\\n            params = abi.encodePacked(params, ', \\\"maxTimestamp\\\": ', LibString.toString(args.maxTimestamp));\\n        }\\n        params = abi.encodePacked(params, ', \\\"maxTimestamp\\\": ', LibString.toString(args.maxTimestamp));\\n        params = abi.encodePacked(params, \\\"}\\\");\\n\\n        bytes memory body =\\n            abi.encodePacked('{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"method\\\":\\\"eth_sendBundle\\\",\\\"params\\\":[', params, '],\\\"id\\\":1}');\\n\\n        Suave.HttpRequest memory request;\\n        request.method = \\\"POST\\\";\\n        request.body = body;\\n        request.headers = new string[](1);\\n        request.headers[0] = \\\"Content-Type: application/json\\\";\\n        request.withFlashbotsSignature = true;\\n\\n        return request;\\n    }\\n}\",\"keccak256\":\"0xb74ba160c26d46ed7a74f84a202b28f2bbf8ec5c4700032881b9186db84d5d04\",\"license\":\"Unlicense\"},\"contracts/libraries/RLPWriter.sol\":{\"content\":\"// Source: https://github.com/flashbots/suave-std/blob/main/src/utils/RLPWriter.sol\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @custom:attribution https://github.com/bakaoh/solidity-rlp-encode\\n * @title RLPWriter\\n * @author RLPWriter is a library for encoding Solidity types to RLP bytes. Adapted from Bakaoh's\\n *         RLPEncode library (https://github.com/bakaoh/solidity-rlp-encode) with minor\\n *         modifications to improve legibility.\\n */\\nlibrary RLPWriter {\\n    /**\\n     * @notice RLP encodes a byte string.\\n     *\\n     * @param _in The byte string to encode.\\n     *\\n     * @return The RLP encoded string in bytes.\\n     */\\n    function writeBytes(bytes memory _in) internal pure returns (bytes memory) {\\n        bytes memory encoded;\\n\\n        if (_in.length == 1 && uint8(_in[0]) < 128) {\\n            encoded = _in;\\n        } else {\\n            encoded = abi.encodePacked(_writeLength(_in.length, 128), _in);\\n        }\\n\\n        return encoded;\\n    }\\n\\n    /**\\n     * @notice RLP encodes a list of RLP encoded byte byte strings.\\n     *\\n     * @param _in The list of RLP encoded byte strings.\\n     *\\n     * @return The RLP encoded list of items in bytes.\\n     */\\n    function writeList(bytes[] memory _in) internal pure returns (bytes memory) {\\n        bytes memory list = _flatten(_in);\\n        return abi.encodePacked(_writeLength(list.length, 192), list);\\n    }\\n\\n    /**\\n     * @notice RLP encodes a string.\\n     *\\n     * @param _in The string to encode.\\n     *\\n     * @return The RLP encoded string in bytes.\\n     */\\n    function writeString(string memory _in) internal pure returns (bytes memory) {\\n        return writeBytes(bytes(_in));\\n    }\\n\\n    /**\\n     * @notice RLP encodes an address.\\n     *\\n     * @param _in The address to encode.\\n     *\\n     * @return The RLP encoded address in bytes.\\n     */\\n    function writeAddress(address _in) internal pure returns (bytes memory) {\\n        return writeBytes(abi.encodePacked(_in));\\n    }\\n\\n    /**\\n     * @notice RLP encodes a uint.\\n     *\\n     * @param _in The uint256 to encode.\\n     *\\n     * @return The RLP encoded uint256 in bytes.\\n     */\\n    function writeUint(uint256 _in) internal pure returns (bytes memory) {\\n        return writeBytes(_toBinary(_in));\\n    }\\n\\n    /**\\n     * @notice RLP encodes a bool.\\n     *\\n     * @param _in The bool to encode.\\n     *\\n     * @return The RLP encoded bool in bytes.\\n     */\\n    function writeBool(bool _in) internal pure returns (bytes memory) {\\n        bytes memory encoded = new bytes(1);\\n        encoded[0] = (_in ? bytes1(0x01) : bytes1(0x80));\\n        return encoded;\\n    }\\n\\n    /**\\n     * @notice Encode the first byte and then the `len` in binary form if `length` is more than 55.\\n     *\\n     * @param _len    The length of the string or the payload.\\n     * @param _offset 128 if item is string, 192 if item is list.\\n     *\\n     * @return RLP encoded bytes.\\n     */\\n    function _writeLength(uint256 _len, uint256 _offset) private pure returns (bytes memory) {\\n        bytes memory encoded;\\n\\n        if (_len < 56) {\\n            encoded = new bytes(1);\\n            encoded[0] = bytes1(uint8(_len) + uint8(_offset));\\n        } else {\\n            uint256 lenLen;\\n            uint256 i = 1;\\n            while (_len / i != 0) {\\n                lenLen++;\\n                i *= 256;\\n            }\\n\\n            encoded = new bytes(lenLen + 1);\\n            encoded[0] = bytes1(uint8(lenLen) + uint8(_offset) + 55);\\n            for (i = 1; i <= lenLen; i++) {\\n                encoded[i] = bytes1(uint8((_len / (256 ** (lenLen - i))) % 256));\\n            }\\n        }\\n\\n        return encoded;\\n    }\\n\\n    /**\\n     * @notice Encode integer in big endian binary form with no leading zeroes.\\n     *\\n     * @param _x The integer to encode.\\n     *\\n     * @return RLP encoded bytes.\\n     */\\n    function _toBinary(uint256 _x) private pure returns (bytes memory) {\\n        bytes memory b = abi.encodePacked(_x);\\n\\n        uint256 i = 0;\\n        for (; i < 32; i++) {\\n            if (b[i] != 0) {\\n                break;\\n            }\\n        }\\n\\n        bytes memory res = new bytes(32 - i);\\n        for (uint256 j = 0; j < res.length; j++) {\\n            res[j] = b[i++];\\n        }\\n\\n        return res;\\n    }\\n\\n    /**\\n     * @custom:attribution https://github.com/Arachnid/solidity-stringutils\\n     * @notice Copies a piece of memory to another location.\\n     *\\n     * @param _dest Destination location.\\n     * @param _src  Source location.\\n     * @param _len  Length of memory to copy.\\n     */\\n    function _memcpy(uint256 _dest, uint256 _src, uint256 _len) private pure {\\n        uint256 dest = _dest;\\n        uint256 src = _src;\\n        uint256 len = _len;\\n\\n        for (; len >= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        uint256 mask;\\n        unchecked {\\n            mask = 256 ** (32 - len) - 1;\\n        }\\n        assembly {\\n            let srcpart := and(mload(src), not(mask))\\n            let destpart := and(mload(dest), mask)\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n    }\\n\\n    /**\\n     * @custom:attribution https://github.com/sammayo/solidity-rlp-encoder\\n     * @notice Flattens a list of byte strings into one byte string.\\n     *\\n     * @param _list List of byte strings to flatten.\\n     *\\n     * @return The flattened byte string.\\n     */\\n    function _flatten(bytes[] memory _list) private pure returns (bytes memory) {\\n        if (_list.length == 0) {\\n            return new bytes(0);\\n        }\\n\\n        uint256 len;\\n        uint256 i = 0;\\n        for (; i < _list.length; i++) {\\n            len += _list[i].length;\\n        }\\n\\n        bytes memory flattened = new bytes(len);\\n        uint256 flattenedPtr;\\n        assembly {\\n            flattenedPtr := add(flattened, 0x20)\\n        }\\n\\n        for (i = 0; i < _list.length; i++) {\\n            bytes memory item = _list[i];\\n\\n            uint256 listPtr;\\n            assembly {\\n                listPtr := add(item, 0x20)\\n            }\\n\\n            _memcpy(flattenedPtr, listPtr, item.length);\\n            flattenedPtr += _list[i].length;\\n        }\\n\\n        return flattened;\\n    }\\n}\",\"keccak256\":\"0x56651ebc297bf3681217d96f035f3f1fdd3027ae64f55087095182c90307f703\",\"license\":\"MIT\"},\"contracts/libraries/Suave.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.8;\\n\\n/// @notice Library to interact with the Suave MEVM precompiles.\\nlibrary Suave {\\n    error PeekerReverted(address, bytes);\\n\\n    enum CryptoSignature {\\n        SECP256,\\n        BLS\\n    }\\n\\n    type DataId is bytes16;\\n\\n    /// @notice Arguments to build the block.\\n    /// @param slot Slot number of the block\\n    /// @param proposerPubkey Public key of the proposer\\n    /// @param parent Hash of the parent block\\n    /// @param timestamp Timestamp of the block\\n    /// @param feeRecipient Address of the fee recipient\\n    /// @param gasLimit Gas limit of the block\\n    /// @param random Randomness of the block\\n    /// @param withdrawals List of withdrawals\\n    /// @param extra Extra data of the block\\n    /// @param beaconRoot Root of the beacon chain\\n    /// @param fillPending Whether to fill the block with pending transactions\\n    struct BuildBlockArgs {\\n        uint64 slot;\\n        bytes proposerPubkey;\\n        bytes32 parent;\\n        uint64 timestamp;\\n        address feeRecipient;\\n        uint64 gasLimit;\\n        bytes32 random;\\n        Withdrawal[] withdrawals;\\n        bytes extra;\\n        bytes32 beaconRoot;\\n        bool fillPending;\\n    }\\n\\n    /// @notice A record of data stored in the ConfidentialStore.\\n    /// @param id ID of the data record\\n    /// @param salt Salt used to derive the encryption key\\n    /// @param decryptionCondition Up to which block this data record is valid\\n    /// @param allowedPeekers Addresses which can get data\\n    /// @param allowedStores Addresses can set data\\n    /// @param version Namespace of the data record\\n    struct DataRecord {\\n        DataId id;\\n        DataId salt;\\n        uint64 decryptionCondition;\\n        address[] allowedPeekers;\\n        address[] allowedStores;\\n        string version;\\n    }\\n\\n    /// @notice Description of an HTTP request.\\n    /// @param url Target url of the request\\n    /// @param method HTTP method of the request\\n    /// @param headers HTTP Headers\\n    /// @param body Body of the request (if Post or Put)\\n    /// @param withFlashbotsSignature Whether to include the Flashbots signature\\n    /// @param timeout Timeout of the request in milliseconds\\n    struct HttpRequest {\\n        string url;\\n        string method;\\n        string[] headers;\\n        bytes body;\\n        bool withFlashbotsSignature;\\n        uint64 timeout;\\n    }\\n\\n    /// @notice Result of a simulated transaction.\\n    /// @param egp Effective Gas Price of the transaction\\n    /// @param logs Logs emitted during the simulation\\n    /// @param success Whether the transaction was successful or not\\n    /// @param error Error message if any\\n    struct SimulateTransactionResult {\\n        uint64 egp;\\n        SimulatedLog[] logs;\\n        bool success;\\n        string error;\\n    }\\n\\n    /// @notice A log emitted during the simulation of a transaction.\\n    /// @param data Data of the log\\n    /// @param addr Address of the contract that emitted the log\\n    /// @param topics Topics of the log\\n    struct SimulatedLog {\\n        bytes data;\\n        address addr;\\n        bytes32[] topics;\\n    }\\n\\n    /// @notice A withdrawal from the beacon chain.\\n    /// @param index Index of the withdrawal\\n    /// @param validator ID of the validator\\n    /// @param Address Address to withdraw to\\n    /// @param amount Amount to be withdrawn\\n    struct Withdrawal {\\n        uint64 index;\\n        uint64 validator;\\n        address Address;\\n        uint64 amount;\\n    }\\n\\n    address public constant ANYALLOWED = 0xC8df3686b4Afb2BB53e60EAe97EF043FE03Fb829;\\n\\n    address public constant IS_CONFIDENTIAL_ADDR = 0x0000000000000000000000000000000042010000;\\n\\n    address public constant BUILD_ETH_BLOCK = 0x0000000000000000000000000000000042100001;\\n\\n    address public constant BUILD_ETH_BLOCK_TO = 0x0000000000000000000000000000000042100006;\\n\\n    address public constant CONFIDENTIAL_INPUTS = 0x0000000000000000000000000000000042010001;\\n\\n    address public constant CONFIDENTIAL_RETRIEVE = 0x0000000000000000000000000000000042020001;\\n\\n    address public constant CONFIDENTIAL_STORE = 0x0000000000000000000000000000000042020000;\\n\\n    address public constant CONTEXT_GET = 0x0000000000000000000000000000000053300003;\\n\\n    address public constant DO_HTTPREQUEST = 0x0000000000000000000000000000000043200002;\\n\\n    address public constant ETHCALL = 0x0000000000000000000000000000000042100003;\\n\\n    address public constant EXTRACT_HINT = 0x0000000000000000000000000000000042100037;\\n\\n    address public constant FETCH_DATA_RECORDS = 0x0000000000000000000000000000000042030001;\\n\\n    address public constant FILL_MEV_SHARE_BUNDLE = 0x0000000000000000000000000000000043200001;\\n\\n    address public constant NEW_BUILDER = 0x0000000000000000000000000000000053200001;\\n\\n    address public constant NEW_DATA_RECORD = 0x0000000000000000000000000000000042030000;\\n\\n    address public constant PRIVATE_KEY_GEN = 0x0000000000000000000000000000000053200003;\\n\\n    address public constant RANDOM_BYTES = 0x000000000000000000000000000000007770000b;\\n\\n    address public constant SIGN_ETH_TRANSACTION = 0x0000000000000000000000000000000040100001;\\n\\n    address public constant SIGN_MESSAGE = 0x0000000000000000000000000000000040100003;\\n\\n    address public constant SIMULATE_BUNDLE = 0x0000000000000000000000000000000042100000;\\n\\n    address public constant SIMULATE_TRANSACTION = 0x0000000000000000000000000000000053200002;\\n\\n    address public constant SUBMIT_BUNDLE_JSON_RPC = 0x0000000000000000000000000000000043000001;\\n\\n    address public constant SUBMIT_ETH_BLOCK_TO_RELAY = 0x0000000000000000000000000000000042100002;\\n\\n    /// @notice Returns whether execution is off- or on-chain\\n    /// @return b Whether execution is off- or on-chain\\n    function isConfidential() internal returns (bool b) {\\n        (bool success, bytes memory isConfidentialBytes) = IS_CONFIDENTIAL_ADDR.call(\\\"\\\");\\n        if (!success) {\\n            revert PeekerReverted(IS_CONFIDENTIAL_ADDR, isConfidentialBytes);\\n        }\\n        assembly {\\n            // Load the length of data (first 32 bytes)\\n            let len := mload(isConfidentialBytes)\\n            // Load the data after 32 bytes, so add 0x20\\n            b := mload(add(isConfidentialBytes, 0x20))\\n        }\\n    }\\n\\n    /// @notice Constructs an Ethereum block based on the provided data records. No blobs are returned.\\n    /// @param blockArgs Arguments to build the block\\n    /// @param dataId ID of the data record with mev-share bundle data\\n    /// @param relayUrl If specified the built block will be submitted to the relay\\n    /// @return blockBid Block Bid encoded in JSON\\n    /// @return executionPayload Execution payload encoded in JSON\\n    function buildEthBlock(BuildBlockArgs memory blockArgs, DataId dataId, string memory relayUrl)\\n        internal\\n        returns (bytes memory, bytes memory)\\n    {\\n        (bool success, bytes memory data) = BUILD_ETH_BLOCK.call(abi.encode(blockArgs, dataId, relayUrl));\\n        if (!success) {\\n            revert PeekerReverted(BUILD_ETH_BLOCK, data);\\n        }\\n\\n        return abi.decode(data, (bytes, bytes));\\n    }\\n\\n    /// @notice Constructs an Ethereum block based on the provided data records. No blobs are returned.\\n    /// @param executionNodeURL URL (or service name) of the execution node\\n    /// @param blockArgs Arguments to build the block\\n    /// @param dataId ID of the data record with mev-share bundle data\\n    /// @param relayUrl If specified the built block will be submitted to the relay\\n    /// @return blockBid Block Bid encoded in JSON\\n    /// @return executionPayload Execution payload encoded in JSON\\n    function buildEthBlockTo(\\n        string memory executionNodeURL,\\n        BuildBlockArgs memory blockArgs,\\n        DataId dataId,\\n        string memory relayUrl\\n    ) internal returns (bytes memory, bytes memory) {\\n        (bool success, bytes memory data) =\\n            BUILD_ETH_BLOCK_TO.call(abi.encode(executionNodeURL, blockArgs, dataId, relayUrl));\\n        if (!success) {\\n            revert PeekerReverted(BUILD_ETH_BLOCK_TO, data);\\n        }\\n\\n        return abi.decode(data, (bytes, bytes));\\n    }\\n\\n    /// @notice Provides the confidential inputs associated with a confidential computation request. Outputs are in bytes format.\\n    /// @return confindentialData Confidential inputs\\n    function confidentialInputs() internal returns (bytes memory) {\\n        (bool success, bytes memory data) = CONFIDENTIAL_INPUTS.call(abi.encode());\\n        if (!success) {\\n            revert PeekerReverted(CONFIDENTIAL_INPUTS, data);\\n        }\\n\\n        return data;\\n    }\\n\\n    /// @notice Retrieves data from the confidential store. Also mandates the caller's presence in the `AllowedPeekers` list.\\n    /// @param dataId ID of the data record to retrieve\\n    /// @param key Key slot of the data to retrieve\\n    /// @return value Value of the data\\n    function confidentialRetrieve(DataId dataId, string memory key) internal returns (bytes memory) {\\n        (bool success, bytes memory data) = CONFIDENTIAL_RETRIEVE.call(abi.encode(dataId, key));\\n        if (!success) {\\n            revert PeekerReverted(CONFIDENTIAL_RETRIEVE, data);\\n        }\\n\\n        return data;\\n    }\\n\\n    /// @notice Stores data in the confidential store. Requires the caller to be part of the `AllowedPeekers` for the associated data record.\\n    /// @param dataId ID of the data record to store\\n    /// @param key Key slot of the data to store\\n    /// @param value Value of the data to store\\n    function confidentialStore(DataId dataId, string memory key, bytes memory value) internal {\\n        (bool success, bytes memory data) = CONFIDENTIAL_STORE.call(abi.encode(dataId, key, value));\\n        if (!success) {\\n            revert PeekerReverted(CONFIDENTIAL_STORE, data);\\n        }\\n    }\\n\\n    /// @notice Retrieves a value from the context\\n    /// @param key Key of the value to retrieve\\n    /// @return value Value of the key\\n    function contextGet(string memory key) internal returns (bytes memory) {\\n        (bool success, bytes memory data) = CONTEXT_GET.call(abi.encode(key));\\n        if (!success) {\\n            revert PeekerReverted(CONTEXT_GET, data);\\n        }\\n\\n        return abi.decode(data, (bytes));\\n    }\\n\\n    /// @notice Performs an HTTP request and returns the response. `request` is the request to perform.\\n    /// @param request Request to perform\\n    /// @return httpResponse Body of the response\\n    function doHTTPRequest(HttpRequest memory request) internal returns (bytes memory) {\\n        (bool success, bytes memory data) = DO_HTTPREQUEST.call(abi.encode(request));\\n        if (!success) {\\n            revert PeekerReverted(DO_HTTPREQUEST, data);\\n        }\\n\\n        return abi.decode(data, (bytes));\\n    }\\n\\n    /// @notice Uses the `eth_call` JSON RPC method to let you simulate a function call and return the response.\\n    /// @param contractAddr Address of the contract to call\\n    /// @param input1 Data to send to the contract\\n    /// @return callOutput Output of the contract call\\n    function ethcall(address contractAddr, bytes memory input1) internal returns (bytes memory) {\\n        (bool success, bytes memory data) = ETHCALL.call(abi.encode(contractAddr, input1));\\n        if (!success) {\\n            revert PeekerReverted(ETHCALL, data);\\n        }\\n\\n        return abi.decode(data, (bytes));\\n    }\\n\\n    /// @notice Interprets the bundle data and extracts hints, such as the `To` address and calldata.\\n    /// @param bundleData Bundle object encoded in JSON\\n    /// @return hints List of hints encoded in JSON\\n    function extractHint(bytes memory bundleData) internal returns (bytes memory) {\\n        require(isConfidential());\\n        (bool success, bytes memory data) = EXTRACT_HINT.call(abi.encode(bundleData));\\n        if (!success) {\\n            revert PeekerReverted(EXTRACT_HINT, data);\\n        }\\n\\n        return data;\\n    }\\n\\n    /// @notice Retrieves all data records correlating with a specified decryption condition and namespace\\n    /// @param cond Filter for the decryption condition\\n    /// @param namespace Filter for the namespace of the data records\\n    /// @return dataRecords List of data records that match the filter\\n    function fetchDataRecords(uint64 cond, string memory namespace) internal returns (DataRecord[] memory) {\\n        (bool success, bytes memory data) = FETCH_DATA_RECORDS.call(abi.encode(cond, namespace));\\n        if (!success) {\\n            revert PeekerReverted(FETCH_DATA_RECORDS, data);\\n        }\\n\\n        return abi.decode(data, (DataRecord[]));\\n    }\\n\\n    /// @notice Joins the user's transaction and with the backrun, and returns encoded mev-share bundle. The bundle is ready to be sent via `SubmitBundleJsonRPC`.\\n    /// @param dataId ID of the data record with mev-share bundle data\\n    /// @return encodedBundle Mev-Share bundle encoded in JSON\\n    function fillMevShareBundle(DataId dataId) internal returns (bytes memory) {\\n        require(isConfidential());\\n        (bool success, bytes memory data) = FILL_MEV_SHARE_BUNDLE.call(abi.encode(dataId));\\n        if (!success) {\\n            revert PeekerReverted(FILL_MEV_SHARE_BUNDLE, data);\\n        }\\n\\n        return data;\\n    }\\n\\n    /// @notice Initializes a new remote builder session\\n    /// @return sessionid ID of the remote builder session\\n    function newBuilder() internal returns (string memory) {\\n        (bool success, bytes memory data) = NEW_BUILDER.call(abi.encode());\\n        if (!success) {\\n            revert PeekerReverted(NEW_BUILDER, data);\\n        }\\n\\n        return abi.decode(data, (string));\\n    }\\n\\n    /// @notice Initializes data records within the ConfidentialStore. Prior to storing data, all data records should undergo initialization via this precompile.\\n    /// @param decryptionCondition Up to which block this data record is valid. Used during `fillMevShareBundle` precompie.\\n    /// @param allowedPeekers Addresses which can get data\\n    /// @param allowedStores Addresses can set data\\n    /// @param dataType Namespace of the data\\n    /// @return dataRecord Data record that was created\\n    function newDataRecord(\\n        uint64 decryptionCondition,\\n        address[] memory allowedPeekers,\\n        address[] memory allowedStores,\\n        string memory dataType\\n    ) internal returns (DataRecord memory) {\\n        (bool success, bytes memory data) =\\n            NEW_DATA_RECORD.call(abi.encode(decryptionCondition, allowedPeekers, allowedStores, dataType));\\n        if (!success) {\\n            revert PeekerReverted(NEW_DATA_RECORD, data);\\n        }\\n\\n        return abi.decode(data, (DataRecord));\\n    }\\n\\n    /// @notice Generates a private key in ECDA secp256k1 format\\n    /// @param crypto Type of the private key to generate\\n    /// @return privateKey Hex encoded string of the ECDSA private key. Exactly as a signMessage precompile wants.\\n    function privateKeyGen(CryptoSignature crypto) internal returns (string memory) {\\n        (bool success, bytes memory data) = PRIVATE_KEY_GEN.call(abi.encode(crypto));\\n        if (!success) {\\n            revert PeekerReverted(PRIVATE_KEY_GEN, data);\\n        }\\n\\n        return abi.decode(data, (string));\\n    }\\n\\n    /// @notice Generates a number of random bytes, given by the argument numBytes.\\n    /// @param numBytes Number of random bytes to generate\\n    /// @return value Randomly-generated bytes\\n    function randomBytes(uint8 numBytes) internal returns (bytes memory) {\\n        (bool success, bytes memory data) = RANDOM_BYTES.call(abi.encode(numBytes));\\n        if (!success) {\\n            revert PeekerReverted(RANDOM_BYTES, data);\\n        }\\n\\n        return abi.decode(data, (bytes));\\n    }\\n\\n    /// @notice Signs an Ethereum Transaction, 1559 or Legacy, and returns raw signed transaction bytes. `txn` is binary encoding of the transaction.\\n    /// @param txn Transaction to sign (RLP encoded)\\n    /// @param chainId Id of the chain to sign for (hex encoded, with 0x prefix)\\n    /// @param signingKey Hex encoded string of the ECDSA private key (without 0x prefix)\\n    /// @return signedTxn Signed transaction encoded in RLP\\n    function signEthTransaction(bytes memory txn, string memory chainId, string memory signingKey)\\n        internal\\n        returns (bytes memory)\\n    {\\n        (bool success, bytes memory data) = SIGN_ETH_TRANSACTION.call(abi.encode(txn, chainId, signingKey));\\n        if (!success) {\\n            revert PeekerReverted(SIGN_ETH_TRANSACTION, data);\\n        }\\n\\n        return abi.decode(data, (bytes));\\n    }\\n\\n    /// @notice Signs a message and returns the signature.\\n    /// @param digest Message to sign\\n    /// @param crypto Type of the private key to generate\\n    /// @param signingKey Hex encoded string of the ECDSA private key\\n    /// @return signature Signature of the message with the private key\\n    function signMessage(bytes memory digest, CryptoSignature crypto, string memory signingKey)\\n        internal\\n        returns (bytes memory)\\n    {\\n        require(isConfidential());\\n        (bool success, bytes memory data) = SIGN_MESSAGE.call(abi.encode(digest, crypto, signingKey));\\n        if (!success) {\\n            revert PeekerReverted(SIGN_MESSAGE, data);\\n        }\\n\\n        return abi.decode(data, (bytes));\\n    }\\n\\n    /// @notice Performs a simulation of the bundle by building a block that includes it.\\n    /// @param bundleData Bundle encoded in JSON\\n    /// @return effectiveGasPrice Effective Gas Price of the resultant block\\n    function simulateBundle(bytes memory bundleData) internal returns (uint64) {\\n        (bool success, bytes memory data) = SIMULATE_BUNDLE.call(abi.encode(bundleData));\\n        if (!success) {\\n            revert PeekerReverted(SIMULATE_BUNDLE, data);\\n        }\\n\\n        return abi.decode(data, (uint64));\\n    }\\n\\n    /// @notice Simulates a transaction on a remote builder session\\n    /// @param sessionid ID of the remote builder session\\n    /// @param txn Txn to simulate encoded in RLP\\n    /// @return simulationResult Result of the simulation\\n    function simulateTransaction(string memory sessionid, bytes memory txn)\\n        internal\\n        returns (SimulateTransactionResult memory)\\n    {\\n        (bool success, bytes memory data) = SIMULATE_TRANSACTION.call(abi.encode(sessionid, txn));\\n        if (!success) {\\n            revert PeekerReverted(SIMULATE_TRANSACTION, data);\\n        }\\n\\n        return abi.decode(data, (SimulateTransactionResult));\\n    }\\n\\n    /// @notice Submits bytes as JSONRPC message to the specified URL with the specified method. As this call is intended for bundles, it also signs the params and adds `X-Flashbots-Signature` header, as usual with bundles. Regular eth bundles don't need any processing to be sent.\\n    /// @param url URL to send the request to\\n    /// @param method JSONRPC method to call\\n    /// @param params JSONRPC input params encoded in RLP\\n    /// @return errorMessage Error message if any\\n    function submitBundleJsonRPC(string memory url, string memory method, bytes memory params)\\n        internal\\n        returns (bytes memory)\\n    {\\n        require(isConfidential());\\n        (bool success, bytes memory data) = SUBMIT_BUNDLE_JSON_RPC.call(abi.encode(url, method, params));\\n        if (!success) {\\n            revert PeekerReverted(SUBMIT_BUNDLE_JSON_RPC, data);\\n        }\\n\\n        return data;\\n    }\\n\\n    /// @notice Submits a given builderBid to a mev-boost relay.\\n    /// @param relayUrl URL of the relay to submit to\\n    /// @param builderBid Block bid to submit encoded in JSON\\n    /// @return blockBid Error message if any\\n    function submitEthBlockToRelay(string memory relayUrl, bytes memory builderBid) internal returns (bytes memory) {\\n        require(isConfidential());\\n        (bool success, bytes memory data) = SUBMIT_ETH_BLOCK_TO_RELAY.call(abi.encode(relayUrl, builderBid));\\n        if (!success) {\\n            revert PeekerReverted(SUBMIT_ETH_BLOCK_TO_RELAY, data);\\n        }\\n\\n        return data;\\n    }\\n}\\n\",\"keccak256\":\"0x3cd3eda525d8403668553d130780ecdca2bdee28bb82cc58a7c138c849409f9f\",\"license\":\"UNLICENSED\"},\"contracts/libraries/Transactions.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\nimport \\\"./RLPWriter.sol\\\";\\nimport \\\"./Suave.sol\\\";\\nimport \\\"solidity-rlp/contracts/RLPReader.sol\\\";\\n\\nlibrary Transactions {\\n    using RLPReader for RLPReader.RLPItem;\\n    using RLPReader for RLPReader.Iterator;\\n    using RLPReader for bytes;\\n\\n    struct EIP155 {\\n        address to;\\n        uint256 gas;\\n        uint256 gasPrice;\\n        uint256 value;\\n        uint256 nonce;\\n        bytes data;\\n        uint256 chainId;\\n        bytes32 r;\\n        bytes32 s;\\n        uint64 v;\\n    }\\n\\n    struct EIP155Request {\\n        address to;\\n        uint256 gas;\\n        uint256 gasPrice;\\n        uint256 value;\\n        uint256 nonce;\\n        bytes data;\\n        uint256 chainId;\\n    }\\n\\n    struct EIP1559 {\\n        address to;\\n        uint64 gas;\\n        uint64 maxFeePerGas;\\n        uint64 maxPriorityFeePerGas;\\n        uint64 value;\\n        uint64 nonce;\\n        bytes data;\\n        uint64 chainId;\\n        bytes accessList;\\n        bytes32 r;\\n        bytes32 s;\\n        uint64 v;\\n    }\\n\\n    struct EIP1559Request {\\n        address to;\\n        uint64 gas;\\n        uint64 maxFeePerGas;\\n        uint64 maxPriorityFeePerGas;\\n        uint64 value;\\n        uint64 nonce;\\n        bytes data;\\n        uint64 chainId;\\n        bytes accessList;\\n    }\\n\\n    function encodeRLP(EIP155 memory txStruct) internal pure returns (bytes memory) {\\n        bytes[] memory items = new bytes[](9);\\n\\n        items[0] = RLPWriter.writeUint(txStruct.nonce);\\n        items[1] = RLPWriter.writeUint(txStruct.gasPrice);\\n        items[2] = RLPWriter.writeUint(txStruct.gas);\\n\\n        if (txStruct.to == address(0)) {\\n            items[3] = RLPWriter.writeBytes(bytes(\\\"\\\"));\\n        } else {\\n            items[3] = RLPWriter.writeAddress(txStruct.to);\\n        }\\n        items[4] = RLPWriter.writeUint(txStruct.value);\\n        items[5] = RLPWriter.writeBytes(txStruct.data);\\n        items[6] = RLPWriter.writeUint(uint256(txStruct.v));\\n        items[7] = RLPWriter.writeBytes(abi.encodePacked(txStruct.r));\\n        items[8] = RLPWriter.writeBytes(abi.encodePacked(txStruct.s));\\n\\n        return RLPWriter.writeList(items);\\n    }\\n\\n    function encodeRLP(EIP155Request memory txStruct) internal pure returns (bytes memory) {\\n        bytes[] memory items = new bytes[](9);\\n\\n        items[0] = RLPWriter.writeUint(txStruct.nonce);\\n        items[1] = RLPWriter.writeUint(txStruct.gasPrice);\\n        items[2] = RLPWriter.writeUint(txStruct.gas);\\n\\n        if (txStruct.to == address(0)) {\\n            items[3] = RLPWriter.writeBytes(bytes(\\\"\\\"));\\n        } else {\\n            items[3] = RLPWriter.writeAddress(txStruct.to);\\n        }\\n        items[4] = RLPWriter.writeUint(txStruct.value);\\n        items[5] = RLPWriter.writeBytes(txStruct.data);\\n        items[6] = RLPWriter.writeUint(txStruct.chainId);\\n        items[7] = RLPWriter.writeBytes(\\\"\\\");\\n        items[8] = RLPWriter.writeBytes(\\\"\\\");\\n\\n        return RLPWriter.writeList(items);\\n    }\\n\\n    function encodeRLP(EIP1559 memory txStruct) internal pure returns (bytes memory) {\\n        bytes[] memory items = new bytes[](12);\\n\\n        items[0] = RLPWriter.writeUint(txStruct.chainId);\\n        items[1] = RLPWriter.writeUint(txStruct.nonce);\\n        items[2] = RLPWriter.writeUint(txStruct.maxPriorityFeePerGas);\\n        items[3] = RLPWriter.writeUint(txStruct.maxFeePerGas);\\n        items[4] = RLPWriter.writeUint(txStruct.gas);\\n\\n        if (txStruct.to == address(0)) {\\n            items[5] = RLPWriter.writeBytes(bytes(\\\"\\\"));\\n        } else {\\n            items[5] = RLPWriter.writeAddress(txStruct.to);\\n        }\\n\\n        items[6] = RLPWriter.writeUint(txStruct.value);\\n        items[7] = RLPWriter.writeBytes(txStruct.data);\\n\\n        if (txStruct.accessList.length == 0) {\\n            items[8] = hex\\\"c0\\\"; // Empty list encoding\\n        } else {\\n            items[8] = RLPWriter.writeBytes(txStruct.accessList);\\n        }\\n\\n        items[9] = RLPWriter.writeUint(uint256(txStruct.v));\\n        items[10] = RLPWriter.writeBytes(abi.encodePacked(txStruct.r));\\n        items[11] = RLPWriter.writeBytes(abi.encodePacked(txStruct.s));\\n\\n        bytes memory rlpTxn = RLPWriter.writeList(items);\\n\\n        bytes memory txn = new bytes(1 + rlpTxn.length);\\n        txn[0] = 0x02;\\n\\n        for (uint256 i = 0; i < rlpTxn.length; ++i) {\\n            txn[i + 1] = rlpTxn[i];\\n        }\\n\\n        return txn;\\n    }\\n\\n    function encodeRLP(EIP1559Request memory txStruct) internal pure returns (bytes memory) {\\n        bytes[] memory items = new bytes[](9);\\n\\n        items[0] = RLPWriter.writeUint(txStruct.chainId);\\n        items[1] = RLPWriter.writeUint(txStruct.nonce);\\n        items[2] = RLPWriter.writeUint(txStruct.maxPriorityFeePerGas);\\n        items[3] = RLPWriter.writeUint(txStruct.maxFeePerGas);\\n        items[4] = RLPWriter.writeUint(txStruct.gas);\\n\\n        if (txStruct.to == address(0)) {\\n            items[5] = RLPWriter.writeBytes(bytes(\\\"\\\"));\\n        } else {\\n            items[5] = RLPWriter.writeAddress(txStruct.to);\\n        }\\n\\n        items[6] = RLPWriter.writeUint(txStruct.value);\\n        items[7] = RLPWriter.writeBytes(txStruct.data);\\n\\n        if (txStruct.accessList.length == 0) {\\n            items[8] = hex\\\"c0\\\"; // Empty list encoding\\n        } else {\\n            items[8] = RLPWriter.writeBytes(txStruct.accessList);\\n        }\\n\\n        bytes memory rlpTxn = RLPWriter.writeList(items);\\n\\n        bytes memory txn = new bytes(1 + rlpTxn.length);\\n        txn[0] = 0x02;\\n\\n        for (uint256 i = 0; i < rlpTxn.length; ++i) {\\n            txn[i + 1] = rlpTxn[i];\\n        }\\n\\n        return txn;\\n    }\\n\\n    function decodeRLP_EIP155(bytes memory rlp) internal pure returns (EIP155 memory) {\\n        EIP155 memory txStruct;\\n\\n        RLPReader.RLPItem[] memory ls = rlp.toRlpItem().toList();\\n        require(ls.length == 9, \\\"invalid transaction\\\");\\n\\n        txStruct.nonce = uint64(ls[0].toUint());\\n        txStruct.gasPrice = uint64(ls[1].toUint());\\n        txStruct.gas = uint64(ls[2].toUint());\\n\\n        if (ls[3].toRlpBytes().length == 1) {\\n            txStruct.to = address(0);\\n        } else {\\n            txStruct.to = ls[3].toAddress();\\n        }\\n\\n        txStruct.value = uint64(ls[4].toUint());\\n        txStruct.data = ls[5].toBytes();\\n        txStruct.v = uint64(ls[6].toUint());\\n        txStruct.r = bytesToBytes32(ls[7].toBytes());\\n        txStruct.s = bytesToBytes32(ls[8].toBytes());\\n\\n        return txStruct;\\n    }\\n\\n    function decodeRLP_EIP155Request(bytes memory rlp) internal pure returns (EIP155Request memory) {\\n        EIP155Request memory txStruct;\\n\\n        RLPReader.RLPItem[] memory ls = rlp.toRlpItem().toList();\\n        require(ls.length == 9, \\\"invalid transaction\\\");\\n\\n        txStruct.nonce = ls[0].toUint();\\n        txStruct.gasPrice = ls[1].toUint();\\n        txStruct.gas = ls[2].toUint();\\n\\n        if (ls[3].toRlpBytes().length == 1) {\\n            txStruct.to = address(0);\\n        } else {\\n            txStruct.to = ls[3].toAddress();\\n        }\\n\\n        txStruct.value = ls[4].toUint();\\n        txStruct.data = ls[5].toBytes();\\n        txStruct.chainId = uint64(ls[6].toUint());\\n\\n        return txStruct;\\n    }\\n\\n    function decodeRLP_EIP1559(bytes memory rlp) internal pure returns (EIP1559 memory) {\\n        EIP1559 memory txStruct;\\n\\n        bytes memory rlpWithoutPrefix = new bytes(rlp.length - 1);\\n\\n        for (uint256 i = 0; i < rlp.length - 1; ++i) {\\n            rlpWithoutPrefix[i] = rlp[i + 1];\\n        }\\n\\n        RLPReader.RLPItem[] memory ls = rlpWithoutPrefix.toRlpItem().toList();\\n        require(ls.length == 12, \\\"invalid transaction\\\");\\n\\n        txStruct.chainId = uint64(ls[0].toUint());\\n        txStruct.nonce = uint64(ls[1].toUint());\\n        txStruct.maxPriorityFeePerGas = uint64(ls[2].toUint());\\n        txStruct.maxFeePerGas = uint64(ls[3].toUint());\\n        txStruct.gas = uint64(ls[4].toUint());\\n\\n        if (ls[5].toRlpBytes().length == 1) {\\n            txStruct.to = address(0);\\n        } else {\\n            txStruct.to = ls[5].toAddress();\\n        }\\n\\n        txStruct.value = uint64(ls[6].toUint());\\n        txStruct.data = ls[7].toBytes();\\n        txStruct.accessList = ls[8].toBytes();\\n        txStruct.v = uint64(ls[9].toUint());\\n        txStruct.r = bytesToBytes32(ls[10].toBytes());\\n        txStruct.s = bytesToBytes32(ls[11].toBytes());\\n\\n        return txStruct;\\n    }\\n\\n    function decodeRLP_EIP1559Request(bytes memory rlp) internal pure returns (EIP1559Request memory) {\\n        EIP1559Request memory txStruct;\\n\\n        bytes memory rlpWithoutPrefix = new bytes(rlp.length - 1);\\n\\n        for (uint256 i = 0; i < rlp.length - 1; ++i) {\\n            rlpWithoutPrefix[i] = rlp[i + 1];\\n        }\\n\\n        RLPReader.RLPItem[] memory ls = rlpWithoutPrefix.toRlpItem().toList();\\n        require(ls.length == 8, \\\"invalid transaction\\\");\\n\\n        txStruct.chainId = uint64(ls[0].toUint());\\n        txStruct.nonce = uint64(ls[1].toUint());\\n        txStruct.maxPriorityFeePerGas = uint64(ls[2].toUint());\\n        txStruct.maxFeePerGas = uint64(ls[3].toUint());\\n        txStruct.gas = uint64(ls[4].toUint());\\n\\n        if (ls[5].toRlpBytes().length == 1) {\\n            txStruct.to = address(0);\\n        } else {\\n            txStruct.to = ls[5].toAddress();\\n        }\\n\\n        txStruct.value = uint64(ls[6].toUint());\\n        txStruct.data = ls[7].toBytes();\\n\\n        return txStruct;\\n    }\\n\\n    function bytesToBytes32(bytes memory inBytes) internal pure returns (bytes32 out) {\\n        require(inBytes.length == 32, \\\"bytesToBytes32: invalid input length\\\");\\n        assembly {\\n            out := mload(add(inBytes, 32))\\n        }\\n    }\\n\\n    function signTxn(Transactions.EIP1559Request memory request, string memory signingKey)\\n        internal\\n        returns (Transactions.EIP1559 memory response)\\n    {\\n        bytes memory rlp = Transactions.encodeRLP(request);\\n        bytes memory hash = abi.encodePacked(keccak256(rlp));\\n        bytes memory signature = Suave.signMessage(hash, Suave.CryptoSignature.SECP256, signingKey);\\n        (uint8 v, bytes32 r, bytes32 s) = decodeSignature(signature);\\n\\n        response.to = request.to;\\n        response.gas = request.gas;\\n        response.maxFeePerGas = request.maxFeePerGas;\\n        response.maxPriorityFeePerGas = request.maxPriorityFeePerGas;\\n        response.value = request.value;\\n        response.nonce = request.nonce;\\n        response.data = request.data;\\n        response.chainId = request.chainId;\\n        response.accessList = request.accessList;\\n        response.v = v;\\n        response.r = r;\\n        response.s = s;\\n\\n        return response;\\n    }\\n\\n    function signTxn(Transactions.EIP155Request memory request, string memory signingKey)\\n        internal\\n        returns (Transactions.EIP155 memory response)\\n    {\\n        bytes memory rlp = Transactions.encodeRLP(request);\\n        bytes memory hash = abi.encodePacked(keccak256(rlp));\\n        bytes memory signature = Suave.signMessage(hash, Suave.CryptoSignature.SECP256, signingKey);\\n\\n        // TODO: check overflow\\n        uint64 chainIdMul = uint64(request.chainId) * 2;\\n        (uint8 v, bytes32 r, bytes32 s) = decodeSignature(signature);\\n\\n        uint64 v64 = uint64(v) + 35;\\n        v64 += chainIdMul;\\n\\n        response.to = request.to;\\n        response.gas = request.gas;\\n        response.gasPrice = request.gasPrice;\\n        response.value = request.value;\\n        response.nonce = request.nonce;\\n        response.data = request.data;\\n        response.chainId = request.chainId;\\n        response.v = v64;\\n        response.r = r;\\n        response.s = s;\\n\\n        return response;\\n    }\\n\\n    function decodeSignature(bytes memory signature) public pure returns (uint8 v, bytes32 r, bytes32 s) {\\n        assembly {\\n            r := mload(add(signature, 0x20))\\n            s := mload(add(signature, 0x40))\\n            v := byte(0, mload(add(signature, 0x60)))\\n        }\\n    }\\n}\",\"keccak256\":\"0x89fc7ac3af9f379b723cd0647dbbbc916d28adca2ad4261f2c11febc661b9d84\",\"license\":\"Unlicense\"},\"contracts/oracle/BinanceOracle.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// Author: Miha Lotric (halo3mic)\\n\\npragma solidity ^0.8.13;\\n\\nimport { AnyBundleContract, Suave } from \\\"../standard_peekers/bids.sol\\\";\\nimport { SuaveContract } from \\\"../blockad/lib/SuaveContract.sol\\\";\\nimport \\\"solady/src/utils/JSONParserLib.sol\\\";\\nimport \\\"solady/src/utils/LibString.sol\\\";\\nimport \\\"../libraries/Transactions.sol\\\";\\nimport \\\"../libraries/Bundle.sol\\\";\\n\\n\\ncontract BinanceOracle is SuaveContract {\\n    using JSONParserLib for *;\\n\\n    uint public constant HOLESKY_CHAINID = 17000;\\n    string public constant HOLESKY_CHAINID_STR = \\\"0x4268\\\";\\n    uint8 public constant DECIMALS = 4;\\n    string public constant S_NAMESPACE = \\\"oracle:v0:pksecret\\\";\\n    string public constant REMOTE_HOLESKY_RPC = \\\"https://ethereum-holesky-rpc.publicnode.com\\\";\\n    string public constant URL_PARTIAL = \\\"https://data-api.binance.vision/api/v3/ticker/price?symbol=\\\";\\n    string public constant HOLESKY_BUNDLE_ENDPOINT = \\\"https://relay-holesky.flashbots.net\\\";\\n    \\n    bool public isInitialized;\\n    Suave.DataId public pkBidId;\\n    address public controller;\\n    address public settlementContract;\\n\\n    event PriceSubmission(string ticker, uint price);\\n\\n    // \\u26d3\\ufe0f EVM Methods\\n\\n    function confidentialConstructorCallback(\\n        Suave.DataId _pkBidId, \\n        address pkAddress\\n    ) public {\\n        crequire(!isInitialized, \\\"Already initialized\\\");\\n        pkBidId = _pkBidId;\\n        controller = pkAddress;\\n        isInitialized = true;\\n    }\\n\\n    function registerCallback(address _settlementContract) public {\\n        require(settlementContract == address(0), \\\"Already registered\\\");\\n        settlementContract = _settlementContract;\\n    }\\n\\n    // ! Warning: This method is not restricted and emitted events should not be relied upon\\n    function queryAndSubmitCallback(string memory ticker, uint price) public {\\n        emit PriceSubmission(ticker, price);\\n    }\\n\\n    fallback() external payable {\\n        // Needed to accept MEVM calls with no callbacks\\n    }\\n\\n    // \\ud83e\\udd10 MEVM Methods\\n\\n    function confidentialConstructor() external onlyConfidential returns (bytes memory) {\\n        crequire(!isInitialized, \\\"Already initialized\\\");\\n\\n        string memory pk = Suave.privateKeyGen(Suave.CryptoSignature.SECP256);\\n        address pkAddress = getAddressForPk(pk);\\n\\t\\tSuave.DataId bidId = storePK(bytes(pk));\\n\\n        return abi.encodeWithSelector(\\n            this.confidentialConstructorCallback.selector, \\n            bidId, \\n            pkAddress\\n        );\\n    }\\n\\n    function registerSettlementContract(\\n        address _settlementContract\\n    ) external onlyConfidential() returns (bytes memory) {\\n        // Allow multiple registrations for the same address (consider the intial tx is not commited to the chain)\\n        require(_settlementContract == settlementContract || settlementContract == address(0), \\\"Already registered\\\");\\n        bytes memory signedTx = createRegisterTx(_settlementContract);\\n        return sendRawTx(signedTx);\\n    }\\n\\n    function queryAndSubmit(\\n        string memory ticker,\\n        uint nonce,\\n        uint gasPrice,\\n        uint64 settlementBlockNum,\\n        bool privateSubmission\\n    ) external onlyConfidential returns (bytes memory) {\\n        uint price = queryLatestPrice(ticker);\\n        submitPriceUpdate(ticker, price, nonce, gasPrice, settlementBlockNum, privateSubmission);\\n        return abi.encodeWithSelector(this.queryAndSubmitCallback.selector, ticker, price);\\n    }\\n\\n    function queryLatestPrice(string memory ticker) public view returns (uint price) {\\n        bytes memory response = doBinanceQuery(ticker);\\n        JSONParserLib.Item memory parsedRes = string(response).parse();\\n        // solhint-disable-next-line\\n        string memory priceStr = string(parsedRes.at('\\\"price\\\"').value());\\n        price = floatToInt(trimStrEdges(priceStr), DECIMALS);\\n    }\\n\\n    function submitPriceUpdate(\\n        string memory ticker,\\n        uint price, \\n        uint nonce,\\n        uint gasPrice,\\n        uint64 settlementBlockNum,\\n        bool privateSubmission\\n    ) internal {\\n        bytes memory signedTx = createPriceUpdateTx(ticker, price, nonce, gasPrice);\\n        if (privateSubmission) {\\n            sendBundle(signedTx, settlementBlockNum);\\n        } else {\\n            sendRawTx(signedTx);\\n        }\\n    }\\n\\n    function createRegisterTx(address _settlementContract) internal returns (bytes memory txSigned) {\\n        Transactions.EIP155 memory transaction = Transactions.EIP155({\\n            nonce: 0,\\n            gasPrice: 100 gwei,\\n            gas: 100_000,\\n            to: _settlementContract,\\n            value: 0,\\n            data: abi.encodeWithSignature(\\\"register()\\\"),\\n            chainId: HOLESKY_CHAINID,\\n            v: 27,\\n            r: hex\\\"1111111111111111111111111111111111111111111111111111111111111111\\\",\\n            s: hex\\\"1111111111111111111111111111111111111111111111111111111111111111\\\"\\n        });\\n        bytes memory txRlp = Transactions.encodeRLP(transaction);\\n        string memory pk = retreivePK();\\n        txSigned = Suave.signEthTransaction(txRlp, HOLESKY_CHAINID_STR, pk);\\n    }\\n\\n    function createPriceUpdateTx(\\n        string memory ticker, \\n        uint price, \\n        uint nonce, \\n        uint gasPrice\\n    ) internal returns (bytes memory txSigned)  {\\n        Transactions.EIP155 memory transaction = Transactions.EIP155({\\n            nonce: nonce,\\n            gasPrice: gasPrice,\\n            gas: 100_000,\\n            to: settlementContract,\\n            value: 0,\\n            data: abi.encodeWithSignature(\\\"updatePrice(string,uint256)\\\", ticker, price),\\n            chainId: HOLESKY_CHAINID,\\n            v: 27,\\n            r: hex\\\"1111111111111111111111111111111111111111111111111111111111111111\\\",\\n            s: hex\\\"1111111111111111111111111111111111111111111111111111111111111111\\\"\\n        });\\n        bytes memory txRlp = Transactions.encodeRLP(transaction);\\n        string memory pk = retreivePK();\\n        txSigned = Suave.signEthTransaction(txRlp, HOLESKY_CHAINID_STR, pk);\\n    }\\n\\n    function sendRawTx(bytes memory txSigned) public view returns (bytes memory) {\\n        /* solhint-disable */\\n        bytes memory body = abi.encodePacked(\\n            '{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"method\\\":\\\"eth_sendRawTransaction\\\",\\\"params\\\":[\\\"', \\n            LibString.toHexString(txSigned), \\n            '\\\"],\\\"id\\\":1}'\\n        );\\n        /* solhint-enable */\\n        Suave.HttpRequest memory request;\\n        request.method = \\\"POST\\\";\\n        request.body = body;\\n        request.headers = new string[](1);\\n        request.headers[0] = \\\"Content-Type: application/json\\\";\\n        request.withFlashbotsSignature = false;\\n        request.url = REMOTE_HOLESKY_RPC;\\n        request.timeout = 10000;\\n        return doHttpRequest(request);\\n    }\\n\\n    function sendBundle(bytes memory txSigned, uint64 settlementBlockNum) internal view {\\n        simulateTx(txSigned);\\n        sendTxViaBundle(txSigned, settlementBlockNum);\\n    }\\n\\n    function simulateTx(bytes memory signedTx) internal view {\\n        // solhint-disable-next-line\\n        bytes memory bundle = abi.encodePacked('{\\\"txs\\\": [\\\"', LibString.toHexString(signedTx), '\\\"]}');\\n        (bool successSim, bytes memory data) = Suave.SIMULATE_BUNDLE.staticcall(abi.encode(bundle));\\n        crequire(successSim,  string(abi.encodePacked(\\\"BundleSimulationFailed: \\\", string(data))));\\n    }\\n\\n    function doBinanceQuery(string memory ticker) internal view returns (bytes memory) {\\n        string[] memory headers = new string[](1);\\n        headers[0] = \\\"Content-Type: application/json\\\";\\n        Suave.HttpRequest memory request = Suave.HttpRequest({\\n            url: string(abi.encodePacked(URL_PARTIAL, ticker)),\\n            method: \\\"GET\\\",\\n            headers: headers,\\n            body: new bytes(0),\\n            withFlashbotsSignature: false,\\n            timeout: 10_000\\n        });\\n        return doHttpRequest(request);\\n    }\\n\\n    function doHttpRequest(Suave.HttpRequest memory request) internal view returns (bytes memory) {\\n        (bool success, bytes memory data) = Suave.DO_HTTPREQUEST.staticcall(abi.encode(request));\\n        crequire(success, string(data));\\n        return abi.decode(data, (bytes));\\n    }\\n\\n    function sendTxViaBundle(bytes memory txSigned, uint64 settlementBlockNum) internal view {\\n        bytes[] memory txns = new bytes[](1);\\n        txns[0] = txSigned;\\n        bytes memory bundleReqParams = bundleRequestParams(txns, settlementBlockNum);\\n        (bool successReq, bytes memory dataReq) = Suave.SUBMIT_BUNDLE_JSON_RPC.staticcall(abi.encode(\\n            HOLESKY_BUNDLE_ENDPOINT, \\n            \\\"eth_sendBundle\\\", \\n            bundleReqParams\\n        ));\\n        crequire(successReq, string(abi.encodePacked(\\\"BundleSubmissionFailed: \\\", string(dataReq))));\\n    }\\n\\n    function bundleRequestParams(bytes[] memory txns, uint blockNumber) internal pure returns (bytes memory) {\\n        // solhint-disable-next-line\\n        bytes memory params = abi.encodePacked('{\\\"blockNumber\\\": \\\"', LibString.toHexString(blockNumber), '\\\", \\\"txs\\\": [');\\n        for (uint256 i = 0; i < txns.length; i++) {\\n            // solhint-disable-next-line\\n            params = abi.encodePacked(params, '\\\"', LibString.toHexString(txns[i]), '\\\"');\\n            if (i < txns.length - 1) {\\n                params = abi.encodePacked(params, \\\",\\\");\\n            } else {\\n                params = abi.encodePacked(params, \\\"]\\\");\\n            }\\n        }\\n        params = abi.encodePacked(params, \\\"}\\\");\\n\\n        return params;\\n    }\\n\\n    function storePK(bytes memory pk) internal returns (Suave.DataId) {\\n\\t\\taddress[] memory peekers = new address[](3);\\n\\t\\tpeekers[0] = address(this);\\n\\t\\tpeekers[1] = Suave.FETCH_DATA_RECORDS;\\n\\t\\tpeekers[2] = Suave.CONFIDENTIAL_RETRIEVE;\\n\\t\\tSuave.DataRecord memory secretBid = Suave.newDataRecord(0, peekers, peekers, S_NAMESPACE);\\n\\t\\tSuave.confidentialStore(secretBid.id, S_NAMESPACE, pk);\\n\\t\\treturn secretBid.id;\\n\\t}\\n\\n    function retreivePK() internal returns (string memory) {\\n        bytes memory pkBytes =  Suave.confidentialRetrieve(pkBidId, S_NAMESPACE);\\n        return string(pkBytes);\\n    }\\n\\n}\\n\\n// \\ud83d\\udd27 Utils\\n\\nfunction floatToInt(string memory floatString, uint8 decimals) pure returns (uint) {\\n    bytes memory stringBytes = bytes(floatString);\\n    uint dotPosition;\\n    \\n    // Find the position of the dot\\n    for (uint i = 0; i < stringBytes.length; i++) {\\n        if (stringBytes[i] == 0x2E) {\\n            dotPosition = i;\\n            break;\\n        }\\n    }\\n    \\n    uint integerPart = 0;\\n    uint decimalPart = 0;\\n    uint tenPower = 1;\\n    \\n    // Convert integer part\\n    for (uint i = dotPosition; i > 0; i--) {\\n        integerPart += (uint8(stringBytes[i - 1]) - 48) * tenPower;\\n        tenPower *= 10;\\n    }\\n    // Reset power of ten\\n    tenPower = 1;\\n    // Convert decimal part\\n    for (uint i = dotPosition+decimals; i > dotPosition; i--) {\\n        decimalPart += (uint8(stringBytes[i]) - 48) * tenPower;\\n        tenPower *= 10;\\n    }\\n    // Combine integer and decimal parts\\n    return integerPart * (10**decimals) + decimalPart;\\n}\\n\\nfunction trimStrEdges(string memory _input) pure returns (string memory) {\\n    bytes memory input = bytes(_input);\\n    require(input.length > 2, \\\"Input too short\\\");\\n\\n    uint newLength = input.length - 2;\\n    bytes memory result = new bytes(newLength);\\n\\n    assembly {\\n        let inputPtr := add(input, 0x21)\\n        let resultPtr := add(result, 0x20)\\n        let length := mload(input)\\n        mstore(resultPtr, mload(inputPtr))\\n        mstore(result, newLength)\\n    }\\n    return string(result);\\n}\\n\\nfunction getAddressForPk(string memory pk) returns (address) {\\n    bytes32 digest = keccak256(abi.encode(\\\"yo\\\"));\\n    bytes memory sig = Suave.signMessage(abi.encodePacked(digest), Suave.CryptoSignature.SECP256, pk);\\n    return recoverSigner(digest, sig);\\n}\\n\\nfunction recoverSigner(bytes32 _ethSignedMessageHash, bytes memory _signature) pure returns (address) {\\n    (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);\\n    return ecrecover(_ethSignedMessageHash, v, r, s);\\n}\\n\\nfunction splitSignature(bytes memory sig) pure returns (bytes32 r, bytes32 s, uint8 v) {\\n    require(sig.length == 65, \\\"invalid signature length\\\");\\n    assembly {\\n        r := mload(add(sig, 32))\\n        s := mload(add(sig, 64))\\n        v := byte(0, mload(add(sig, 96)))\\n    }\\n    if (v < 27) {\\n        v += 27;\\n    }\\n}\",\"keccak256\":\"0xc01aacf2a3f5920b11bb27e82b53b00368c60f5eda90794d47ef8d41269c4389\",\"license\":\"MIT\"},\"contracts/standard_peekers/bids.sol\":{\"content\":\"pragma solidity ^0.8.8;\\n\\nimport \\\"../libraries/Suave.sol\\\";\\n\\ncontract AnyBundleContract {\\n    event DataRecordEvent(Suave.DataId dataId, uint64 decryptionCondition, address[] allowedPeekers);\\n\\n    function fetchConfidentialBundleData() public returns (bytes memory) {\\n        require(Suave.isConfidential());\\n\\n        bytes memory confidentialInputs = Suave.confidentialInputs();\\n        return abi.decode(confidentialInputs, (bytes));\\n    }\\n\\n    function emitDataRecord(Suave.DataRecord calldata dataRecord) public {\\n        emit DataRecordEvent(dataRecord.id, dataRecord.decryptionCondition, dataRecord.allowedPeekers);\\n    }\\n}\\n\\ncontract BundleContract is AnyBundleContract {\\n    function newBundle(\\n        uint64 decryptionCondition,\\n        address[] memory dataAllowedPeekers,\\n        address[] memory dataAllowedStores\\n    ) external payable returns (bytes memory) {\\n        require(Suave.isConfidential());\\n\\n        bytes memory bundleData = this.fetchConfidentialBundleData();\\n\\n        uint64 egp = Suave.simulateBundle(bundleData);\\n\\n        Suave.DataRecord memory dataRecord =\\n            Suave.newDataRecord(decryptionCondition, dataAllowedPeekers, dataAllowedStores, \\\"default:v0:ethBundles\\\");\\n\\n        Suave.confidentialStore(dataRecord.id, \\\"default:v0:ethBundles\\\", bundleData);\\n        Suave.confidentialStore(dataRecord.id, \\\"default:v0:ethBundleSimResults\\\", abi.encode(egp));\\n\\n        return emitAndReturn(dataRecord, bundleData);\\n    }\\n\\n    function emitAndReturn(Suave.DataRecord memory dataRecord, bytes memory) internal virtual returns (bytes memory) {\\n        emit DataRecordEvent(dataRecord.id, dataRecord.decryptionCondition, dataRecord.allowedPeekers);\\n        return bytes.concat(this.emitDataRecord.selector, abi.encode(dataRecord));\\n    }\\n}\\n\\ncontract EthBundleSenderContract is BundleContract {\\n    string[] public builderUrls;\\n\\n    constructor(string[] memory builderUrls_) {\\n        builderUrls = builderUrls_;\\n    }\\n\\n    function emitAndReturn(Suave.DataRecord memory dataRecord, bytes memory bundleData)\\n        internal\\n        virtual\\n        override\\n        returns (bytes memory)\\n    {\\n        for (uint256 i = 0; i < builderUrls.length; i++) {\\n            Suave.submitBundleJsonRPC(builderUrls[i], \\\"eth_sendBundle\\\", bundleData);\\n        }\\n\\n        return BundleContract.emitAndReturn(dataRecord, bundleData);\\n    }\\n}\\n\\ncontract MevShareContract is AnyBundleContract {\\n    event HintEvent(Suave.DataId dataId, bytes hint);\\n\\n    event MatchEvent(Suave.DataId matchDataId, bytes matchHint);\\n\\n    function newTransaction(\\n        uint64 decryptionCondition,\\n        address[] memory dataAllowedPeekers,\\n        address[] memory dataAllowedStores\\n    ) external payable returns (bytes memory) {\\n        // 0. check confidential execution\\n        require(Suave.isConfidential());\\n\\n        // 1. fetch bundle data\\n        bytes memory bundleData = this.fetchConfidentialBundleData();\\n\\n        // 2. sim bundle\\n        uint64 egp = Suave.simulateBundle(bundleData);\\n\\n        // 3. extract hint\\n        bytes memory hint = Suave.extractHint(bundleData);\\n\\n        // // 4. store bundle and sim results\\n        Suave.DataRecord memory dataRecord = Suave.newDataRecord(\\n            decryptionCondition, dataAllowedPeekers, dataAllowedStores, \\\"mevshare:v0:unmatchedBundles\\\"\\n        );\\n        Suave.confidentialStore(dataRecord.id, \\\"mevshare:v0:ethBundles\\\", bundleData);\\n        Suave.confidentialStore(dataRecord.id, \\\"mevshare:v0:ethBundleSimResults\\\", abi.encode(egp));\\n        emit DataRecordEvent(dataRecord.id, dataRecord.decryptionCondition, dataRecord.allowedPeekers);\\n        emit HintEvent(dataRecord.id, hint);\\n\\n        // // 5. return \\\"callback\\\" to emit hint onchain\\n        return bytes.concat(this.emitDataRecordAndHint.selector, abi.encode(dataRecord, hint));\\n    }\\n\\n    function emitDataRecordAndHint(Suave.DataRecord calldata dataRecord, bytes memory hint) public {\\n        emit DataRecordEvent(dataRecord.id, dataRecord.decryptionCondition, dataRecord.allowedPeekers);\\n        emit HintEvent(dataRecord.id, hint);\\n    }\\n\\n    function newMatch(\\n        uint64 decryptionCondition,\\n        address[] memory dataAllowedPeekers,\\n        address[] memory dataAllowedStores,\\n        Suave.DataId sharedataId\\n    ) external payable returns (bytes memory) {\\n        // WARNING : this function will copy the original mev share bid\\n        // into a new key with potentially different permsissions\\n\\n        require(Suave.isConfidential());\\n        // 1. fetch confidential data\\n        bytes memory matchBundleData = this.fetchConfidentialBundleData();\\n\\n        // 2. sim match alone for validity\\n        uint64 egp = Suave.simulateBundle(matchBundleData);\\n\\n        // 3. extract hint\\n        bytes memory matchHint = Suave.extractHint(matchBundleData);\\n\\n        Suave.DataRecord memory dataRecord = Suave.newDataRecord(\\n            decryptionCondition, dataAllowedPeekers, dataAllowedStores, \\\"mevshare:v0:matchDataRecords\\\"\\n        );\\n        Suave.confidentialStore(dataRecord.id, \\\"mevshare:v0:ethBundles\\\", matchBundleData);\\n        Suave.confidentialStore(dataRecord.id, \\\"mevshare:v0:ethBundleSimResults\\\", abi.encode(0));\\n\\n        //4. merge data records\\n        Suave.DataId[] memory dataRecords = new Suave.DataId[](2);\\n        dataRecords[0] = sharedataId;\\n        dataRecords[1] = dataRecord.id;\\n        Suave.confidentialStore(dataRecord.id, \\\"mevshare:v0:mergedDataRecords\\\", abi.encode(dataRecords));\\n\\n        return emitMatchDataRecordAndHint(dataRecord, matchHint);\\n    }\\n\\n    function emitMatchDataRecordAndHint(Suave.DataRecord memory dataRecord, bytes memory matchHint)\\n        internal\\n        virtual\\n        returns (bytes memory)\\n    {\\n        emit DataRecordEvent(dataRecord.id, dataRecord.decryptionCondition, dataRecord.allowedPeekers);\\n        emit MatchEvent(dataRecord.id, matchHint);\\n\\n        return bytes.concat(this.emitDataRecord.selector, abi.encode(dataRecord));\\n    }\\n}\\n\\ncontract MevShareBundleSenderContract is MevShareContract {\\n    string[] public builderUrls;\\n\\n    constructor(string[] memory builderUrls_) {\\n        builderUrls = builderUrls_;\\n    }\\n\\n    function emitMatchDataRecordAndHint(Suave.DataRecord memory dataRecord, bytes memory matchHint)\\n        internal\\n        virtual\\n        override\\n        returns (bytes memory)\\n    {\\n        bytes memory bundleData = Suave.fillMevShareBundle(dataRecord.id);\\n        for (uint256 i = 0; i < builderUrls.length; i++) {\\n            Suave.submitBundleJsonRPC(builderUrls[i], \\\"mev_sendBundle\\\", bundleData);\\n        }\\n\\n        return MevShareContract.emitMatchDataRecordAndHint(dataRecord, matchHint);\\n    }\\n}\\n\\n/* Not tested or implemented on the precompile side */\\nstruct EgpRecordPair {\\n    uint64 egp; // in wei, beware overflow\\n    Suave.DataId dataId;\\n}\\n\\ncontract EthBlockContract is AnyBundleContract {\\n    event BuilderBoostBidEvent(Suave.DataId dataId, bytes builderBid);\\n\\n    function idsEqual(Suave.DataId _l, Suave.DataId _r) public pure returns (bool) {\\n        bytes memory l = abi.encodePacked(_l);\\n        bytes memory r = abi.encodePacked(_r);\\n        for (uint256 i = 0; i < l.length; i++) {\\n            if (bytes(l)[i] != r[i]) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    function buildMevShare(Suave.BuildBlockArgs memory blockArgs, uint64 blockHeight) public returns (bytes memory) {\\n        require(Suave.isConfidential());\\n\\n        Suave.DataRecord[] memory allShareMatchDataRecords =\\n            Suave.fetchDataRecords(blockHeight, \\\"mevshare:v0:matchDataRecords\\\");\\n        Suave.DataRecord[] memory allShareUserDataRecords =\\n            Suave.fetchDataRecords(blockHeight, \\\"mevshare:v0:unmatchedBundles\\\");\\n\\n        if (allShareUserDataRecords.length == 0) {\\n            revert Suave.PeekerReverted(address(this), \\\"no data records\\\");\\n        }\\n\\n        Suave.DataRecord[] memory allRecords = new Suave.DataRecord[](allShareUserDataRecords.length);\\n        for (uint256 i = 0; i < allShareUserDataRecords.length; i++) {\\n            // TODO: sort matches by egp first!\\n            Suave.DataRecord memory dataRecordToInsert = allShareUserDataRecords[i]; // will be updated with the best match if any\\n            for (uint256 j = 0; j < allShareMatchDataRecords.length; j++) {\\n                // TODO: should be done once at the start and sorted\\n                Suave.DataId[] memory mergeddataIds = abi.decode(\\n                    Suave.confidentialRetrieve(allShareMatchDataRecords[j].id, \\\"mevshare:v0:mergedDataRecords\\\"),\\n                    (Suave.DataId[])\\n                );\\n                if (idsEqual(mergeddataIds[0], allShareUserDataRecords[i].id)) {\\n                    dataRecordToInsert = allShareMatchDataRecords[j];\\n                    break;\\n                }\\n            }\\n            allRecords[i] = dataRecordToInsert;\\n        }\\n\\n        EgpRecordPair[] memory bidsByEGP = new EgpRecordPair[](allRecords.length);\\n        for (uint256 i = 0; i < allRecords.length; i++) {\\n            bytes memory simResults = Suave.confidentialRetrieve(allRecords[i].id, \\\"mevshare:v0:ethBundleSimResults\\\");\\n            uint64 egp = abi.decode(simResults, (uint64));\\n            bidsByEGP[i] = EgpRecordPair(egp, allRecords[i].id);\\n        }\\n\\n        // Bubble sort, cause why not\\n        uint256 n = bidsByEGP.length;\\n        for (uint256 i = 0; i < n - 1; i++) {\\n            for (uint256 j = i + 1; j < n; j++) {\\n                if (bidsByEGP[i].egp < bidsByEGP[j].egp) {\\n                    EgpRecordPair memory temp = bidsByEGP[i];\\n                    bidsByEGP[i] = bidsByEGP[j];\\n                    bidsByEGP[j] = temp;\\n                }\\n            }\\n        }\\n\\n        Suave.DataId[] memory alldataIds = new Suave.DataId[](allRecords.length);\\n        for (uint256 i = 0; i < bidsByEGP.length; i++) {\\n            alldataIds[i] = bidsByEGP[i].dataId;\\n        }\\n\\n        return buildAndEmit(blockArgs, blockHeight, alldataIds, \\\"mevshare:v0\\\");\\n    }\\n\\n    function buildFromPool(Suave.BuildBlockArgs memory blockArgs, uint64 blockHeight) public returns (bytes memory) {\\n        require(Suave.isConfidential());\\n\\n        Suave.DataRecord[] memory allRecords = Suave.fetchDataRecords(blockHeight, \\\"default:v0:ethBundles\\\");\\n        if (allRecords.length == 0) {\\n            revert Suave.PeekerReverted(address(this), \\\"no data records\\\");\\n        }\\n\\n        EgpRecordPair[] memory bidsByEGP = new EgpRecordPair[](allRecords.length);\\n        for (uint256 i = 0; i < allRecords.length; i++) {\\n            bytes memory simResults = Suave.confidentialRetrieve(allRecords[i].id, \\\"default:v0:ethBundleSimResults\\\");\\n            uint64 egp = abi.decode(simResults, (uint64));\\n            bidsByEGP[i] = EgpRecordPair(egp, allRecords[i].id);\\n        }\\n\\n        // Bubble sort, cause why not\\n        uint256 n = bidsByEGP.length;\\n        for (uint256 i = 0; i < n - 1; i++) {\\n            for (uint256 j = i + 1; j < n; j++) {\\n                if (bidsByEGP[i].egp < bidsByEGP[j].egp) {\\n                    EgpRecordPair memory temp = bidsByEGP[i];\\n                    bidsByEGP[i] = bidsByEGP[j];\\n                    bidsByEGP[j] = temp;\\n                }\\n            }\\n        }\\n\\n        Suave.DataId[] memory alldataIds = new Suave.DataId[](allRecords.length);\\n        for (uint256 i = 0; i < bidsByEGP.length; i++) {\\n            alldataIds[i] = bidsByEGP[i].dataId;\\n        }\\n\\n        return buildAndEmit(blockArgs, blockHeight, alldataIds, \\\"\\\");\\n    }\\n\\n    function buildAndEmit(\\n        Suave.BuildBlockArgs memory blockArgs,\\n        uint64 blockHeight,\\n        Suave.DataId[] memory records,\\n        string memory relayUrl\\n    ) public virtual returns (bytes memory) {\\n        require(Suave.isConfidential());\\n\\n        (Suave.DataRecord memory blockBid, bytes memory builderBid) =\\n            this.doBuild(blockArgs, blockHeight, records, relayUrl);\\n\\n        emit BuilderBoostBidEvent(blockBid.id, builderBid);\\n        emit DataRecordEvent(blockBid.id, blockBid.decryptionCondition, blockBid.allowedPeekers);\\n        return bytes.concat(this.emitBuilderBidAndBid.selector, abi.encode(blockBid, builderBid));\\n    }\\n\\n    function doBuild(\\n        Suave.BuildBlockArgs memory blockArgs,\\n        uint64 blockHeight,\\n        Suave.DataId[] memory records,\\n        string memory relayUrl\\n    ) public returns (Suave.DataRecord memory, bytes memory) {\\n        address[] memory allowedPeekers = new address[](2);\\n        allowedPeekers[0] = address(this);\\n        allowedPeekers[1] = Suave.BUILD_ETH_BLOCK;\\n\\n        Suave.DataRecord memory blockBid =\\n            Suave.newDataRecord(blockHeight, allowedPeekers, allowedPeekers, \\\"default:v0:mergedDataRecords\\\");\\n        Suave.confidentialStore(blockBid.id, \\\"default:v0:mergedDataRecords\\\", abi.encode(records));\\n\\n        // todo: specify the builder - mainnet/holesky\\n        (bytes memory builderBid, bytes memory payload) = Suave.buildEthBlock(blockArgs, blockBid.id, relayUrl);\\n        Suave.confidentialStore(blockBid.id, \\\"default:v0:builderPayload\\\", payload); // only through this.unlock\\n\\n        return (blockBid, builderBid);\\n    }\\n\\n    function emitBuilderBidAndBid(Suave.DataRecord memory dataRecord, bytes memory builderBid)\\n        public\\n        returns (Suave.DataRecord memory, bytes memory)\\n    {\\n        emit BuilderBoostBidEvent(dataRecord.id, builderBid);\\n        emit DataRecordEvent(dataRecord.id, dataRecord.decryptionCondition, dataRecord.allowedPeekers);\\n        return (dataRecord, builderBid);\\n    }\\n\\n    function unlock(Suave.DataId dataId, bytes memory signedBlindedHeader) public returns (bytes memory) {\\n        require(Suave.isConfidential());\\n\\n        // TODO: verify the header is correct\\n        // TODO: incorporate protocol name\\n        bytes memory payload = Suave.confidentialRetrieve(dataId, \\\"default:v0:builderPayload\\\");\\n        return payload;\\n    }\\n}\\n\\ncontract EthBlockBidSenderContract is EthBlockContract {\\n    string boostRelayUrl;\\n\\n    constructor(string memory boostRelayUrl_) {\\n        boostRelayUrl = boostRelayUrl_;\\n    }\\n\\n    function buildAndEmit(\\n        Suave.BuildBlockArgs memory blockArgs,\\n        uint64 blockHeight,\\n        Suave.DataId[] memory dataRecords,\\n        string memory namespace\\n    ) public virtual override returns (bytes memory) {\\n        require(Suave.isConfidential());\\n\\n        (Suave.DataRecord memory blockDataRecord, bytes memory builderBid) =\\n            this.doBuild(blockArgs, blockHeight, dataRecords, namespace);\\n        Suave.submitEthBlockToRelay(boostRelayUrl, builderBid);\\n\\n        emit DataRecordEvent(blockDataRecord.id, blockDataRecord.decryptionCondition, blockDataRecord.allowedPeekers);\\n        return bytes.concat(this.emitDataRecord.selector, abi.encode(blockDataRecord));\\n    }\\n}\\n\",\"keccak256\":\"0x02df5891b0edb36844256712b85fd15bf3b5778204bee20b69d3ce3b51c2d14d\"},\"solady/src/utils/JSONParserLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library for parsing JSONs.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/JSONParserLib.sol)\\nlibrary JSONParserLib {\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The input is invalid.\\n    error ParsingFailed();\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    // There are 6 types of variables in JSON (excluding undefined).\\n\\n    /// @dev For denoting that an item has not been initialized.\\n    /// A item returned from `parse` will never be of an undefined type.\\n    /// Parsing a invalid JSON string will simply revert.\\n    uint8 internal constant TYPE_UNDEFINED = 0;\\n\\n    /// @dev Type representing an array (e.g. `[1,2,3]`).\\n    uint8 internal constant TYPE_ARRAY = 1;\\n\\n    /// @dev Type representing an object (e.g. `{\\\"a\\\":\\\"A\\\",\\\"b\\\":\\\"B\\\"}`).\\n    uint8 internal constant TYPE_OBJECT = 2;\\n\\n    /// @dev Type representing a number (e.g. `-1.23e+21`).\\n    uint8 internal constant TYPE_NUMBER = 3;\\n\\n    /// @dev Type representing a string (e.g. `\\\"hello\\\"`).\\n    uint8 internal constant TYPE_STRING = 4;\\n\\n    /// @dev Type representing a boolean (i.e. `true` or `false`).\\n    uint8 internal constant TYPE_BOOLEAN = 5;\\n\\n    /// @dev Type representing null (i.e. `null`).\\n    uint8 internal constant TYPE_NULL = 6;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                          STRUCTS                           */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev A pointer to a parsed JSON node.\\n    struct Item {\\n        // Do NOT modify the `_data` directly.\\n        uint256 _data;\\n    }\\n\\n    // Private constants for packing `_data`.\\n\\n    uint256 private constant _BITPOS_STRING = 32 * 7 - 8;\\n    uint256 private constant _BITPOS_KEY_LENGTH = 32 * 6 - 8;\\n    uint256 private constant _BITPOS_KEY = 32 * 5 - 8;\\n    uint256 private constant _BITPOS_VALUE_LENGTH = 32 * 4 - 8;\\n    uint256 private constant _BITPOS_VALUE = 32 * 3 - 8;\\n    uint256 private constant _BITPOS_CHILD = 32 * 2 - 8;\\n    uint256 private constant _BITPOS_SIBLING_OR_PARENT = 32 * 1 - 8;\\n    uint256 private constant _BITMASK_POINTER = 0xffffffff;\\n    uint256 private constant _BITMASK_TYPE = 7;\\n    uint256 private constant _KEY_INITED = 1 << 3;\\n    uint256 private constant _VALUE_INITED = 1 << 4;\\n    uint256 private constant _CHILDREN_INITED = 1 << 5;\\n    uint256 private constant _PARENT_IS_ARRAY = 1 << 6;\\n    uint256 private constant _PARENT_IS_OBJECT = 1 << 7;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                   JSON PARSING OPERATION                   */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Parses the JSON string `s`, and returns the root.\\n    /// Reverts if `s` is not a valid JSON as specified in RFC 8259.\\n    /// Object items WILL simply contain all their children, inclusive of repeated keys,\\n    /// in the same order which they appear in the JSON string.\\n    ///\\n    /// Note: For efficiency, this function WILL NOT make a copy of `s`.\\n    /// The parsed tree WILL contain offsets to `s`.\\n    /// Do NOT pass in a string that WILL be modified later on.\\n    function parse(string memory s) internal pure returns (Item memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x40, result) // We will use our own allocation instead.\\n        }\\n        bytes32 r = _query(_toInput(s), 255);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := r\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                    JSON ITEM OPERATIONS                    */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    // Note:\\n    // - An item is a node in the JSON tree.\\n    // - The value of a string item WILL be double-quoted, JSON encoded.\\n    // - We make a distinction between `index` and `key`.\\n    //   - Items in arrays are located by `index` (uint256).\\n    //   - Items in objects are located by `key` (string).\\n    // - Keys are always strings, double-quoted, JSON encoded.\\n    //\\n    // These design choices are made to balance between efficiency and ease-of-use.\\n\\n    /// @dev Returns the string value of the item.\\n    /// This is its exact string representation in the original JSON string.\\n    /// The returned string WILL have leading and trailing whitespace trimmed.\\n    /// All inner whitespace WILL be preserved, exactly as it is in the original JSON string.\\n    /// If the item's type is string, the returned string WILL be double-quoted, JSON encoded.\\n    ///\\n    /// Note: This function lazily instantiates and caches the returned string.\\n    /// Do NOT modify the returned string.\\n    function value(Item memory item) internal pure returns (string memory result) {\\n        bytes32 r = _query(_toInput(item), 0);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := r\\n        }\\n    }\\n\\n    /// @dev Returns the index of the item in the array.\\n    /// It the item's parent is not an array, returns 0.\\n    function index(Item memory item) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if and(mload(item), _PARENT_IS_ARRAY) {\\n                result := and(_BITMASK_POINTER, shr(_BITPOS_KEY, mload(item)))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the key of the item in the object.\\n    /// It the item's parent is not an object, returns an empty string.\\n    /// The returned string WILL be double-quoted, JSON encoded.\\n    ///\\n    /// Note: This function lazily instantiates and caches the returned string.\\n    /// Do NOT modify the returned string.\\n    function key(Item memory item) internal pure returns (string memory result) {\\n        if (item._data & _PARENT_IS_OBJECT != 0) {\\n            bytes32 r = _query(_toInput(item), 1);\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                result := r\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the key of the item in the object.\\n    /// It the item is neither an array nor object, returns an empty array.\\n    ///\\n    /// Note: This function lazily instantiates and caches the returned array.\\n    /// Do NOT modify the returned array.\\n    function children(Item memory item) internal pure returns (Item[] memory result) {\\n        bytes32 r = _query(_toInput(item), 3);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := r\\n        }\\n    }\\n\\n    /// @dev Returns the number of children.\\n    /// It the item is neither an array nor object, returns zero.\\n    function size(Item memory item) internal pure returns (uint256 result) {\\n        bytes32 r = _query(_toInput(item), 3);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(r)\\n        }\\n    }\\n\\n    /// @dev Returns the item at index `i` for (array).\\n    /// If `item` is not an array, the result's type WILL be undefined.\\n    /// If there is no item with the index, the result's type WILL be undefined.\\n    function at(Item memory item, uint256 i) internal pure returns (Item memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x40, result) // Free the default allocation. We'll allocate manually.\\n        }\\n        bytes32 r = _query(_toInput(item), 3);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(add(add(r, 0x20), shl(5, i)))\\n            if iszero(and(lt(i, mload(r)), eq(and(mload(item), _BITMASK_TYPE), TYPE_ARRAY))) {\\n                result := 0x60 // Reset to the zero pointer.\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the item at key `k` for (object).\\n    /// If `item` is not an object, the result's type WILL be undefined.\\n    /// The key MUST be double-quoted, JSON encoded. This is for efficiency reasons.\\n    /// - Correct : `item.at('\\\"k\\\"')`.\\n    /// - Wrong   : `item.at(\\\"k\\\")`.\\n    /// For duplicated keys, the last item with the key WILL be returned.\\n    /// If there is no item with the key, the result's type WILL be undefined.\\n    function at(Item memory item, string memory k) internal pure returns (Item memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x40, result) // Free the default allocation. We'll allocate manually.\\n            result := 0x60 // Initialize to the zero pointer.\\n        }\\n        if (isObject(item)) {\\n            bytes32 kHash = keccak256(bytes(k));\\n            Item[] memory r = children(item);\\n            // We'll just do a linear search. The alternatives are very bloated.\\n            for (uint256 i = r.length << 5; i != 0;) {\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    item := mload(add(r, i))\\n                    i := sub(i, 0x20)\\n                }\\n                if (keccak256(bytes(key(item))) != kHash) continue;\\n                result = item;\\n                break;\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the item's type.\\n    function getType(Item memory item) internal pure returns (uint8 result) {\\n        result = uint8(item._data & _BITMASK_TYPE);\\n    }\\n\\n    /// Note: All types are mutually exclusive.\\n\\n    /// @dev Returns whether the item is of type undefined.\\n    function isUndefined(Item memory item) internal pure returns (bool result) {\\n        result = item._data & _BITMASK_TYPE == TYPE_UNDEFINED;\\n    }\\n\\n    /// @dev Returns whether the item is of type array.\\n    function isArray(Item memory item) internal pure returns (bool result) {\\n        result = item._data & _BITMASK_TYPE == TYPE_ARRAY;\\n    }\\n\\n    /// @dev Returns whether the item is of type object.\\n    function isObject(Item memory item) internal pure returns (bool result) {\\n        result = item._data & _BITMASK_TYPE == TYPE_OBJECT;\\n    }\\n\\n    /// @dev Returns whether the item is of type number.\\n    function isNumber(Item memory item) internal pure returns (bool result) {\\n        result = item._data & _BITMASK_TYPE == TYPE_NUMBER;\\n    }\\n\\n    /// @dev Returns whether the item is of type string.\\n    function isString(Item memory item) internal pure returns (bool result) {\\n        result = item._data & _BITMASK_TYPE == TYPE_STRING;\\n    }\\n\\n    /// @dev Returns whether the item is of type boolean.\\n    function isBoolean(Item memory item) internal pure returns (bool result) {\\n        result = item._data & _BITMASK_TYPE == TYPE_BOOLEAN;\\n    }\\n\\n    /// @dev Returns whether the item is of type null.\\n    function isNull(Item memory item) internal pure returns (bool result) {\\n        result = item._data & _BITMASK_TYPE == TYPE_NULL;\\n    }\\n\\n    /// @dev Returns the item's parent.\\n    /// If the item does not have a parent, the result's type will be undefined.\\n    function parent(Item memory item) internal pure returns (Item memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x40, result) // Free the default allocation. We've already allocated.\\n            result := and(shr(_BITPOS_SIBLING_OR_PARENT, mload(item)), _BITMASK_POINTER)\\n            if iszero(result) { result := 0x60 } // Reset to the zero pointer.\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                     UTILITY FUNCTIONS                      */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Parses an unsigned integer from a string (in decimal, i.e. base 10).\\n    /// Reverts if `s` is not a valid uint256 string matching the RegEx `^[0-9]+$`,\\n    /// or if the parsed number is too big for a uint256.\\n    function parseUint(string memory s) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let n := mload(s)\\n            let preMulOverflowThres := div(not(0), 10)\\n            for { let i := 0 } 1 {} {\\n                i := add(i, 1)\\n                let digit := sub(and(mload(add(s, i)), 0xff), 48)\\n                let mulOverflowed := gt(result, preMulOverflowThres)\\n                let product := mul(10, result)\\n                result := add(product, digit)\\n                n := mul(n, iszero(or(or(mulOverflowed, lt(result, product)), gt(digit, 9))))\\n                if iszero(lt(i, n)) { break }\\n            }\\n            if iszero(n) {\\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Parses a signed integer from a string (in decimal, i.e. base 10).\\n    /// Reverts if `s` is not a valid int256 string matching the RegEx `^[+-]?[0-9]+$`,\\n    /// or if the parsed number cannot fit within `[-2**255 .. 2**255 - 1]`.\\n    function parseInt(string memory s) internal pure returns (int256 result) {\\n        uint256 n = bytes(s).length;\\n        uint256 sign;\\n        uint256 isNegative;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if n {\\n                let c := and(mload(add(s, 1)), 0xff)\\n                isNegative := eq(c, 45)\\n                if or(eq(c, 43), isNegative) {\\n                    sign := c\\n                    s := add(s, 1)\\n                    mstore(s, sub(n, 1))\\n                }\\n                if iszero(or(sign, lt(sub(c, 48), 10))) { s := 0x60 }\\n            }\\n        }\\n        uint256 x = parseUint(s);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(lt(x, add(shl(255, 1), isNegative))) {\\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if sign {\\n                mstore(s, sign)\\n                s := sub(s, 1)\\n                mstore(s, n)\\n            }\\n            result := xor(x, mul(xor(x, add(not(x), 1)), isNegative))\\n        }\\n    }\\n\\n    /// @dev Parses an unsigned integer from a string (in hexadecimal, i.e. base 16).\\n    /// Reverts if `s` is not a valid uint256 hex string matching the RegEx\\n    /// `^(0[xX])?[0-9a-fA-F]+$`, or if the parsed number cannot fit within `[0 .. 2**256 - 1]`.\\n    function parseUintFromHex(string memory s) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let n := mload(s)\\n            // Skip two if starts with '0x' or '0X'.\\n            let i := shl(1, and(eq(0x3078, or(shr(240, mload(add(s, 0x20))), 0x20)), gt(n, 1)))\\n            for {} 1 {} {\\n                i := add(i, 1)\\n                let c :=\\n                    byte(\\n                        and(0x1f, shr(and(mload(add(s, i)), 0xff), 0x3e4088843e41bac000000000000)),\\n                        0x3010a071000000b0104040208000c05090d060e0f\\n                    )\\n                n := mul(n, iszero(or(iszero(c), shr(252, result))))\\n                result := add(shl(4, result), sub(c, 1))\\n                if iszero(lt(i, n)) { break }\\n            }\\n            if iszero(n) {\\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Decodes a JSON encoded string.\\n    /// The string MUST be double-quoted, JSON encoded.\\n    /// Reverts if the string is invalid.\\n    /// As you can see, it's pretty complex for a deceptively simple looking task.\\n    function decodeString(string memory s) internal pure returns (string memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            function fail() {\\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n\\n            function decodeUnicodeEscapeSequence(pIn_, end_) -> _unicode, _pOut {\\n                _pOut := add(pIn_, 4)\\n                let b_ := iszero(gt(_pOut, end_))\\n                let t_ := mload(pIn_) // Load the whole word.\\n                for { let i_ := 0 } iszero(eq(i_, 4)) { i_ := add(i_, 1) } {\\n                    let c_ := sub(byte(i_, t_), 48)\\n                    if iszero(and(shr(c_, 0x7e0000007e03ff), b_)) { fail() } // Not hexadecimal.\\n                    c_ := sub(c_, add(mul(gt(c_, 16), 7), shl(5, gt(c_, 48))))\\n                    _unicode := add(shl(4, _unicode), c_)\\n                }\\n            }\\n\\n            function decodeUnicodeCodePoint(pIn_, end_) -> _unicode, _pOut {\\n                _unicode, _pOut := decodeUnicodeEscapeSequence(pIn_, end_)\\n                if iszero(or(lt(_unicode, 0xd800), gt(_unicode, 0xdbff))) {\\n                    let t_ := mload(_pOut) // Load the whole word.\\n                    end_ := mul(end_, eq(shr(240, t_), 0x5c75)) // Fail if not starting with '\\\\\\\\u'.\\n                    t_, _pOut := decodeUnicodeEscapeSequence(add(_pOut, 2), end_)\\n                    _unicode := add(0x10000, add(shl(10, and(0x3ff, _unicode)), and(0x3ff, t_)))\\n                }\\n            }\\n\\n            function appendCodePointAsUTF8(pIn_, c_) -> _pOut {\\n                if iszero(gt(c_, 0x7f)) {\\n                    mstore8(pIn_, c_)\\n                    _pOut := add(pIn_, 1)\\n                    leave\\n                }\\n                mstore8(0x1f, c_)\\n                mstore8(0x1e, shr(6, c_))\\n                if iszero(gt(c_, 0x7ff)) {\\n                    mstore(pIn_, shl(240, or(0xc080, and(0x1f3f, mload(0x00)))))\\n                    _pOut := add(pIn_, 2)\\n                    leave\\n                }\\n                mstore8(0x1d, shr(12, c_))\\n                if iszero(gt(c_, 0xffff)) {\\n                    mstore(pIn_, shl(232, or(0xe08080, and(0x0f3f3f, mload(0x00)))))\\n                    _pOut := add(pIn_, 3)\\n                    leave\\n                }\\n                mstore8(0x1c, shr(18, c_))\\n                mstore(pIn_, shl(224, or(0xf0808080, and(0x073f3f3f, mload(0x00)))))\\n                _pOut := add(pIn_, shl(2, lt(c_, 0x110000)))\\n            }\\n\\n            function chr(p_) -> _c {\\n                _c := byte(0, mload(p_))\\n            }\\n\\n            let n := mload(s)\\n            let end := add(add(s, n), 0x1f)\\n            if iszero(and(gt(n, 1), eq(0x2222, or(and(0xff00, mload(add(s, 2))), chr(end))))) {\\n                fail() // Fail if not double-quoted.\\n            }\\n            let out := add(mload(0x40), 0x20)\\n            for { let curr := add(s, 0x21) } iszero(eq(curr, end)) {} {\\n                let c := chr(curr)\\n                curr := add(curr, 1)\\n                // Not '\\\\\\\\'.\\n                if iszero(eq(c, 92)) {\\n                    // Not '\\\"'.\\n                    if iszero(eq(c, 34)) {\\n                        mstore8(out, c)\\n                        out := add(out, 1)\\n                        continue\\n                    }\\n                    curr := end\\n                }\\n                if iszero(eq(curr, end)) {\\n                    let escape := chr(curr)\\n                    curr := add(curr, 1)\\n                    // '\\\"', '/', '\\\\\\\\'.\\n                    if and(shr(escape, 0x100000000000800400000000), 1) {\\n                        mstore8(out, escape)\\n                        out := add(out, 1)\\n                        continue\\n                    }\\n                    // 'u'.\\n                    if eq(escape, 117) {\\n                        escape, curr := decodeUnicodeCodePoint(curr, end)\\n                        out := appendCodePointAsUTF8(out, escape)\\n                        continue\\n                    }\\n                    // `{'b':'\\\\b', 'f':'\\\\f', 'n':'\\\\n', 'r':'\\\\r', 't':'\\\\t'}`.\\n                    escape := byte(sub(escape, 85), 0x080000000c000000000000000a0000000d0009)\\n                    if escape {\\n                        mstore8(out, escape)\\n                        out := add(out, 1)\\n                        continue\\n                    }\\n                }\\n                fail()\\n                break\\n            }\\n            mstore(out, 0) // Zeroize the last slot.\\n            result := mload(0x40)\\n            mstore(result, sub(out, add(result, 0x20))) // Store the length.\\n            mstore(0x40, add(out, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                      PRIVATE HELPERS                       */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Performs a query on the input with the given mode.\\n    function _query(bytes32 input, uint256 mode) private pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            function fail() {\\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n\\n            function chr(p_) -> _c {\\n                _c := byte(0, mload(p_))\\n            }\\n\\n            function skipWhitespace(pIn_, end_) -> _pOut {\\n                for { _pOut := pIn_ } 1 { _pOut := add(_pOut, 1) } {\\n                    if iszero(and(shr(chr(_pOut), 0x100002600), 1)) { leave } // Not in ' \\\\n\\\\r\\\\t'.\\n                }\\n            }\\n\\n            function setP(packed_, bitpos_, p_) -> _packed {\\n                // Perform an out-of-gas revert if `p_` exceeds `_BITMASK_POINTER`.\\n                returndatacopy(returndatasize(), returndatasize(), gt(p_, _BITMASK_POINTER))\\n                _packed := or(and(not(shl(bitpos_, _BITMASK_POINTER)), packed_), shl(bitpos_, p_))\\n            }\\n\\n            function getP(packed_, bitpos_) -> _p {\\n                _p := and(_BITMASK_POINTER, shr(bitpos_, packed_))\\n            }\\n\\n            function mallocItem(s_, packed_, pStart_, pCurr_, type_) -> _item {\\n                _item := mload(0x40)\\n                // forgefmt: disable-next-item\\n                packed_ := setP(setP(packed_, _BITPOS_VALUE, sub(pStart_, add(s_, 0x20))),\\n                    _BITPOS_VALUE_LENGTH, sub(pCurr_, pStart_))\\n                mstore(_item, or(packed_, type_))\\n                mstore(0x40, add(_item, 0x20)) // Allocate memory.\\n            }\\n\\n            function parseValue(s_, sibling_, pIn_, end_) -> _item, _pOut {\\n                let packed_ := setP(mload(0x00), _BITPOS_SIBLING_OR_PARENT, sibling_)\\n                _pOut := skipWhitespace(pIn_, end_)\\n                if iszero(lt(_pOut, end_)) { leave }\\n                for { let c_ := chr(_pOut) } 1 {} {\\n                    // If starts with '\\\"'.\\n                    if eq(c_, 34) {\\n                        let pStart_ := _pOut\\n                        _pOut := parseStringSub(s_, packed_, _pOut, end_)\\n                        _item := mallocItem(s_, packed_, pStart_, _pOut, TYPE_STRING)\\n                        break\\n                    }\\n                    // If starts with '['.\\n                    if eq(c_, 91) {\\n                        _item, _pOut := parseArray(s_, packed_, _pOut, end_)\\n                        break\\n                    }\\n                    // If starts with '{'.\\n                    if eq(c_, 123) {\\n                        _item, _pOut := parseObject(s_, packed_, _pOut, end_)\\n                        break\\n                    }\\n                    // If starts with any in '0123456789-'.\\n                    if and(shr(c_, shl(45, 0x1ff9)), 1) {\\n                        _item, _pOut := parseNumber(s_, packed_, _pOut, end_)\\n                        break\\n                    }\\n                    if iszero(gt(add(_pOut, 4), end_)) {\\n                        let pStart_ := _pOut\\n                        let w_ := shr(224, mload(_pOut))\\n                        // 'true' in hex format.\\n                        if eq(w_, 0x74727565) {\\n                            _pOut := add(_pOut, 4)\\n                            _item := mallocItem(s_, packed_, pStart_, _pOut, TYPE_BOOLEAN)\\n                            break\\n                        }\\n                        // 'null' in hex format.\\n                        if eq(w_, 0x6e756c6c) {\\n                            _pOut := add(_pOut, 4)\\n                            _item := mallocItem(s_, packed_, pStart_, _pOut, TYPE_NULL)\\n                            break\\n                        }\\n                    }\\n                    if iszero(gt(add(_pOut, 5), end_)) {\\n                        let pStart_ := _pOut\\n                        let w_ := shr(216, mload(_pOut))\\n                        // 'false' in hex format.\\n                        if eq(w_, 0x66616c7365) {\\n                            _pOut := add(_pOut, 5)\\n                            _item := mallocItem(s_, packed_, pStart_, _pOut, TYPE_BOOLEAN)\\n                            break\\n                        }\\n                    }\\n                    fail()\\n                    break\\n                }\\n                _pOut := skipWhitespace(_pOut, end_)\\n            }\\n\\n            function parseArray(s_, packed_, pIn_, end_) -> _item, _pOut {\\n                let j_ := 0\\n                for { _pOut := add(pIn_, 1) } 1 { _pOut := add(_pOut, 1) } {\\n                    if iszero(lt(_pOut, end_)) { fail() }\\n                    if iszero(_item) {\\n                        _pOut := skipWhitespace(_pOut, end_)\\n                        if eq(chr(_pOut), 93) { break } // ']'.\\n                    }\\n                    _item, _pOut := parseValue(s_, _item, _pOut, end_)\\n                    if _item {\\n                        // forgefmt: disable-next-item\\n                        mstore(_item, setP(or(_PARENT_IS_ARRAY, mload(_item)),\\n                            _BITPOS_KEY, j_))\\n                        j_ := add(j_, 1)\\n                        let c_ := chr(_pOut)\\n                        if eq(c_, 93) { break } // ']'.\\n                        if eq(c_, 44) { continue } // ','.\\n                    }\\n                    _pOut := end_\\n                }\\n                _pOut := add(_pOut, 1)\\n                packed_ := setP(packed_, _BITPOS_CHILD, _item)\\n                _item := mallocItem(s_, packed_, pIn_, _pOut, TYPE_ARRAY)\\n            }\\n\\n            function parseObject(s_, packed_, pIn_, end_) -> _item, _pOut {\\n                for { _pOut := add(pIn_, 1) } 1 { _pOut := add(_pOut, 1) } {\\n                    if iszero(lt(_pOut, end_)) { fail() }\\n                    if iszero(_item) {\\n                        _pOut := skipWhitespace(_pOut, end_)\\n                        if eq(chr(_pOut), 125) { break } // '}'.\\n                    }\\n                    _pOut := skipWhitespace(_pOut, end_)\\n                    let pKeyStart_ := _pOut\\n                    let pKeyEnd_ := parseStringSub(s_, _item, _pOut, end_)\\n                    _pOut := skipWhitespace(pKeyEnd_, end_)\\n                    // If ':'.\\n                    if eq(chr(_pOut), 58) {\\n                        _item, _pOut := parseValue(s_, _item, add(_pOut, 1), end_)\\n                        if _item {\\n                            // forgefmt: disable-next-item\\n                            mstore(_item, setP(setP(or(_PARENT_IS_OBJECT, mload(_item)),\\n                                _BITPOS_KEY_LENGTH, sub(pKeyEnd_, pKeyStart_)),\\n                                    _BITPOS_KEY, sub(pKeyStart_, add(s_, 0x20))))\\n                            let c_ := chr(_pOut)\\n                            if eq(c_, 125) { break } // '}'.\\n                            if eq(c_, 44) { continue } // ','.\\n                        }\\n                    }\\n                    _pOut := end_\\n                }\\n                _pOut := add(_pOut, 1)\\n                packed_ := setP(packed_, _BITPOS_CHILD, _item)\\n                _item := mallocItem(s_, packed_, pIn_, _pOut, TYPE_OBJECT)\\n            }\\n\\n            function checkStringU(p_, o_) {\\n                // If not in '0123456789abcdefABCDEF', revert.\\n                if iszero(and(shr(sub(chr(add(p_, o_)), 48), 0x7e0000007e03ff), 1)) { fail() }\\n                if iszero(eq(o_, 5)) { checkStringU(p_, add(o_, 1)) }\\n            }\\n\\n            function parseStringSub(s_, packed_, pIn_, end_) -> _pOut {\\n                if iszero(lt(pIn_, end_)) { fail() }\\n                for { _pOut := add(pIn_, 1) } 1 {} {\\n                    let c_ := chr(_pOut)\\n                    if eq(c_, 34) { break } // '\\\"'.\\n                    // Not '\\\\'.\\n                    if iszero(eq(c_, 92)) {\\n                        _pOut := add(_pOut, 1)\\n                        continue\\n                    }\\n                    c_ := chr(add(_pOut, 1))\\n                    // '\\\"', '\\\\', '//', 'b', 'f', 'n', 'r', 't'.\\n                    if and(shr(sub(c_, 34), 0x510110400000000002001), 1) {\\n                        _pOut := add(_pOut, 2)\\n                        continue\\n                    }\\n                    // 'u'.\\n                    if eq(c_, 117) {\\n                        checkStringU(_pOut, 2)\\n                        _pOut := add(_pOut, 6)\\n                        continue\\n                    }\\n                    _pOut := end_\\n                    break\\n                }\\n                if iszero(lt(_pOut, end_)) { fail() }\\n                _pOut := add(_pOut, 1)\\n            }\\n\\n            function skip0To9s(pIn_, end_, atLeastOne_) -> _pOut {\\n                for { _pOut := pIn_ } 1 { _pOut := add(_pOut, 1) } {\\n                    if iszero(lt(sub(chr(_pOut), 48), 10)) { break } // Not '0'..'9'.\\n                }\\n                if and(atLeastOne_, eq(pIn_, _pOut)) { fail() }\\n            }\\n\\n            function parseNumber(s_, packed_, pIn_, end_) -> _item, _pOut {\\n                _pOut := pIn_\\n                if eq(chr(_pOut), 45) { _pOut := add(_pOut, 1) } // '-'.\\n                if iszero(lt(sub(chr(_pOut), 48), 10)) { fail() } // Not '0'..'9'.\\n                let c_ := chr(_pOut)\\n                _pOut := add(_pOut, 1)\\n                if iszero(eq(c_, 48)) { _pOut := skip0To9s(_pOut, end_, 0) } // Not '0'.\\n                if eq(chr(_pOut), 46) { _pOut := skip0To9s(add(_pOut, 1), end_, 1) } // '.'.\\n                let t_ := mload(_pOut)\\n                // 'E', 'e'.\\n                if eq(or(0x20, byte(0, t_)), 101) {\\n                    // forgefmt: disable-next-item\\n                    _pOut := skip0To9s(add(byte(sub(byte(1, t_), 14), 0x010001), // '+', '-'.\\n                        add(_pOut, 1)), end_, 1)\\n                }\\n                _item := mallocItem(s_, packed_, pIn_, _pOut, TYPE_NUMBER)\\n            }\\n\\n            function copyStr(s_, offset_, len_) -> _sCopy {\\n                _sCopy := mload(0x40)\\n                s_ := add(s_, offset_)\\n                let w_ := not(0x1f)\\n                for { let i_ := and(add(len_, 0x1f), w_) } 1 {} {\\n                    mstore(add(_sCopy, i_), mload(add(s_, i_)))\\n                    i_ := add(i_, w_) // `sub(i_, 0x20)`.\\n                    if iszero(i_) { break }\\n                }\\n                mstore(_sCopy, len_) // Copy the length.\\n                mstore(add(add(_sCopy, 0x20), len_), 0) // Zeroize the last slot.\\n                mstore(0x40, add(add(_sCopy, 0x40), len_)) // Allocate memory.\\n            }\\n\\n            function value(item_) -> _value {\\n                let packed_ := mload(item_)\\n                _value := getP(packed_, _BITPOS_VALUE) // The offset in the string.\\n                if iszero(and(_VALUE_INITED, packed_)) {\\n                    let s_ := getP(packed_, _BITPOS_STRING)\\n                    _value := copyStr(s_, _value, getP(packed_, _BITPOS_VALUE_LENGTH))\\n                    packed_ := setP(packed_, _BITPOS_VALUE, _value)\\n                    mstore(s_, or(_VALUE_INITED, packed_))\\n                }\\n            }\\n\\n            function children(item_) -> _arr {\\n                _arr := 0x60 // Initialize to the zero pointer.\\n                let packed_ := mload(item_)\\n                for {} iszero(gt(and(_BITMASK_TYPE, packed_), TYPE_OBJECT)) {} {\\n                    if or(iszero(packed_), iszero(item_)) { break }\\n                    if and(packed_, _CHILDREN_INITED) {\\n                        _arr := getP(packed_, _BITPOS_CHILD)\\n                        break\\n                    }\\n                    _arr := mload(0x40)\\n                    let o_ := add(_arr, 0x20)\\n                    for { let h_ := getP(packed_, _BITPOS_CHILD) } h_ {} {\\n                        mstore(o_, h_)\\n                        let q_ := mload(h_)\\n                        let y_ := getP(q_, _BITPOS_SIBLING_OR_PARENT)\\n                        mstore(h_, setP(q_, _BITPOS_SIBLING_OR_PARENT, item_))\\n                        h_ := y_\\n                        o_ := add(o_, 0x20)\\n                    }\\n                    let w_ := not(0x1f)\\n                    let n_ := add(w_, sub(o_, _arr))\\n                    mstore(_arr, shr(5, n_))\\n                    mstore(0x40, o_) // Allocate memory.\\n                    packed_ := setP(packed_, _BITPOS_CHILD, _arr)\\n                    mstore(item_, or(_CHILDREN_INITED, packed_))\\n                    // Reverse the array.\\n                    if iszero(lt(n_, 0x40)) {\\n                        let lo_ := add(_arr, 0x20)\\n                        let hi_ := add(_arr, n_)\\n                        for {} 1 {} {\\n                            let temp_ := mload(lo_)\\n                            mstore(lo_, mload(hi_))\\n                            mstore(hi_, temp_)\\n                            hi_ := add(hi_, w_)\\n                            lo_ := add(lo_, 0x20)\\n                            if iszero(lt(lo_, hi_)) { break }\\n                        }\\n                    }\\n                    break\\n                }\\n            }\\n\\n            function getStr(item_, bitpos_, bitposLength_, bitmaskInited_) -> _result {\\n                _result := 0x60 // Initialize to the zero pointer.\\n                let packed_ := mload(item_)\\n                if or(iszero(item_), iszero(packed_)) { leave }\\n                _result := getP(packed_, bitpos_)\\n                if iszero(and(bitmaskInited_, packed_)) {\\n                    let s_ := getP(packed_, _BITPOS_STRING)\\n                    _result := copyStr(s_, _result, getP(packed_, bitposLength_))\\n                    mstore(item_, or(bitmaskInited_, setP(packed_, bitpos_, _result)))\\n                }\\n            }\\n\\n            switch mode\\n            // Get value.\\n            case 0 { result := getStr(input, _BITPOS_VALUE, _BITPOS_VALUE_LENGTH, _VALUE_INITED) }\\n            // Get key.\\n            case 1 { result := getStr(input, _BITPOS_KEY, _BITPOS_KEY_LENGTH, _KEY_INITED) }\\n            // Get children.\\n            case 3 { result := children(input) }\\n            // Parse.\\n            default {\\n                let p := add(input, 0x20)\\n                let e := add(p, mload(input))\\n                if iszero(eq(p, e)) {\\n                    let c := chr(e)\\n                    mstore8(e, 34) // Place a '\\\"' at the end to speed up parsing.\\n                    // The `34 << 248` makes `mallocItem` preserve '\\\"' at the end.\\n                    mstore(0x00, setP(shl(248, 34), _BITPOS_STRING, input))\\n                    result, p := parseValue(input, 0, p, e)\\n                    mstore8(e, c) // Restore the original char at the end.\\n                }\\n                if or(lt(p, e), iszero(result)) { fail() }\\n            }\\n        }\\n    }\\n\\n    /// @dev Casts the input to a bytes32.\\n    function _toInput(string memory input) private pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := input\\n        }\\n    }\\n\\n    /// @dev Casts the input to a bytes32.\\n    function _toInput(Item memory input) private pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := input\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x24ddc4015b10af1bcf9eb4fd69d1e03a575698b0104b9ecc60c0c25464cd4d03\",\"license\":\"MIT\"},\"solady/src/utils/LibString.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library for converting numbers into strings and other string operations.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibString.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)\\n///\\n/// Note:\\n/// For performance and bytecode compactness, most of the string operations are restricted to\\n/// byte strings (7-bit ASCII), except where otherwise specified.\\n/// Usage of byte string operations on charsets with runes spanning two or more bytes\\n/// can lead to undefined behavior.\\nlibrary LibString {\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                        CUSTOM ERRORS                       */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The length of the output is too small to contain all the hex digits.\\n    error HexLengthInsufficient();\\n\\n    /// @dev The length of the string is more than 32 bytes.\\n    error TooBigForSmallString();\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The constant returned when the `search` is not found in the string.\\n    uint256 internal constant NOT_FOUND = type(uint256).max;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                     DECIMAL OPERATIONS                     */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns the base 10 decimal representation of `value`.\\n    function toString(uint256 value) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\\n            // and 3 words for a maximum of 78 digits.\\n            str := add(mload(0x40), 0x80)\\n            // Update the free memory pointer to allocate.\\n            mstore(0x40, add(str, 0x20))\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end of the memory to calculate the length later.\\n            let end := str\\n\\n            let w := not(0) // Tsk.\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for { let temp := value } 1 {} {\\n                str := add(str, w) // `sub(str, 1)`.\\n                // Write the character to the pointer.\\n                // The ASCII index of the '0' character is 48.\\n                mstore8(str, add(48, mod(temp, 10)))\\n                // Keep dividing `temp` until zero.\\n                temp := div(temp, 10)\\n                if iszero(temp) { break }\\n            }\\n\\n            let length := sub(end, str)\\n            // Move the pointer 32 bytes leftwards to make room for the length.\\n            str := sub(str, 0x20)\\n            // Store the length.\\n            mstore(str, length)\\n        }\\n    }\\n\\n    /// @dev Returns the base 10 decimal representation of `value`.\\n    function toString(int256 value) internal pure returns (string memory str) {\\n        if (value >= 0) {\\n            return toString(uint256(value));\\n        }\\n        unchecked {\\n            str = toString(~uint256(value) + 1);\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We still have some spare memory space on the left,\\n            // as we have allocated 3 words (96 bytes) for up to 78 digits.\\n            let length := mload(str) // Load the string length.\\n            mstore(str, 0x2d) // Store the '-' character.\\n            str := sub(str, 1) // Move back the string pointer by a byte.\\n            mstore(str, add(length, 1)) // Update the string length.\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                   HEXADECIMAL OPERATIONS                   */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns the hexadecimal representation of `value`,\\n    /// left-padded to an input length of `length` bytes.\\n    /// The output is prefixed with \\\"0x\\\" encoded using 2 hexadecimal digits per byte,\\n    /// giving a total length of `length * 2 + 2` bytes.\\n    /// Reverts if `length` is too small for the output to contain all the digits.\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value, length);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Write the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`,\\n    /// left-padded to an input length of `length` bytes.\\n    /// The output is prefixed with \\\"0x\\\" encoded using 2 hexadecimal digits per byte,\\n    /// giving a total length of `length * 2` bytes.\\n    /// Reverts if `length` is too small for the output to contain all the digits.\\n    function toHexStringNoPrefix(uint256 value, uint256 length)\\n        internal\\n        pure\\n        returns (string memory str)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes\\n            // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.\\n            // We add 0x20 to the total and round down to a multiple of 0x20.\\n            // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.\\n            str := add(mload(0x40), and(add(shl(1, length), 0x42), not(0x1f)))\\n            // Allocate the memory.\\n            mstore(0x40, add(str, 0x20))\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end to calculate the length later.\\n            let end := str\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            let start := sub(str, add(length, length))\\n            let w := not(1) // Tsk.\\n            let temp := value\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for {} 1 {} {\\n                str := add(str, w) // `sub(str, 2)`.\\n                mstore8(add(str, 1), mload(and(temp, 15)))\\n                mstore8(str, mload(and(shr(4, temp), 15)))\\n                temp := shr(8, temp)\\n                if iszero(xor(str, start)) { break }\\n            }\\n\\n            if temp {\\n                mstore(0x00, 0x2194895a) // `HexLengthInsufficient()`.\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Compute the string's length.\\n            let strLength := sub(end, str)\\n            // Move the pointer and write the length.\\n            str := sub(str, 0x20)\\n            mstore(str, strLength)\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\" and encoded using 2 hexadecimal digits per byte.\\n    /// As address are 20 bytes long, the output will left-padded to have\\n    /// a length of `20 * 2 + 2` bytes.\\n    function toHexString(uint256 value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Write the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\".\\n    /// The output excludes leading \\\"0\\\" from the `toHexString` output.\\n    /// `0x00: \\\"0x0\\\", 0x01: \\\"0x1\\\", 0x12: \\\"0x12\\\", 0x123: \\\"0x123\\\"`.\\n    function toMinimalHexString(uint256 value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(add(str, o), 0x3078) // Write the \\\"0x\\\" prefix, accounting for leading zero.\\n            str := sub(add(str, o), 2) // Move the pointer, accounting for leading zero.\\n            mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output excludes leading \\\"0\\\" from the `toHexStringNoPrefix` output.\\n    /// `0x00: \\\"0\\\", 0x01: \\\"1\\\", 0x12: \\\"12\\\", 0x123: \\\"123\\\"`.\\n    function toMinimalHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\\n            let strLength := mload(str) // Get the length.\\n            str := add(str, o) // Move the pointer, accounting for leading zero.\\n            mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    /// As address are 20 bytes long, the output will left-padded to have\\n    /// a length of `20 * 2` bytes.\\n    function toHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\\n            // 0x02 bytes for the prefix, and 0x40 bytes for the digits.\\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.\\n            str := add(mload(0x40), 0x80)\\n            // Allocate the memory.\\n            mstore(0x40, add(str, 0x20))\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end to calculate the length later.\\n            let end := str\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            let w := not(1) // Tsk.\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for { let temp := value } 1 {} {\\n                str := add(str, w) // `sub(str, 2)`.\\n                mstore8(add(str, 1), mload(and(temp, 15)))\\n                mstore8(str, mload(and(shr(4, temp), 15)))\\n                temp := shr(8, temp)\\n                if iszero(temp) { break }\\n            }\\n\\n            // Compute the string's length.\\n            let strLength := sub(end, str)\\n            // Move the pointer and write the length.\\n            str := sub(str, 0x20)\\n            mstore(str, strLength)\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\", encoded using 2 hexadecimal digits per byte,\\n    /// and the alphabets are capitalized conditionally according to\\n    /// https://eips.ethereum.org/EIPS/eip-55\\n    function toHexStringChecksummed(address value) internal pure returns (string memory str) {\\n        str = toHexString(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`\\n            let o := add(str, 0x22)\\n            let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `\\n            let t := shl(240, 136) // `0b10001000 << 240`\\n            for { let i := 0 } 1 {} {\\n                mstore(add(i, i), mul(t, byte(i, hashed)))\\n                i := add(i, 1)\\n                if eq(i, 20) { break }\\n            }\\n            mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))\\n            o := add(o, 0x20)\\n            mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\" and encoded using 2 hexadecimal digits per byte.\\n    function toHexString(address value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Write the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    function toHexStringNoPrefix(address value) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            str := mload(0x40)\\n\\n            // Allocate the memory.\\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\\n            // 0x02 bytes for the prefix, and 0x28 bytes for the digits.\\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.\\n            mstore(0x40, add(str, 0x80))\\n\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            str := add(str, 2)\\n            mstore(str, 40)\\n\\n            let o := add(str, 0x20)\\n            mstore(add(o, 40), 0)\\n\\n            value := shl(96, value)\\n\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for { let i := 0 } 1 {} {\\n                let p := add(o, add(i, i))\\n                let temp := byte(i, value)\\n                mstore8(add(p, 1), mload(and(temp, 15)))\\n                mstore8(p, mload(shr(4, temp)))\\n                i := add(i, 1)\\n                if eq(i, 20) { break }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the hex encoded string from the raw bytes.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    function toHexString(bytes memory raw) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(raw);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Write the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hex encoded string from the raw bytes.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    function toHexStringNoPrefix(bytes memory raw) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let length := mload(raw)\\n            str := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.\\n            mstore(str, add(length, length)) // Store the length of the output.\\n\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            let o := add(str, 0x20)\\n            let end := add(raw, length)\\n\\n            for {} iszero(eq(raw, end)) {} {\\n                raw := add(raw, 1)\\n                mstore8(add(o, 1), mload(and(mload(raw), 15)))\\n                mstore8(o, mload(and(shr(4, mload(raw)), 15)))\\n                o := add(o, 2)\\n            }\\n            mstore(o, 0) // Zeroize the slot after the string.\\n            mstore(0x40, add(o, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                   RUNE STRING OPERATIONS                   */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns the number of UTF characters in the string.\\n    function runeCount(string memory s) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if mload(s) {\\n                mstore(0x00, div(not(0), 255))\\n                mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)\\n                let o := add(s, 0x20)\\n                let end := add(o, mload(s))\\n                for { result := 1 } 1 { result := add(result, 1) } {\\n                    o := add(o, byte(0, mload(shr(250, mload(o)))))\\n                    if iszero(lt(o, end)) { break }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns if this string is a 7-bit ASCII string.\\n    /// (i.e. all characters codes are in [0..127])\\n    function is7BitASCII(string memory s) internal pure returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let mask := shl(7, div(not(0), 255))\\n            result := 1\\n            let n := mload(s)\\n            if n {\\n                let o := add(s, 0x20)\\n                let end := add(o, n)\\n                let last := mload(end)\\n                mstore(end, 0)\\n                for {} 1 {} {\\n                    if and(mask, mload(o)) {\\n                        result := 0\\n                        break\\n                    }\\n                    o := add(o, 0x20)\\n                    if iszero(lt(o, end)) { break }\\n                }\\n                mstore(end, last)\\n            }\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                   BYTE STRING OPERATIONS                   */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    // For performance and bytecode compactness, byte string operations are restricted\\n    // to 7-bit ASCII strings. All offsets are byte offsets, not UTF character offsets.\\n    // Usage of byte string operations on charsets with runes spanning two or more bytes\\n    // can lead to undefined behavior.\\n\\n    /// @dev Returns `subject` all occurrences of `search` replaced with `replacement`.\\n    function replace(string memory subject, string memory search, string memory replacement)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            let searchLength := mload(search)\\n            let replacementLength := mload(replacement)\\n\\n            subject := add(subject, 0x20)\\n            search := add(search, 0x20)\\n            replacement := add(replacement, 0x20)\\n            result := add(mload(0x40), 0x20)\\n\\n            let subjectEnd := add(subject, subjectLength)\\n            if iszero(gt(searchLength, subjectLength)) {\\n                let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)\\n                let h := 0\\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\\n                let s := mload(search)\\n                for {} 1 {} {\\n                    let t := mload(subject)\\n                    // Whether the first `searchLength % 32` bytes of\\n                    // `subject` and `search` matches.\\n                    if iszero(shr(m, xor(t, s))) {\\n                        if h {\\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\\n                                mstore(result, t)\\n                                result := add(result, 1)\\n                                subject := add(subject, 1)\\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\\n                                continue\\n                            }\\n                        }\\n                        // Copy the `replacement` one word at a time.\\n                        for { let o := 0 } 1 {} {\\n                            mstore(add(result, o), mload(add(replacement, o)))\\n                            o := add(o, 0x20)\\n                            if iszero(lt(o, replacementLength)) { break }\\n                        }\\n                        result := add(result, replacementLength)\\n                        subject := add(subject, searchLength)\\n                        if searchLength {\\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\\n                            continue\\n                        }\\n                    }\\n                    mstore(result, t)\\n                    result := add(result, 1)\\n                    subject := add(subject, 1)\\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\\n                }\\n            }\\n\\n            let resultRemainder := result\\n            result := add(mload(0x40), 0x20)\\n            let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))\\n            // Copy the rest of the string one word at a time.\\n            for {} lt(subject, subjectEnd) {} {\\n                mstore(resultRemainder, mload(subject))\\n                resultRemainder := add(resultRemainder, 0x20)\\n                subject := add(subject, 0x20)\\n            }\\n            result := sub(result, 0x20)\\n            let last := add(add(result, 0x20), k) // Zeroize the slot after the string.\\n            mstore(last, 0)\\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n            mstore(result, k) // Store the length.\\n        }\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from left to right, starting from `from`.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function indexOf(string memory subject, string memory search, uint256 from)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for { let subjectLength := mload(subject) } 1 {} {\\n                if iszero(mload(search)) {\\n                    if iszero(gt(from, subjectLength)) {\\n                        result := from\\n                        break\\n                    }\\n                    result := subjectLength\\n                    break\\n                }\\n                let searchLength := mload(search)\\n                let subjectStart := add(subject, 0x20)\\n\\n                result := not(0) // Initialize to `NOT_FOUND`.\\n\\n                subject := add(subjectStart, from)\\n                let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)\\n\\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\\n                let s := mload(add(search, 0x20))\\n\\n                if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }\\n\\n                if iszero(lt(searchLength, 0x20)) {\\n                    for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\\n                        if iszero(shr(m, xor(mload(subject), s))) {\\n                            if eq(keccak256(subject, searchLength), h) {\\n                                result := sub(subject, subjectStart)\\n                                break\\n                            }\\n                        }\\n                        subject := add(subject, 1)\\n                        if iszero(lt(subject, end)) { break }\\n                    }\\n                    break\\n                }\\n                for {} 1 {} {\\n                    if iszero(shr(m, xor(mload(subject), s))) {\\n                        result := sub(subject, subjectStart)\\n                        break\\n                    }\\n                    subject := add(subject, 1)\\n                    if iszero(lt(subject, end)) { break }\\n                }\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from left to right.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function indexOf(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        result = indexOf(subject, search, 0);\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from right to left, starting from `from`.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function lastIndexOf(string memory subject, string memory search, uint256 from)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {} 1 {} {\\n                result := not(0) // Initialize to `NOT_FOUND`.\\n                let searchLength := mload(search)\\n                if gt(searchLength, mload(subject)) { break }\\n                let w := result\\n\\n                let fromMax := sub(mload(subject), searchLength)\\n                if iszero(gt(fromMax, from)) { from := fromMax }\\n\\n                let end := add(add(subject, 0x20), w)\\n                subject := add(add(subject, 0x20), from)\\n                if iszero(gt(subject, end)) { break }\\n                // As this function is not too often used,\\n                // we shall simply use keccak256 for smaller bytecode size.\\n                for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\\n                    if eq(keccak256(subject, searchLength), h) {\\n                        result := sub(subject, add(end, 1))\\n                        break\\n                    }\\n                    subject := add(subject, w) // `sub(subject, 1)`.\\n                    if iszero(gt(subject, end)) { break }\\n                }\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from right to left.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function lastIndexOf(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        result = lastIndexOf(subject, search, uint256(int256(-1)));\\n    }\\n\\n    /// @dev Returns true if `search` is found in `subject`, false otherwise.\\n    function contains(string memory subject, string memory search) internal pure returns (bool) {\\n        return indexOf(subject, search) != NOT_FOUND;\\n    }\\n\\n    /// @dev Returns whether `subject` starts with `search`.\\n    function startsWith(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (bool result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let searchLength := mload(search)\\n            // Just using keccak256 directly is actually cheaper.\\n            // forgefmt: disable-next-item\\n            result := and(\\n                iszero(gt(searchLength, mload(subject))),\\n                eq(\\n                    keccak256(add(subject, 0x20), searchLength),\\n                    keccak256(add(search, 0x20), searchLength)\\n                )\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns whether `subject` ends with `search`.\\n    function endsWith(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (bool result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let searchLength := mload(search)\\n            let subjectLength := mload(subject)\\n            // Whether `search` is not longer than `subject`.\\n            let withinRange := iszero(gt(searchLength, subjectLength))\\n            // Just using keccak256 directly is actually cheaper.\\n            // forgefmt: disable-next-item\\n            result := and(\\n                withinRange,\\n                eq(\\n                    keccak256(\\n                        // `subject + 0x20 + max(subjectLength - searchLength, 0)`.\\n                        add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),\\n                        searchLength\\n                    ),\\n                    keccak256(add(search, 0x20), searchLength)\\n                )\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns `subject` repeated `times`.\\n    function repeat(string memory subject, uint256 times)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            if iszero(or(iszero(times), iszero(subjectLength))) {\\n                subject := add(subject, 0x20)\\n                result := mload(0x40)\\n                let output := add(result, 0x20)\\n                for {} 1 {} {\\n                    // Copy the `subject` one word at a time.\\n                    for { let o := 0 } 1 {} {\\n                        mstore(add(output, o), mload(add(subject, o)))\\n                        o := add(o, 0x20)\\n                        if iszero(lt(o, subjectLength)) { break }\\n                    }\\n                    output := add(output, subjectLength)\\n                    times := sub(times, 1)\\n                    if iszero(times) { break }\\n                }\\n                mstore(output, 0) // Zeroize the slot after the string.\\n                let resultLength := sub(output, add(result, 0x20))\\n                mstore(result, resultLength) // Store the length.\\n                // Allocate the memory.\\n                mstore(0x40, add(result, add(resultLength, 0x20)))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\\n    /// `start` and `end` are byte offsets.\\n    function slice(string memory subject, uint256 start, uint256 end)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            if iszero(gt(subjectLength, end)) { end := subjectLength }\\n            if iszero(gt(subjectLength, start)) { start := subjectLength }\\n            if lt(start, end) {\\n                result := mload(0x40)\\n                let resultLength := sub(end, start)\\n                mstore(result, resultLength)\\n                subject := add(subject, start)\\n                let w := not(0x1f)\\n                // Copy the `subject` one word at a time, backwards.\\n                for { let o := and(add(resultLength, 0x1f), w) } 1 {} {\\n                    mstore(add(result, o), mload(add(subject, o)))\\n                    o := add(o, w) // `sub(o, 0x20)`.\\n                    if iszero(o) { break }\\n                }\\n                // Zeroize the slot after the string.\\n                mstore(add(add(result, 0x20), resultLength), 0)\\n                // Allocate memory for the length and the bytes,\\n                // rounded up to a multiple of 32.\\n                mstore(0x40, add(result, and(add(resultLength, 0x3f), w)))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the string.\\n    /// `start` is a byte offset.\\n    function slice(string memory subject, uint256 start)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        result = slice(subject, start, uint256(int256(-1)));\\n    }\\n\\n    /// @dev Returns all the indices of `search` in `subject`.\\n    /// The indices are byte offsets.\\n    function indicesOf(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (uint256[] memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            let searchLength := mload(search)\\n\\n            if iszero(gt(searchLength, subjectLength)) {\\n                subject := add(subject, 0x20)\\n                search := add(search, 0x20)\\n                result := add(mload(0x40), 0x20)\\n\\n                let subjectStart := subject\\n                let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)\\n                let h := 0\\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\\n                let s := mload(search)\\n                for {} 1 {} {\\n                    let t := mload(subject)\\n                    // Whether the first `searchLength % 32` bytes of\\n                    // `subject` and `search` matches.\\n                    if iszero(shr(m, xor(t, s))) {\\n                        if h {\\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\\n                                subject := add(subject, 1)\\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\\n                                continue\\n                            }\\n                        }\\n                        // Append to `result`.\\n                        mstore(result, sub(subject, subjectStart))\\n                        result := add(result, 0x20)\\n                        // Advance `subject` by `searchLength`.\\n                        subject := add(subject, searchLength)\\n                        if searchLength {\\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\\n                            continue\\n                        }\\n                    }\\n                    subject := add(subject, 1)\\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\\n                }\\n                let resultEnd := result\\n                // Assign `result` to the free memory pointer.\\n                result := mload(0x40)\\n                // Store the length of `result`.\\n                mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))\\n                // Allocate memory for result.\\n                // We allocate one more word, so this array can be recycled for {split}.\\n                mstore(0x40, add(resultEnd, 0x20))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a arrays of strings based on the `delimiter` inside of the `subject` string.\\n    function split(string memory subject, string memory delimiter)\\n        internal\\n        pure\\n        returns (string[] memory result)\\n    {\\n        uint256[] memory indices = indicesOf(subject, delimiter);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let w := not(0x1f)\\n            let indexPtr := add(indices, 0x20)\\n            let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))\\n            mstore(add(indicesEnd, w), mload(subject))\\n            mstore(indices, add(mload(indices), 1))\\n            let prevIndex := 0\\n            for {} 1 {} {\\n                let index := mload(indexPtr)\\n                mstore(indexPtr, 0x60)\\n                if iszero(eq(index, prevIndex)) {\\n                    let element := mload(0x40)\\n                    let elementLength := sub(index, prevIndex)\\n                    mstore(element, elementLength)\\n                    // Copy the `subject` one word at a time, backwards.\\n                    for { let o := and(add(elementLength, 0x1f), w) } 1 {} {\\n                        mstore(add(element, o), mload(add(add(subject, prevIndex), o)))\\n                        o := add(o, w) // `sub(o, 0x20)`.\\n                        if iszero(o) { break }\\n                    }\\n                    // Zeroize the slot after the string.\\n                    mstore(add(add(element, 0x20), elementLength), 0)\\n                    // Allocate memory for the length and the bytes,\\n                    // rounded up to a multiple of 32.\\n                    mstore(0x40, add(element, and(add(elementLength, 0x3f), w)))\\n                    // Store the `element` into the array.\\n                    mstore(indexPtr, element)\\n                }\\n                prevIndex := add(index, mload(delimiter))\\n                indexPtr := add(indexPtr, 0x20)\\n                if iszero(lt(indexPtr, indicesEnd)) { break }\\n            }\\n            result := indices\\n            if iszero(mload(delimiter)) {\\n                result := add(indices, 0x20)\\n                mstore(result, sub(mload(indices), 2))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a concatenated string of `a` and `b`.\\n    /// Cheaper than `string.concat()` and does not de-align the free memory pointer.\\n    function concat(string memory a, string memory b)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let w := not(0x1f)\\n            result := mload(0x40)\\n            let aLength := mload(a)\\n            // Copy `a` one word at a time, backwards.\\n            for { let o := and(add(aLength, 0x20), w) } 1 {} {\\n                mstore(add(result, o), mload(add(a, o)))\\n                o := add(o, w) // `sub(o, 0x20)`.\\n                if iszero(o) { break }\\n            }\\n            let bLength := mload(b)\\n            let output := add(result, aLength)\\n            // Copy `b` one word at a time, backwards.\\n            for { let o := and(add(bLength, 0x20), w) } 1 {} {\\n                mstore(add(output, o), mload(add(b, o)))\\n                o := add(o, w) // `sub(o, 0x20)`.\\n                if iszero(o) { break }\\n            }\\n            let totalLength := add(aLength, bLength)\\n            let last := add(add(result, 0x20), totalLength)\\n            // Zeroize the slot after the string.\\n            mstore(last, 0)\\n            // Stores the length.\\n            mstore(result, totalLength)\\n            // Allocate memory for the length and the bytes,\\n            // rounded up to a multiple of 32.\\n            mstore(0x40, and(add(last, 0x1f), w))\\n        }\\n    }\\n\\n    /// @dev Returns a copy of the string in either lowercase or UPPERCASE.\\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\\n    function toCase(string memory subject, bool toUpper)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let length := mload(subject)\\n            if length {\\n                result := add(mload(0x40), 0x20)\\n                subject := add(subject, 1)\\n                let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)\\n                let w := not(0)\\n                for { let o := length } 1 {} {\\n                    o := add(o, w)\\n                    let b := and(0xff, mload(add(subject, o)))\\n                    mstore8(add(result, o), xor(b, and(shr(b, flags), 0x20)))\\n                    if iszero(o) { break }\\n                }\\n                result := mload(0x40)\\n                mstore(result, length) // Store the length.\\n                let last := add(add(result, 0x20), length)\\n                mstore(last, 0) // Zeroize the slot after the string.\\n                mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a string from a small bytes32 string.\\n    /// `s` must be null-terminated, or behavior will be undefined.\\n    function fromSmallString(bytes32 s) internal pure returns (string memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            let n := 0\\n            for {} byte(n, s) { n := add(n, 1) } {} // Scan for '\\\\0'.\\n            mstore(result, n)\\n            let o := add(result, 0x20)\\n            mstore(o, s)\\n            mstore(add(o, n), 0)\\n            mstore(0x40, add(result, 0x40))\\n        }\\n    }\\n\\n    /// @dev Returns the small string, with all bytes after the first null byte zeroized.\\n    function normalizeSmallString(bytes32 s) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {} byte(result, s) { result := add(result, 1) } {} // Scan for '\\\\0'.\\n            mstore(0x00, s)\\n            mstore(result, 0x00)\\n            result := mload(0x00)\\n        }\\n    }\\n\\n    /// @dev Returns the string as a normalized null-terminated small string.\\n    function toSmallString(string memory s) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(s)\\n            if iszero(lt(result, 33)) {\\n                mstore(0x00, 0xec92f9a3) // `TooBigForSmallString()`.\\n                revert(0x1c, 0x04)\\n            }\\n            result := shl(shl(3, sub(32, result)), mload(add(s, result)))\\n        }\\n    }\\n\\n    /// @dev Returns a lowercased copy of the string.\\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\\n    function lower(string memory subject) internal pure returns (string memory result) {\\n        result = toCase(subject, false);\\n    }\\n\\n    /// @dev Returns an UPPERCASED copy of the string.\\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\\n    function upper(string memory subject) internal pure returns (string memory result) {\\n        result = toCase(subject, true);\\n    }\\n\\n    /// @dev Escapes the string to be used within HTML tags.\\n    function escapeHTML(string memory s) internal pure returns (string memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let end := add(s, mload(s))\\n            result := add(mload(0x40), 0x20)\\n            // Store the bytes of the packed offsets and strides into the scratch space.\\n            // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.\\n            mstore(0x1f, 0x900094)\\n            mstore(0x08, 0xc0000000a6ab)\\n            // Store \\\"&quot;&amp;&#39;&lt;&gt;\\\" into the scratch space.\\n            mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))\\n            for {} iszero(eq(s, end)) {} {\\n                s := add(s, 1)\\n                let c := and(mload(s), 0xff)\\n                // Not in `[\\\"\\\\\\\"\\\",\\\"'\\\",\\\"&\\\",\\\"<\\\",\\\">\\\"]`.\\n                if iszero(and(shl(c, 1), 0x500000c400000000)) {\\n                    mstore8(result, c)\\n                    result := add(result, 1)\\n                    continue\\n                }\\n                let t := shr(248, mload(c))\\n                mstore(result, mload(and(t, 0x1f)))\\n                result := add(result, shr(5, t))\\n            }\\n            let last := result\\n            mstore(last, 0) // Zeroize the slot after the string.\\n            result := mload(0x40)\\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\\n    /// If `addDoubleQuotes` is true, the result will be enclosed in double-quotes.\\n    function escapeJSON(string memory s, bool addDoubleQuotes)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let end := add(s, mload(s))\\n            result := add(mload(0x40), 0x20)\\n            if addDoubleQuotes {\\n                mstore8(result, 34)\\n                result := add(1, result)\\n            }\\n            // Store \\\"\\\\\\\\u0000\\\" in scratch space.\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            // Also, store `{0x08:\\\"b\\\", 0x09:\\\"t\\\", 0x0a:\\\"n\\\", 0x0c:\\\"f\\\", 0x0d:\\\"r\\\"}`.\\n            // into the scratch space.\\n            mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)\\n            // Bitmask for detecting `[\\\"\\\\\\\"\\\",\\\"\\\\\\\\\\\"]`.\\n            let e := or(shl(0x22, 1), shl(0x5c, 1))\\n            for {} iszero(eq(s, end)) {} {\\n                s := add(s, 1)\\n                let c := and(mload(s), 0xff)\\n                if iszero(lt(c, 0x20)) {\\n                    if iszero(and(shl(c, 1), e)) {\\n                        // Not in `[\\\"\\\\\\\"\\\",\\\"\\\\\\\\\\\"]`.\\n                        mstore8(result, c)\\n                        result := add(result, 1)\\n                        continue\\n                    }\\n                    mstore8(result, 0x5c) // \\\"\\\\\\\\\\\".\\n                    mstore8(add(result, 1), c)\\n                    result := add(result, 2)\\n                    continue\\n                }\\n                if iszero(and(shl(c, 1), 0x3700)) {\\n                    // Not in `[\\\"\\\\b\\\",\\\"\\\\t\\\",\\\"\\\\n\\\",\\\"\\\\f\\\",\\\"\\\\d\\\"]`.\\n                    mstore8(0x1d, mload(shr(4, c))) // Hex value.\\n                    mstore8(0x1e, mload(and(c, 15))) // Hex value.\\n                    mstore(result, mload(0x19)) // \\\"\\\\\\\\u00XX\\\".\\n                    result := add(result, 6)\\n                    continue\\n                }\\n                mstore8(result, 0x5c) // \\\"\\\\\\\\\\\".\\n                mstore8(add(result, 1), mload(add(c, 8)))\\n                result := add(result, 2)\\n            }\\n            if addDoubleQuotes {\\n                mstore8(result, 34)\\n                result := add(1, result)\\n            }\\n            let last := result\\n            mstore(last, 0) // Zeroize the slot after the string.\\n            result := mload(0x40)\\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\\n    function escapeJSON(string memory s) internal pure returns (string memory result) {\\n        result = escapeJSON(s, false);\\n    }\\n\\n    /// @dev Returns whether `a` equals `b`.\\n    function eq(string memory a, string memory b) internal pure returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))\\n        }\\n    }\\n\\n    /// @dev Returns whether `a` equals `b`, where `b` is a null-terminated small string.\\n    function eqs(string memory a, bytes32 b) internal pure returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // These should be evaluated on compile time, as far as possible.\\n            let m := not(shl(7, div(not(iszero(b)), 255))) // `0x7f7f ...`.\\n            let x := not(or(m, or(b, add(m, and(b, m)))))\\n            let r := shl(7, iszero(iszero(shr(128, x))))\\n            r := or(r, shl(6, iszero(iszero(shr(64, shr(r, x))))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\\n            // forgefmt: disable-next-item\\n            result := gt(eq(mload(a), add(iszero(x), xor(31, shr(3, r)))),\\n                xor(shr(add(8, r), b), shr(add(8, r), mload(add(a, 0x20)))))\\n        }\\n    }\\n\\n    /// @dev Packs a single string with its length into a single word.\\n    /// Returns `bytes32(0)` if the length is zero or greater than 31.\\n    function packOne(string memory a) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We don't need to zero right pad the string,\\n            // since this is our own custom non-standard packing scheme.\\n            result :=\\n                mul(\\n                    // Load the length and the bytes.\\n                    mload(add(a, 0x1f)),\\n                    // `length != 0 && length < 32`. Abuses underflow.\\n                    // Assumes that the length is valid and within the block gas limit.\\n                    lt(sub(mload(a), 1), 0x1f)\\n                )\\n        }\\n    }\\n\\n    /// @dev Unpacks a string packed using {packOne}.\\n    /// Returns the empty string if `packed` is `bytes32(0)`.\\n    /// If `packed` is not an output of {packOne}, the output behavior is undefined.\\n    function unpackOne(bytes32 packed) internal pure returns (string memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Grab the free memory pointer.\\n            result := mload(0x40)\\n            // Allocate 2 words (1 for the length, 1 for the bytes).\\n            mstore(0x40, add(result, 0x40))\\n            // Zeroize the length slot.\\n            mstore(result, 0)\\n            // Store the length and bytes.\\n            mstore(add(result, 0x1f), packed)\\n            // Right pad with zeroes.\\n            mstore(add(add(result, 0x20), mload(result)), 0)\\n        }\\n    }\\n\\n    /// @dev Packs two strings with their lengths into a single word.\\n    /// Returns `bytes32(0)` if combined length is zero or greater than 30.\\n    function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let aLength := mload(a)\\n            // We don't need to zero right pad the strings,\\n            // since this is our own custom non-standard packing scheme.\\n            result :=\\n                mul(\\n                    // Load the length and the bytes of `a` and `b`.\\n                    or(\\n                        shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))),\\n                        mload(sub(add(b, 0x1e), aLength))\\n                    ),\\n                    // `totalLength != 0 && totalLength < 31`. Abuses underflow.\\n                    // Assumes that the lengths are valid and within the block gas limit.\\n                    lt(sub(add(aLength, mload(b)), 1), 0x1e)\\n                )\\n        }\\n    }\\n\\n    /// @dev Unpacks strings packed using {packTwo}.\\n    /// Returns the empty strings if `packed` is `bytes32(0)`.\\n    /// If `packed` is not an output of {packTwo}, the output behavior is undefined.\\n    function unpackTwo(bytes32 packed)\\n        internal\\n        pure\\n        returns (string memory resultA, string memory resultB)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Grab the free memory pointer.\\n            resultA := mload(0x40)\\n            resultB := add(resultA, 0x40)\\n            // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.\\n            mstore(0x40, add(resultB, 0x40))\\n            // Zeroize the length slots.\\n            mstore(resultA, 0)\\n            mstore(resultB, 0)\\n            // Store the lengths and bytes.\\n            mstore(add(resultA, 0x1f), packed)\\n            mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))\\n            // Right pad with zeroes.\\n            mstore(add(add(resultA, 0x20), mload(resultA)), 0)\\n            mstore(add(add(resultB, 0x20), mload(resultB)), 0)\\n        }\\n    }\\n\\n    /// @dev Directly returns `a` without copying.\\n    function directReturn(string memory a) internal pure {\\n        assembly {\\n            // Assumes that the string does not start from the scratch space.\\n            let retStart := sub(a, 0x20)\\n            let retSize := add(mload(a), 0x40)\\n            // Right pad with zeroes. Just in case the string is produced\\n            // by a method that doesn't zero right pad.\\n            mstore(add(retStart, retSize), 0)\\n            // Store the return offset.\\n            mstore(retStart, 0x20)\\n            // End the transaction, returning the string.\\n            return(retStart, retSize)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf9089e94e05f506f21357bc513c166d58f4d6a02d589741c72e8a7722cefeda2\",\"license\":\"MIT\"},\"solidity-rlp/contracts/RLPReader.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * @author Hamdi Allam hamdi.allam97@gmail.com\\n * Please reach out with any questions or concerns\\n */\\npragma solidity >=0.5.10 <0.9.0;\\n\\nlibrary RLPReader {\\n    uint8 constant STRING_SHORT_START = 0x80;\\n    uint8 constant STRING_LONG_START = 0xb8;\\n    uint8 constant LIST_SHORT_START = 0xc0;\\n    uint8 constant LIST_LONG_START = 0xf8;\\n    uint8 constant WORD_SIZE = 32;\\n\\n    struct RLPItem {\\n        uint256 len;\\n        uint256 memPtr;\\n    }\\n\\n    struct Iterator {\\n        RLPItem item; // Item that's being iterated over.\\n        uint256 nextPtr; // Position of the next item in the list.\\n    }\\n\\n    /*\\n     * @dev Returns the next element in the iteration. Reverts if it has not next element.\\n     * @param self The iterator.\\n     * @return The next element in the iteration.\\n     */\\n    function next(Iterator memory self) internal pure returns (RLPItem memory) {\\n        require(hasNext(self));\\n\\n        uint256 ptr = self.nextPtr;\\n        uint256 itemLength = _itemLength(ptr);\\n        self.nextPtr = ptr + itemLength;\\n\\n        return RLPItem(itemLength, ptr);\\n    }\\n\\n    /*\\n     * @dev Returns true if the iteration has more elements.\\n     * @param self The iterator.\\n     * @return true if the iteration has more elements.\\n     */\\n    function hasNext(Iterator memory self) internal pure returns (bool) {\\n        RLPItem memory item = self.item;\\n        return self.nextPtr < item.memPtr + item.len;\\n    }\\n\\n    /*\\n     * @param item RLP encoded bytes\\n     */\\n    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\\n        uint256 memPtr;\\n        assembly {\\n            memPtr := add(item, 0x20)\\n        }\\n\\n        return RLPItem(item.length, memPtr);\\n    }\\n\\n    /*\\n     * @dev Create an iterator. Reverts if item is not a list.\\n     * @param self The RLP item.\\n     * @return An 'Iterator' over the item.\\n     */\\n    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {\\n        require(isList(self));\\n\\n        uint256 ptr = self.memPtr + _payloadOffset(self.memPtr);\\n        return Iterator(self, ptr);\\n    }\\n\\n    /*\\n     * @param the RLP item.\\n     */\\n    function rlpLen(RLPItem memory item) internal pure returns (uint256) {\\n        return item.len;\\n    }\\n\\n    /*\\n     * @param the RLP item.\\n     * @return (memPtr, len) pair: location of the item's payload in memory.\\n     */\\n    function payloadLocation(RLPItem memory item) internal pure returns (uint256, uint256) {\\n        uint256 offset = _payloadOffset(item.memPtr);\\n        uint256 memPtr = item.memPtr + offset;\\n        uint256 len = item.len - offset; // data length\\n        return (memPtr, len);\\n    }\\n\\n    /*\\n     * @param the RLP item.\\n     */\\n    function payloadLen(RLPItem memory item) internal pure returns (uint256) {\\n        (, uint256 len) = payloadLocation(item);\\n        return len;\\n    }\\n\\n    /*\\n     * @param the RLP item containing the encoded list.\\n     */\\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {\\n        require(isList(item));\\n\\n        uint256 items = numItems(item);\\n        RLPItem[] memory result = new RLPItem[](items);\\n\\n        uint256 memPtr = item.memPtr + _payloadOffset(item.memPtr);\\n        uint256 dataLen;\\n        for (uint256 i = 0; i < items; i++) {\\n            dataLen = _itemLength(memPtr);\\n            result[i] = RLPItem(dataLen, memPtr);\\n            memPtr = memPtr + dataLen;\\n        }\\n\\n        return result;\\n    }\\n\\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\\n    function isList(RLPItem memory item) internal pure returns (bool) {\\n        if (item.len == 0) return false;\\n\\n        uint8 byte0;\\n        uint256 memPtr = item.memPtr;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 < LIST_SHORT_START) return false;\\n        return true;\\n    }\\n\\n    /*\\n     * @dev A cheaper version of keccak256(toRlpBytes(item)) that avoids copying memory.\\n     * @return keccak256 hash of RLP encoded bytes.\\n     */\\n    function rlpBytesKeccak256(RLPItem memory item) internal pure returns (bytes32) {\\n        uint256 ptr = item.memPtr;\\n        uint256 len = item.len;\\n        bytes32 result;\\n        assembly {\\n            result := keccak256(ptr, len)\\n        }\\n        return result;\\n    }\\n\\n    /*\\n     * @dev A cheaper version of keccak256(toBytes(item)) that avoids copying memory.\\n     * @return keccak256 hash of the item payload.\\n     */\\n    function payloadKeccak256(RLPItem memory item) internal pure returns (bytes32) {\\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\\n        bytes32 result;\\n        assembly {\\n            result := keccak256(memPtr, len)\\n        }\\n        return result;\\n    }\\n\\n    /** RLPItem conversions into data types **/\\n\\n    // @returns raw rlp encoding in bytes\\n    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {\\n        bytes memory result = new bytes(item.len);\\n        if (result.length == 0) return result;\\n\\n        uint256 ptr;\\n        assembly {\\n            ptr := add(0x20, result)\\n        }\\n\\n        copy(item.memPtr, ptr, item.len);\\n        return result;\\n    }\\n\\n    // any non-zero byte except \\\"0x80\\\" is considered true\\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\\n        require(item.len == 1);\\n        uint256 result;\\n        uint256 memPtr = item.memPtr;\\n        assembly {\\n            result := byte(0, mload(memPtr))\\n        }\\n\\n        // SEE Github Issue #5.\\n        // Summary: Most commonly used RLP libraries (i.e Geth) will encode\\n        // \\\"0\\\" as \\\"0x80\\\" instead of as \\\"0\\\". We handle this edge case explicitly\\n        // here.\\n        if (result == 0 || result == STRING_SHORT_START) {\\n            return false;\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    function toAddress(RLPItem memory item) internal pure returns (address) {\\n        // 1 byte for the length prefix\\n        require(item.len == 21);\\n\\n        return address(uint160(toUint(item)));\\n    }\\n\\n    function toUint(RLPItem memory item) internal pure returns (uint256) {\\n        require(item.len > 0 && item.len <= 33);\\n\\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\\n\\n        uint256 result;\\n        assembly {\\n            result := mload(memPtr)\\n\\n            // shift to the correct location if neccesary\\n            if lt(len, 32) {\\n                result := div(result, exp(256, sub(32, len)))\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    // enforces 32 byte length\\n    function toUintStrict(RLPItem memory item) internal pure returns (uint256) {\\n        // one byte prefix\\n        require(item.len == 33);\\n\\n        uint256 result;\\n        uint256 memPtr = item.memPtr + 1;\\n        assembly {\\n            result := mload(memPtr)\\n        }\\n\\n        return result;\\n    }\\n\\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\\n        require(item.len > 0);\\n\\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\\n        bytes memory result = new bytes(len);\\n\\n        uint256 destPtr;\\n        assembly {\\n            destPtr := add(0x20, result)\\n        }\\n\\n        copy(memPtr, destPtr, len);\\n        return result;\\n    }\\n\\n    /*\\n     * Private Helpers\\n     */\\n\\n    // @return number of payload items inside an encoded list.\\n    function numItems(RLPItem memory item) private pure returns (uint256) {\\n        if (item.len == 0) return 0;\\n\\n        uint256 count = 0;\\n        uint256 currPtr = item.memPtr + _payloadOffset(item.memPtr);\\n        uint256 endPtr = item.memPtr + item.len;\\n        while (currPtr < endPtr) {\\n            currPtr = currPtr + _itemLength(currPtr); // skip over an item\\n            count++;\\n        }\\n\\n        return count;\\n    }\\n\\n    // @return entire rlp item byte length\\n    function _itemLength(uint256 memPtr) private pure returns (uint256) {\\n        uint256 itemLen;\\n        uint256 byte0;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 < STRING_SHORT_START) {\\n            itemLen = 1;\\n        } else if (byte0 < STRING_LONG_START) {\\n            itemLen = byte0 - STRING_SHORT_START + 1;\\n        } else if (byte0 < LIST_SHORT_START) {\\n            assembly {\\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\\n                memPtr := add(memPtr, 1) // skip over the first byte\\n\\n                /* 32 byte word size */\\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\\n                itemLen := add(dataLen, add(byteLen, 1))\\n            }\\n        } else if (byte0 < LIST_LONG_START) {\\n            itemLen = byte0 - LIST_SHORT_START + 1;\\n        } else {\\n            assembly {\\n                let byteLen := sub(byte0, 0xf7)\\n                memPtr := add(memPtr, 1)\\n\\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\\n                itemLen := add(dataLen, add(byteLen, 1))\\n            }\\n        }\\n\\n        return itemLen;\\n    }\\n\\n    // @return number of bytes until the data\\n    function _payloadOffset(uint256 memPtr) private pure returns (uint256) {\\n        uint256 byte0;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 < STRING_SHORT_START) {\\n            return 0;\\n        } else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START)) {\\n            return 1;\\n        } else if (byte0 < LIST_SHORT_START) {\\n            // being explicit\\n            return byte0 - (STRING_LONG_START - 1) + 1;\\n        } else {\\n            return byte0 - (LIST_LONG_START - 1) + 1;\\n        }\\n    }\\n\\n    /*\\n     * @param src Pointer to source\\n     * @param dest Pointer to destination\\n     * @param len Amount of memory to copy from the source\\n     */\\n    function copy(uint256 src, uint256 dest, uint256 len) private pure {\\n        if (len == 0) return;\\n\\n        // copy as many word sizes as possible\\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n\\n            src += WORD_SIZE;\\n            dest += WORD_SIZE;\\n        }\\n\\n        if (len > 0) {\\n            // left over bytes. Mask is used to remove unwanted bytes from the word\\n            uint256 mask = 256**(WORD_SIZE - len) - 1;\\n            assembly {\\n                let srcpart := and(mload(src), not(mask)) // zero out src\\n                let destpart := and(mload(dest), mask) // retrieve the bytes\\n                mstore(dest, or(destpart, srcpart))\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x3a44f2de3c752fa4f926f3fd4cad8338dab742484150c0d7d2f785409ed8db4d\",\"license\":\"Apache-2.0\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b5061590f80620000216000396000f3fe6080604052600436106101185760003560e01c80639829ba42116100a0578063d86cd69a11610064578063d86cd69a146103b9578063e0a388fb146103e4578063e24116251461040f578063ea42418b14610438578063f77c47911461046357610119565b80639829ba42146102e6578063b72a654014610311578063cf1b037c1461033c578063d3596e7f14610365578063d40ec0661461039057610119565b8063392e53cd116100e7578063392e53cd146101eb578063507235531461021657806357e3c1b5146102535780637e48532c14610290578063847b8150146102bb57610119565b80630de8cb931461011b5780631d148b8d1461015857806323b17abc146101955780632e0f2625146101c057610119565b5b005b34801561012757600080fd5b50610142600480360381019061013d9190613b8f565b61048e565b60405161014f9190613cae565b60405180910390f35b34801561016457600080fd5b5061017f600480360381019061017a9190613d71565b610575565b60405161018c9190613cae565b60405180910390f35b3480156101a157600080fd5b506101aa610708565b6040516101b79190613e0f565b60405180910390f35b3480156101cc57600080fd5b506101d5610724565b6040516101e29190613e4d565b60405180910390f35b3480156101f757600080fd5b50610200610729565b60405161020d9190613e77565b60405180910390f35b34801561022257600080fd5b5061023d60048036038101906102389190613e92565b61073a565b60405161024a9190613eea565b60405180910390f35b34801561025f57600080fd5b5061027a60048036038101906102759190613f63565b6107c6565b6040516102879190613cae565b60405180910390f35b34801561029c57600080fd5b506102a5610915565b6040516102b29190613cae565b60405180910390f35b3480156102c757600080fd5b506102d0610a52565b6040516102dd9190613e0f565b60405180910390f35b3480156102f257600080fd5b506102fb610a6e565b6040516103089190613e0f565b60405180910390f35b34801561031d57600080fd5b50610326610aa7565b6040516103339190613e0f565b60405180910390f35b34801561034857600080fd5b50610363600480360381019061035e9190613f63565b610ac3565b005b34801561037157600080fd5b5061037a610b98565b6040516103879190613fdd565b60405180910390f35b34801561039c57600080fd5b506103b760048036038101906103b29190613ff8565b610bab565b005b3480156103c557600080fd5b506103ce610be8565b6040516103db9190613e0f565b60405180910390f35b3480156103f057600080fd5b506103f9610c21565b6040516104069190613eea565b60405180910390f35b34801561041b57600080fd5b5061043660048036038101906104319190614080565b610c27565b005b34801561044457600080fd5b5061044d610cfd565b60405161045a91906140cf565b60405180910390f35b34801561046f57600080fd5b50610478610d23565b60405161048591906140cf565b60405180910390f35b60606104d661049b610d49565b6040518060400160405280601081526020017f4e6f7420636f6e666964656e7469616c00000000000000000000000000000000815250610e13565b60006104e18761073a565b90506104f1878288888888610e59565b63d40ec06660e01b878260405160240161050c9291906140ea565b604051602081830303815290604052907bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff838183161783525050505091505095945050505050565b6060600061058283610e92565b6040516020016105929190614214565b60405160208183030381529060405290506105ab6138cc565b6040518060400160405280600481526020017f504f5354000000000000000000000000000000000000000000000000000000008152508160200181905250818160600181905250600167ffffffffffffffff81111561060d5761060c6139b6565b5b60405190808252806020026020018201604052801561064057816020015b606081526020019060019003908161062b5790505b5081604001819052506040518060400160405280601e81526020017f436f6e74656e742d547970653a206170706c69636174696f6e2f6a736f6e0000815250816040015160008151811061069757610696614241565b5b602002602001018190525060008160800190151590811515815250506040518060600160405280602b815260200161588c602b913981600001819052506127108160a0019067ffffffffffffffff16908167ffffffffffffffff16815250506106ff81610eb8565b92505050919050565b6040518060600160405280602381526020016158b76023913981565b600481565b60008054906101000a900460ff1681565b60008061074683610f71565b9050600061075382611128565b905060006107a76107a26040518060400160405280600781526020017f22707269636522000000000000000000000000000000000000000000000000008152508461115490919063ffffffff16565b6111d7565b90506107bc6107b5826111f9565b60046112c6565b9350505050919050565b606061080e6107d3610d49565b6040518060400160405280601081526020017f4e6f7420636f6e666964656e7469616c00000000000000000000000000000000815250610e13565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff1614806108b85750600073ffffffffffffffffffffffffffffffffffffffff16600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16145b6108f7576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016108ee906142bc565b60405180910390fd5b60006109028361148d565b905061090d81610575565b915050919050565b606061095d610922610d49565b6040518060400160405280601081526020017f4e6f7420636f6e666964656e7469616c00000000000000000000000000000000815250610e13565b6109aa60008054906101000a900460ff16156040518060400160405280601381526020017f416c726561647920696e697469616c697a656400000000000000000000000000815250610e13565b60006109b6600061162b565b905060006109c382611724565b905060006109d083611790565b905063e241162560e01b81836040516024016109ed9291906142dc565b604051602081830303815290604052907bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff8381831617835250505050935050505090565b6040518060600160405280602b815260200161588c602b913981565b6040518060400160405280601281526020017f6f7261636c653a76303a706b736563726574000000000000000000000000000081525081565b6040518060600160405280603b8152602001615851603b913981565b600073ffffffffffffffffffffffffffffffffffffffff16600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1614610b54576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610b4b906142bc565b60405180910390fd5b80600260006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050565b600060019054906101000a900460801b81565b7ff61f2fd6ab65716facd3516c91d806d98dffa9670f127beac522f8cacfd1d8df8282604051610bdc9291906140ea565b60405180910390a15050565b6040518060400160405280600681526020017f307834323638000000000000000000000000000000000000000000000000000081525081565b61426881565b610c7460008054906101000a900460ff16156040518060400160405280601381526020017f416c726561647920696e697469616c697a656400000000000000000000000000815250610e13565b81600060016101000a8154816fffffffffffffffffffffffffffffffff021916908360801c021790555080600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060016000806101000a81548160ff0219169083151502179055505050565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6000806000634201000073ffffffffffffffffffffffffffffffffffffffff16604051610d7590614336565b6000604051808303816000865af19150503d8060008114610db2576040519150601f19603f3d011682016040523d82523d6000602084013e610db7565b606091505b509150915081610e04576342010000816040517f75fff467000000000000000000000000000000000000000000000000000000008152600401610dfb92919061434b565b60405180910390fd5b80516020820151935050505090565b81610e5557806040517f0c25cd98000000000000000000000000000000000000000000000000000000008152600401610e4c9190613e0f565b60405180910390fd5b5050565b6000610e678787878761196c565b90508115610e7e57610e798184611b36565b610e89565b610e8781610575565b505b50505050505050565b6060610e9d82611b4d565b90506002815101613078825260028203915080825250919050565b6060600080634320000273ffffffffffffffffffffffffffffffffffffffff1684604051602001610ee9919061458d565b604051602081830303815290604052604051610f0591906145e0565b600060405180830381855afa9150503d8060008114610f40576040519150601f19603f3d011682016040523d82523d6000602084013e610f45565b606091505b5091509150610f548282610e13565b80806020019051810190610f689190614667565b92505050919050565b60606000600167ffffffffffffffff811115610f9057610f8f6139b6565b5b604051908082528060200260200182016040528015610fc357816020015b6060815260200190600190039081610fae5790505b5090506040518060400160405280601e81526020017f436f6e74656e742d547970653a206170706c69636174696f6e2f6a736f6e0000815250816000815181106110105761100f614241565b5b602002602001018190525060006040518060c001604052806040518060600160405280603b8152602001615851603b9139866040516020016110539291906146b0565b60405160208183030381529060405281526020016040518060400160405280600381526020017f47455400000000000000000000000000000000000000000000000000000000008152508152602001838152602001600067ffffffffffffffff8111156110c3576110c26139b6565b5b6040519080825280601f01601f1916602001820160405280156110f55781602001600182028036833780820191505090505b50815260200160001515815260200161271067ffffffffffffffff16815250905061111f81610eb8565b92505050919050565b61113061390e565b80604052600061114961114284611bbb565b60ff611bc5565b905080915050919050565b61115c61390e565b806040526060905061116d83612489565b156111d1576000828051906020012090506000611189856124a0565b9050600060058251901b90505b600081146111cd57808201519550602081039050826111b4876124c2565b80519060200120036111c8578593506111cd565b611196565b5050505b92915050565b606060006111ee6111e7846124f4565b6000611bc5565b905080915050919050565b606060008290506002815111611244576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161123b90614720565b60405180910390fd5b600060028251611254919061476f565b905060008167ffffffffffffffff811115611272576112716139b6565b5b6040519080825280601f01601f1916602001820160405280156112a45781602001600182028036833780820191505090505b5090506021830160208201845182518252848452505050809350505050919050565b600080839050600080600090505b825181101561134257602e60f81b8382815181106112f5576112f4614241565b5b602001015160f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff19160361132f57809150611342565b808061133a906147a3565b9150506112d4565b5060008060006001905060008490505b60008111156113d1578160308760018461136c919061476f565b8151811061137d5761137c614241565b5b602001015160f81c60f81b60f81c61139591906147eb565b60ff166113a2919061481f565b846113ad9190614879565b9350600a826113bc919061481f565b915080806113c9906148cf565b915050611352565b506001905060008760ff16856113e79190614879565b90505b8481111561145c5781603087838151811061140857611407614241565b5b602001015160f81c60f81b60f81c61142091906147eb565b60ff1661142d919061481f565b836114389190614879565b9250600a82611447919061481f565b91508080611454906148cf565b9150506113ea565b508187600a61146b9190614a2b565b84611476919061481f565b6114809190614879565b9550505050505092915050565b606060006040518061014001604052808473ffffffffffffffffffffffffffffffffffffffff168152602001620186a0815260200164174876e800815260200160008152602001600081526020016040516024016040516020818303038152906040527f1aa3a008000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff8381831617835250505050815260200161426881526020017f111111111111111111111111111111111111111111111111111111111111111181526020017f11111111111111111111111111111111111111111111111111111111111111118152602001601b67ffffffffffffffff16815250905060006115d3826124fe565b905060006115df6127af565b9050611621826040518060400160405280600681526020017f30783432363800000000000000000000000000000000000000000000000000008152508361280a565b9350505050919050565b6060600080635320000373ffffffffffffffffffffffffffffffffffffffff168460405160200161165c9190614aed565b60405160208183030381529060405260405161167891906145e0565b6000604051808303816000865af19150503d80600081146116b5576040519150601f19603f3d011682016040523d82523d6000602084013e6116ba565b606091505b509150915081611707576353200003816040517f75fff4670000000000000000000000000000000000000000000000000000000081526004016116fe92919061434b565b60405180910390fd5b8080602001905181019061171b9190614b78565b92505050919050565b60008060405160200161173690614c0d565b604051602081830303815290604052805190602001209050600061177b826040516020016117649190614c58565b604051602081830303815290604052600086612909565b90506117878282612a19565b92505050919050565b600080600367ffffffffffffffff8111156117ae576117ad6139b6565b5b6040519080825280602002602001820160405280156117dc5781602001602082028036833780820191505090505b50905030816000815181106117f4576117f3614241565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff168152505063420300018160018151811061184757611846614241565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff168152505063420200018160028151811061189a57611899614241565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250506000611918600083846040518060400160405280601281526020017f6f7261636c653a76303a706b7365637265740000000000000000000000000000815250612a88565b905061195e81600001516040518060400160405280601281526020017f6f7261636c653a76303a706b736563726574000000000000000000000000000081525086612b90565b806000015192505050919050565b60606000604051806101400160405280600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001620186a081526020018481526020016000815260200185815260200187876040516024016119e99291906140ea565b6040516020818303038152906040527f4a432a46000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff8381831617835250505050815260200161426881526020017f111111111111111111111111111111111111111111111111111111111111111181526020017f11111111111111111111111111111111111111111111111111111111111111118152602001601b67ffffffffffffffff1681525090506000611adb826124fe565b90506000611ae76127af565b9050611b29826040518060400160405280600681526020017f30783432363800000000000000000000000000000000000000000000000000008152508361280a565b9350505050949350505050565b611b3f82612c75565b611b498282612d60565b5050565b60608151600260405101915080810182526f30313233343536373839616263646566600f52602082018184015b808514611ba857600185019450600f855116516001830153600f855160041c16518253600282019150611b7a565b6000825260208201604052505050919050565b6000819050919050565b60006123d1565b63101827966000526004601cfd5b6000815160001a9050919050565b60008190505b600115611c18576001640100002600611c0683611bda565b1c1615611c1957600181019050611bee565b5b92915050565b600063ffffffff84113d3d3e83831b8263ffffffff851b19161790509392505050565b600081831c63ffffffff16905092915050565b60006040519050611c7a8486036078611c75602086018803605888611c1f565b611c1f565b925085831781526020810160405295945050505050565b600080611ca2846018600051611c1f565b611cac8787611be8565b9150868210611cbb5750611e0e565b611cc482611bda565b600115611dff5760228103611cf85782611ce089858589612050565b9350611cf060048583868a611c55565b945050611dff565b605b8103611d1557611d0c88848488611e17565b93509350611dff565b607b8103611d3257611d2988848488611eef565b93509350611dff565b6001611ff9602d1b821c1615611d5757611d4e8884848861215f565b93509350611dff565b876004840111611dba5782835160e01c63747275658103611d8f57600485019450611d8660058684878b611c55565b95505050611dff565b636e756c6c8103611db757600485019450611dae60068684878b611c55565b95505050611dff565b50505b876005840111611df65782835160d81c6466616c73658103611df357600585019450611dea60058684878b611c55565b95505050611dff565b50505b611dfe611bcc565b5b50611e0a8783611be8565b9150505b94509492505050565b60008060006001860191505b600115611ec157868210611e3a57611e39611bcc565b5b82611e5d57611e498783611be8565b9150605d611e5683611bda565b0315611ec1575b611e6987838587611c91565b925092508215611eb257611e838160988551604017611c1f565b8352600181019050611e9482611bda565b605d8103611ea25750611ec1565b602c8103611eb05750611eb6565b505b8691505b600182019150611e23565b600182019150611ed383603887611c1f565b9450611ee3600183888888611c55565b92505094509492505050565b6000806001850190505b600115611fe257858110611f1057611f0f611bcc565b5b81611f3357611f1f8682611be8565b9050607d611f2c82611bda565b0315611fe2575b611f3d8682611be8565b905080611f4c87838587612050565b611f568882611be8565b9250603a611f6384611bda565b03611fd157611f7788600185018688611c91565b935093508315611fd057611fa36020860183036098611f9e85850360b88951608017611c1f565b611c1f565b8452611fae83611bda565b607d8103611fbe57505050611fe2565b602c8103611fce57505050611fd7565b505b5b87925050505b600181019050611ef9565b600181019050611ff482603886611c1f565b9350612004600282878787611c55565b915094509492505050565b6001667e0000007e03ff6030612026858501611bda565b031c1661203657612035611bcc565b5b6005821461204c5761204b600183018261200f565b5b5050565b600084841061206257612061611bcc565b5b6001840190505b6001156120fb5761207981611bda565b6022810361208757506120fb565b605c811461209b57600182019150506120f6565b6120a760018301611bda565b905060016a0510110400000000002001602283031c16156120ce57600282019150506120f6565b607581036120ed576120e160028361200f565b600682019150506120f6565b859150506120fb565b612069565b84811061210b5761210a611bcc565b5b600181019050949350505050565b60008190505b60011561214557600a603061213383611bda565b0310156121455760018101905061211f565b80821484161561215857612157611bcc565b5b9392505050565b600080849050602d61217082611bda565b0361217c576001810190505b600a603061218983611bda565b031061219857612197611bcc565b5b6121a181611bda565b600182019150603081146121be576121bb60008884612119565b91505b602e6121c983611bda565b036121e0576121dd60018860018501612119565b91505b815160658160001a6020170361220f5761220c6001896001860162010001600e8660011a031a01612119565b92505b61221d600384898989611c55565b9350505094509492505050565b600060405190508282019150601f1980601f8601165b60011561225a578084015181840152818101905080612240575b50848252600085602084010152846040830101604052509392505050565b6000606090508151600281600716116123645782158115176123645760208116156122af576122a8603882611c42565b9150612364565b6040519150602082016122c3603883611c42565b5b80156122f85780825280516122da601882611c42565b6122e687601884611c1f565b835280925060208401935050506122c4565b50601f1983820381018060051c85528260405261231785603886611c1f565b93508360201786526040811061236057602085018186015b60011561235d578151815183528082528482019150602083019250818310612357575061235d565b5061232f565b50505b5050505b50919050565b600060609050815180158315171561238257506123c9565b61238c8482611c42565b91508086166123c7576123a060d882611c42565b6123b46123ad8784611c42565b848361222a565b92506123c1838684611c1f565b87178452505b505b949350505050565b816000811461244a5760018114612460576003811461247657602084018451810180821461242f5761240281611bda565b602282536124168760d8602260f81b611c1f565b600052612426828460008a611c91565b93509450808253505b8315818310171561244357612442611bcc565b5b5050612482565b6124596010607860588761236a565b9150612482565b61246f600860b860988761236a565b9150612482565b61247f84612278565b91505b5092915050565b6000600260ff166007836000015116149050919050565b606060006124b76124b0846124f4565b6003611bc5565b905080915050919050565b606060006080836000015116146124ef5760006124e86124e1846124f4565b6001611bc5565b9050809150505b919050565b6000819050919050565b60606000600967ffffffffffffffff81111561251d5761251c6139b6565b5b60405190808252806020026020018201604052801561255057816020015b606081526020019060019003908161253b5790505b5090506125608360800151612ec6565b8160008151811061257457612573614241565b5b602002602001018190525061258c8360400151612ec6565b816001815181106125a05761259f614241565b5b60200260200101819052506125b88360200151612ec6565b816002815181106125cc576125cb614241565b5b6020026020010181905250600073ffffffffffffffffffffffffffffffffffffffff16836000015173ffffffffffffffffffffffffffffffffffffffff160361264b5761262760405180602001604052806000815250612ee0565b8160038151811061263b5761263a614241565b5b6020026020010181905250612678565b6126588360000151612f5e565b8160038151811061266c5761266b614241565b5b60200260200101819052505b6126858360600151612ec6565b8160048151811061269957612698614241565b5b60200260200101819052506126b18360a00151612ee0565b816005815181106126c5576126c4614241565b5b60200260200101819052506126e883610120015167ffffffffffffffff16612ec6565b816006815181106126fc576126fb614241565b5b60200260200101819052506127338360e0015160405160200161271f9190614c58565b604051602081830303815290604052612ee0565b8160078151811061274757612746614241565b5b602002602001018190525061277f83610100015160405160200161276b9190614c58565b604051602081830303815290604052612ee0565b8160088151811061279357612792614241565b5b60200260200101819052506127a781612f8f565b915050919050565b60606000612801600060019054906101000a900460801b6040518060400160405280601281526020017f6f7261636c653a76303a706b7365637265740000000000000000000000000000815250612fd3565b90508091505090565b6060600080634010000173ffffffffffffffffffffffffffffffffffffffff1686868660405160200161283f93929190614c73565b60405160208183030381529060405260405161285b91906145e0565b6000604051808303816000865af19150503d8060008114612898576040519150601f19603f3d011682016040523d82523d6000602084013e61289d565b606091505b5091509150816128ea576340100001816040517f75fff4670000000000000000000000000000000000000000000000000000000081526004016128e192919061434b565b60405180910390fd5b808060200190518101906128fe9190614667565b925050509392505050565b6060612913610d49565b61291c57600080fd5b600080634010000373ffffffffffffffffffffffffffffffffffffffff1686868660405160200161294f93929190614cbf565b60405160208183030381529060405260405161296b91906145e0565b6000604051808303816000865af19150503d80600081146129a8576040519150601f19603f3d011682016040523d82523d6000602084013e6129ad565b606091505b5091509150816129fa576340100003816040517f75fff4670000000000000000000000000000000000000000000000000000000081526004016129f192919061434b565b60405180910390fd5b80806020019051810190612a0e9190614667565b925050509392505050565b600080600080612a28856130bc565b92509250925060018682858560405160008152602001604052604051612a519493929190614d13565b6020604051602081039080840390855afa158015612a73573d6000803e3d6000fd5b50505060206040510351935050505092915050565b612a90613921565b600080634203000073ffffffffffffffffffffffffffffffffffffffff1687878787604051602001612ac59493929190614e25565b604051602081830303815290604052604051612ae191906145e0565b6000604051808303816000865af19150503d8060008114612b1e576040519150601f19603f3d011682016040523d82523d6000602084013e612b23565b606091505b509150915081612b70576342030000816040517f75fff467000000000000000000000000000000000000000000000000000000008152600401612b6792919061434b565b60405180910390fd5b80806020019051810190612b849190615084565b92505050949350505050565b600080634202000073ffffffffffffffffffffffffffffffffffffffff16858585604051602001612bc3939291906150cd565b604051602081830303815290604052604051612bdf91906145e0565b6000604051808303816000865af19150503d8060008114612c1c576040519150601f19603f3d011682016040523d82523d6000602084013e612c21565b606091505b509150915081612c6e576342020000816040517f75fff467000000000000000000000000000000000000000000000000000000008152600401612c6592919061434b565b60405180910390fd5b5050505050565b6000612c8082610e92565b604051602001612c9091906151aa565b6040516020818303038152906040529050600080634210000073ffffffffffffffffffffffffffffffffffffffff1683604051602001612cd09190613cae565b604051602081830303815290604052604051612cec91906145e0565b600060405180830381855afa9150503d8060008114612d27576040519150601f19603f3d011682016040523d82523d6000602084013e612d2c565b606091505b5091509150612d5a8282604051602001612d469190615223565b604051602081830303815290604052610e13565b50505050565b6000600167ffffffffffffffff811115612d7d57612d7c6139b6565b5b604051908082528060200260200182016040528015612db057816020015b6060815260200190600190039081612d9b5790505b5090508281600081518110612dc857612dc7614241565b5b60200260200101819052506000612de9828467ffffffffffffffff16613140565b9050600080634300000173ffffffffffffffffffffffffffffffffffffffff166040518060600160405280602381526020016158b76023913984604051602001612e34929190615291565b604051602081830303815290604052604051612e5091906145e0565b600060405180830381855afa9150503d8060008114612e8b576040519150601f19603f3d011682016040523d82523d6000602084013e612e90565b606091505b5091509150612ebe8282604051602001612eaa9190615327565b604051602081830303815290604052610e13565b505050505050565b6060612ed9612ed48361325f565b612ee0565b9050919050565b60608060018351148015612f185750608083600081518110612f0557612f04614241565b5b602001015160f81c60f81b60f81c60ff16105b15612f2557829050612f55565b612f31835160806133e2565b83604051602001612f43929190615349565b60405160208183030381529060405290505b80915050919050565b6060612f8882604051602001612f7491906153b5565b604051602081830303815290604052612ee0565b9050919050565b60606000612f9c8361362e565b9050612faa815160c06133e2565b81604051602001612fbc929190615349565b604051602081830303815290604052915050919050565b6060600080634202000173ffffffffffffffffffffffffffffffffffffffff1685856040516020016130069291906153d0565b60405160208183030381529060405260405161302291906145e0565b6000604051808303816000865af19150503d806000811461305f576040519150601f19603f3d011682016040523d82523d6000602084013e613064565b606091505b5091509150816130b1576342020001816040517f75fff4670000000000000000000000000000000000000000000000000000000081526004016130a892919061434b565b60405180910390fd5b809250505092915050565b60008060006041845114613105576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016130fc9061544c565b60405180910390fd5b6020840151925060408401519150606084015160001a9050601b8160ff16101561313957601b81613136919061546c565b90505b9193909250565b6060600061314d836137c0565b60405160200161315d919061553b565b604051602081830303815290604052905060005b8451811015613232578161319e86838151811061319157613190614241565b5b6020026020010151610e92565b6040516020016131af9291906155b4565b6040516020818303038152906040529150600185516131ce919061476f565b8110156131fc57816040516020016131e6919061563a565b604051602081830303815290604052915061321f565b8160405160200161320d91906156a8565b60405160208183030381529060405291505b808061322a906147a3565b915050613171565b50806040516020016132449190615716565b60405160208183030381529060405290508091505092915050565b60606000826040516020016132749190615759565b604051602081830303815290604052905060005b60208110156132ee57600060f81b8282815181106132a9576132a8614241565b5b602001015160f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916036132ee5780806132e6906147a3565b915050613288565b60008160206132fd919061476f565b67ffffffffffffffff811115613316576133156139b6565b5b6040519080825280601f01601f1916602001820160405280156133485781602001600182028036833780820191505090505b50905060005b81518110156133d657838380613363906147a3565b94508151811061337657613375614241565b5b602001015160f81c60f81b82828151811061339457613393614241565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a90535080806133ce906147a3565b91505061334e565b50809350505050919050565b606080603884101561349557600167ffffffffffffffff811115613409576134086139b6565b5b6040519080825280601f01601f19166020018201604052801561343b5781602001600182028036833780820191505090505b509050828461344a919061546c565b60f81b8160008151811061346157613460614241565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a905350613624565b600080600190505b600081876134ab91906157a3565b146134d35781806134bb906147a3565b925050610100816134cc919061481f565b905061349d565b6001826134e09190614879565b67ffffffffffffffff8111156134f9576134f86139b6565b5b6040519080825280601f01601f19166020018201604052801561352b5781602001600182028036833780820191505090505b5092506037858361353c919061546c565b613546919061546c565b60f81b8360008151811061355d5761355c614241565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a905350600190505b8181116136215761010081836135a7919061476f565b6101006135b491906157d4565b876135bf91906157a3565b6135c9919061581f565b60f81b8382815181106135df576135de614241565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a9053508080613619906147a3565b915050613591565b50505b8091505092915050565b6060600082510361368e57600067ffffffffffffffff811115613654576136536139b6565b5b6040519080825280601f01601f1916602001820160405280156136865781602001600182028036833780820191505090505b5090506137bb565b600080600090505b83518110156136db578381815181106136b2576136b1614241565b5b602002602001015151826136c69190614879565b915080806136d3906147a3565b915050613696565b60008267ffffffffffffffff8111156136f7576136f66139b6565b5b6040519080825280601f01601f1916602001820160405280156137295781602001600182028036833780820191505090505b5090506000602082019050600092505b85518310156137b357600086848151811061375757613756614241565b5b602002602001015190506000602082019050613775838284516137e6565b87858151811061378857613787614241565b5b6020026020010151518361379c9190614879565b9250505082806137ab906147a3565b935050613739565b819450505050505b919050565b60606137cb8261385c565b90506002815101613078825260028203915080825250919050565b6000839050600083905060008390505b60208110613834578151835260208361380f9190614879565b925060208261381e9190614879565b915060208161382d919061476f565b90506137f6565b60006001826020036101000a0390508019835116818551168181178652505050505050505050565b606060806040510190506020810160405260008152806f30313233343536373839616263646566600f52600119835b6001156138b7578184019350600f8116516001850153600f8160041c165184538060081c90508061388b575b50828203602084039350808452505050919050565b6040518060c0016040528060608152602001606081526020016060815260200160608152602001600015158152602001600067ffffffffffffffff1681525090565b6040518060200160405280600081525090565b6040518060c0016040528060006fffffffffffffffffffffffffffffffff1916815260200160006fffffffffffffffffffffffffffffffff19168152602001600067ffffffffffffffff1681526020016060815260200160608152602001606081525090565b6000604051905090565b600080fd5b600080fd5b600080fd5b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6139ee826139a5565b810181811067ffffffffffffffff82111715613a0d57613a0c6139b6565b5b80604052505050565b6000613a20613987565b9050613a2c82826139e5565b919050565b600067ffffffffffffffff821115613a4c57613a4b6139b6565b5b613a55826139a5565b9050602081019050919050565b82818337600083830152505050565b6000613a84613a7f84613a31565b613a16565b905082815260208101848484011115613aa057613a9f6139a0565b5b613aab848285613a62565b509392505050565b600082601f830112613ac857613ac761399b565b5b8135613ad8848260208601613a71565b91505092915050565b6000819050919050565b613af481613ae1565b8114613aff57600080fd5b50565b600081359050613b1181613aeb565b92915050565b600067ffffffffffffffff82169050919050565b613b3481613b17565b8114613b3f57600080fd5b50565b600081359050613b5181613b2b565b92915050565b60008115159050919050565b613b6c81613b57565b8114613b7757600080fd5b50565b600081359050613b8981613b63565b92915050565b600080600080600060a08688031215613bab57613baa613991565b5b600086013567ffffffffffffffff811115613bc957613bc8613996565b5b613bd588828901613ab3565b9550506020613be688828901613b02565b9450506040613bf788828901613b02565b9350506060613c0888828901613b42565b9250506080613c1988828901613b7a565b9150509295509295909350565b600081519050919050565b600082825260208201905092915050565b60005b83811015613c60578082015181840152602081019050613c45565b83811115613c6f576000848401525b50505050565b6000613c8082613c26565b613c8a8185613c31565b9350613c9a818560208601613c42565b613ca3816139a5565b840191505092915050565b60006020820190508181036000830152613cc88184613c75565b905092915050565b600067ffffffffffffffff821115613ceb57613cea6139b6565b5b613cf4826139a5565b9050602081019050919050565b6000613d14613d0f84613cd0565b613a16565b905082815260208101848484011115613d3057613d2f6139a0565b5b613d3b848285613a62565b509392505050565b600082601f830112613d5857613d5761399b565b5b8135613d68848260208601613d01565b91505092915050565b600060208284031215613d8757613d86613991565b5b600082013567ffffffffffffffff811115613da557613da4613996565b5b613db184828501613d43565b91505092915050565b600081519050919050565b600082825260208201905092915050565b6000613de182613dba565b613deb8185613dc5565b9350613dfb818560208601613c42565b613e04816139a5565b840191505092915050565b60006020820190508181036000830152613e298184613dd6565b905092915050565b600060ff82169050919050565b613e4781613e31565b82525050565b6000602082019050613e626000830184613e3e565b92915050565b613e7181613b57565b82525050565b6000602082019050613e8c6000830184613e68565b92915050565b600060208284031215613ea857613ea7613991565b5b600082013567ffffffffffffffff811115613ec657613ec5613996565b5b613ed284828501613ab3565b91505092915050565b613ee481613ae1565b82525050565b6000602082019050613eff6000830184613edb565b92915050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000613f3082613f05565b9050919050565b613f4081613f25565b8114613f4b57600080fd5b50565b600081359050613f5d81613f37565b92915050565b600060208284031215613f7957613f78613991565b5b6000613f8784828501613f4e565b91505092915050565b60007fffffffffffffffffffffffffffffffff0000000000000000000000000000000082169050919050565b6000613fc782613f90565b9050919050565b613fd781613fbc565b82525050565b6000602082019050613ff26000830184613fce565b92915050565b6000806040838503121561400f5761400e613991565b5b600083013567ffffffffffffffff81111561402d5761402c613996565b5b61403985828601613ab3565b925050602061404a85828601613b02565b9150509250929050565b61405d81613f90565b811461406857600080fd5b50565b60008135905061407a81614054565b92915050565b6000806040838503121561409757614096613991565b5b60006140a58582860161406b565b92505060206140b685828601613f4e565b9150509250929050565b6140c981613f25565b82525050565b60006020820190506140e460008301846140c0565b92915050565b600060408201905081810360008301526141048185613dd6565b90506141136020830184613edb565b9392505050565b600081905092915050565b7f7b226a736f6e727063223a22322e30222c226d6574686f64223a226574685f7360008201527f656e645261775472616e73616374696f6e222c22706172616d73223a5b220000602082015250565b6000614181603e8361411a565b915061418c82614125565b603e82019050919050565b60006141a282613dba565b6141ac818561411a565b93506141bc818560208601613c42565b80840191505092915050565b7f225d2c226964223a317d00000000000000000000000000000000000000000000600082015250565b60006141fe600a8361411a565b9150614209826141c8565b600a82019050919050565b600061421f82614174565b915061422b8284614197565b9150614236826141f1565b915081905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b7f416c726561647920726567697374657265640000000000000000000000000000600082015250565b60006142a6601283613dc5565b91506142b182614270565b602082019050919050565b600060208201905081810360008301526142d581614299565b9050919050565b60006040820190506142f16000830185613fce565b6142fe60208301846140c0565b9392505050565b600081905092915050565b50565b6000614320600083614305565b915061432b82614310565b600082019050919050565b600061434182614313565b9150819050919050565b600060408201905061436060008301856140c0565b81810360208301526143728184613c75565b90509392505050565b600082825260208201905092915050565b600061439782613dba565b6143a1818561437b565b93506143b1818560208601613c42565b6143ba816139a5565b840191505092915050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b60006143fd838361438c565b905092915050565b6000602082019050919050565b600061441d826143c5565b61442781856143d0565b935083602082028501614439856143e1565b8060005b85811015614475578484038952815161445685826143f1565b945061446183614405565b925060208a0199505060018101905061443d565b50829750879550505050505092915050565b600082825260208201905092915050565b60006144a382613c26565b6144ad8185614487565b93506144bd818560208601613c42565b6144c6816139a5565b840191505092915050565b6144da81613b57565b82525050565b6144e981613b17565b82525050565b600060c083016000830151848203600086015261450c828261438c565b91505060208301518482036020860152614526828261438c565b915050604083015184820360408601526145408282614412565b9150506060830151848203606086015261455a8282614498565b915050608083015161456f60808601826144d1565b5060a083015161458260a08601826144e0565b508091505092915050565b600060208201905081810360008301526145a781846144ef565b905092915050565b60006145ba82613c26565b6145c48185614305565b93506145d4818560208601613c42565b80840191505092915050565b60006145ec82846145af565b915081905092915050565b600061460a61460584613cd0565b613a16565b905082815260208101848484011115614626576146256139a0565b5b614631848285613c42565b509392505050565b600082601f83011261464e5761464d61399b565b5b815161465e8482602086016145f7565b91505092915050565b60006020828403121561467d5761467c613991565b5b600082015167ffffffffffffffff81111561469b5761469a613996565b5b6146a784828501614639565b91505092915050565b60006146bc8285614197565b91506146c88284614197565b91508190509392505050565b7f496e70757420746f6f2073686f72740000000000000000000000000000000000600082015250565b600061470a600f83613dc5565b9150614715826146d4565b602082019050919050565b60006020820190508181036000830152614739816146fd565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600061477a82613ae1565b915061478583613ae1565b92508282101561479857614797614740565b5b828203905092915050565b60006147ae82613ae1565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82036147e0576147df614740565b5b600182019050919050565b60006147f682613e31565b915061480183613e31565b92508282101561481457614813614740565b5b828203905092915050565b600061482a82613ae1565b915061483583613ae1565b9250817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff048311821515161561486e5761486d614740565b5b828202905092915050565b600061488482613ae1565b915061488f83613ae1565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff038211156148c4576148c3614740565b5b828201905092915050565b60006148da82613ae1565b9150600082036148ed576148ec614740565b5b600182039050919050565b60008160011c9050919050565b6000808291508390505b600185111561494f5780860481111561492b5761492a614740565b5b600185161561493a5780820291505b8081029050614948856148f8565b945061490f565b94509492505050565b6000826149685760019050614a24565b816149765760009050614a24565b816001811461498c5760028114614996576149c5565b6001915050614a24565b60ff8411156149a8576149a7614740565b5b8360020a9150848211156149bf576149be614740565b5b50614a24565b5060208310610133831016604e8410600b84101617156149fa5782820a9050838111156149f5576149f4614740565b5b614a24565b614a078484846001614905565b92509050818404811115614a1e57614a1d614740565b5b81810290505b9392505050565b6000614a3682613ae1565b9150614a4183613e31565b9250614a6e7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8484614958565b905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b60028110614ab657614ab5614a76565b5b50565b6000819050614ac782614aa5565b919050565b6000614ad782614ab9565b9050919050565b614ae781614acc565b82525050565b6000602082019050614b026000830184614ade565b92915050565b6000614b1b614b1684613a31565b613a16565b905082815260208101848484011115614b3757614b366139a0565b5b614b42848285613c42565b509392505050565b600082601f830112614b5f57614b5e61399b565b5b8151614b6f848260208601614b08565b91505092915050565b600060208284031215614b8e57614b8d613991565b5b600082015167ffffffffffffffff811115614bac57614bab613996565b5b614bb884828501614b4a565b91505092915050565b7f796f000000000000000000000000000000000000000000000000000000000000600082015250565b6000614bf7600283613dc5565b9150614c0282614bc1565b602082019050919050565b60006020820190508181036000830152614c2681614bea565b9050919050565b6000819050919050565b6000819050919050565b614c52614c4d82614c2d565b614c37565b82525050565b6000614c648284614c41565b60208201915081905092915050565b60006060820190508181036000830152614c8d8186613c75565b90508181036020830152614ca18185613dd6565b90508181036040830152614cb58184613dd6565b9050949350505050565b60006060820190508181036000830152614cd98186613c75565b9050614ce86020830185614ade565b8181036040830152614cfa8184613dd6565b9050949350505050565b614d0d81614c2d565b82525050565b6000608082019050614d286000830187614d04565b614d356020830186613e3e565b614d426040830185614d04565b614d4f6060830184614d04565b95945050505050565b614d6181613b17565b82525050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b614d9c81613f25565b82525050565b6000614dae8383614d93565b60208301905092915050565b6000602082019050919050565b6000614dd282614d67565b614ddc8185614d72565b9350614de783614d83565b8060005b83811015614e18578151614dff8882614da2565b9750614e0a83614dba565b925050600181019050614deb565b5085935050505092915050565b6000608082019050614e3a6000830187614d58565b8181036020830152614e4c8186614dc7565b90508181036040830152614e608185614dc7565b90508181036060830152614e748184613dd6565b905095945050505050565b600080fd5b600080fd5b600081519050614e9881614054565b92915050565b600081519050614ead81613b2b565b92915050565b600067ffffffffffffffff821115614ece57614ecd6139b6565b5b602082029050602081019050919050565b600080fd5b600081519050614ef381613f37565b92915050565b6000614f0c614f0784614eb3565b613a16565b90508083825260208201905060208402830185811115614f2f57614f2e614edf565b5b835b81811015614f585780614f448882614ee4565b845260208401935050602081019050614f31565b5050509392505050565b600082601f830112614f7757614f7661399b565b5b8151614f87848260208601614ef9565b91505092915050565b600060c08284031215614fa657614fa5614e7f565b5b614fb060c0613a16565b90506000614fc084828501614e89565b6000830152506020614fd484828501614e89565b6020830152506040614fe884828501614e9e565b604083015250606082015167ffffffffffffffff81111561500c5761500b614e84565b5b61501884828501614f62565b606083015250608082015167ffffffffffffffff81111561503c5761503b614e84565b5b61504884828501614f62565b60808301525060a082015167ffffffffffffffff81111561506c5761506b614e84565b5b61507884828501614b4a565b60a08301525092915050565b60006020828403121561509a57615099613991565b5b600082015167ffffffffffffffff8111156150b8576150b7613996565b5b6150c484828501614f90565b91505092915050565b60006060820190506150e26000830186613fce565b81810360208301526150f48185613dd6565b905081810360408301526151088184613c75565b9050949350505050565b7f7b22747873223a205b2200000000000000000000000000000000000000000000600082015250565b6000615148600a8361411a565b915061515382615112565b600a82019050919050565b7f225d7d0000000000000000000000000000000000000000000000000000000000600082015250565b600061519460038361411a565b915061519f8261515e565b600382019050919050565b60006151b58261513b565b91506151c18284614197565b91506151cc82615187565b915081905092915050565b7f42756e646c6553696d756c6174696f6e4661696c65643a200000000000000000600082015250565b600061520d60188361411a565b9150615218826151d7565b601882019050919050565b600061522e82615200565b915061523a8284614197565b915081905092915050565b7f6574685f73656e6442756e646c65000000000000000000000000000000000000600082015250565b600061527b600e83613dc5565b915061528682615245565b602082019050919050565b600060608201905081810360008301526152ab8185613dd6565b905081810360208301526152be8161526e565b905081810360408301526152d28184613c75565b90509392505050565b7f42756e646c655375626d697373696f6e4661696c65643a200000000000000000600082015250565b600061531160188361411a565b915061531c826152db565b601882019050919050565b600061533282615304565b915061533e8284614197565b915081905092915050565b600061535582856145af565b915061536182846145af565b91508190509392505050565b60008160601b9050919050565b60006153858261536d565b9050919050565b60006153978261537a565b9050919050565b6153af6153aa82613f25565b61538c565b82525050565b60006153c1828461539e565b60148201915081905092915050565b60006040820190506153e56000830185613fce565b81810360208301526153f78184613dd6565b90509392505050565b7f696e76616c6964207369676e6174757265206c656e6774680000000000000000600082015250565b6000615436601883613dc5565b915061544182615400565b602082019050919050565b6000602082019050818103600083015261546581615429565b9050919050565b600061547782613e31565b915061548283613e31565b92508260ff0382111561549857615497614740565b5b828201905092915050565b7f7b22626c6f636b4e756d626572223a2022000000000000000000000000000000600082015250565b60006154d960118361411a565b91506154e4826154a3565b601182019050919050565b7f222c2022747873223a205b000000000000000000000000000000000000000000600082015250565b6000615525600b8361411a565b9150615530826154ef565b600b82019050919050565b6000615546826154cc565b91506155528284614197565b915061555d82615518565b915081905092915050565b7f2200000000000000000000000000000000000000000000000000000000000000600082015250565b600061559e60018361411a565b91506155a982615568565b600182019050919050565b60006155c082856145af565b91506155cb82615591565b91506155d78284614197565b91506155e282615591565b91508190509392505050565b7f2c00000000000000000000000000000000000000000000000000000000000000600082015250565b600061562460018361411a565b915061562f826155ee565b600182019050919050565b600061564682846145af565b915061565182615617565b915081905092915050565b7f5d00000000000000000000000000000000000000000000000000000000000000600082015250565b600061569260018361411a565b915061569d8261565c565b600182019050919050565b60006156b482846145af565b91506156bf82615685565b915081905092915050565b7f7d00000000000000000000000000000000000000000000000000000000000000600082015250565b600061570060018361411a565b915061570b826156ca565b600182019050919050565b600061572282846145af565b915061572d826156f3565b915081905092915050565b6000819050919050565b61575361574e82613ae1565b615738565b82525050565b60006157658284615742565b60208201915081905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b60006157ae82613ae1565b91506157b983613ae1565b9250826157c9576157c8615774565b5b828204905092915050565b60006157df82613ae1565b91506157ea83613ae1565b92506158177fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8484614958565b905092915050565b600061582a82613ae1565b915061583583613ae1565b92508261584557615844615774565b5b82820690509291505056fe68747470733a2f2f646174612d6170692e62696e616e63652e766973696f6e2f6170692f76332f7469636b65722f70726963653f73796d626f6c3d68747470733a2f2f657468657265756d2d686f6c65736b792d7270632e7075626c69636e6f64652e636f6d68747470733a2f2f72656c61792d686f6c65736b792e666c617368626f74732e6e6574a2646970667358221220432fa067b94e54e62cdaa12a25113ce1168df52048191e4ffbb02624927a7e9264736f6c634300080d0033",
  "deployedBytecode": "0x6080604052600436106101185760003560e01c80639829ba42116100a0578063d86cd69a11610064578063d86cd69a146103b9578063e0a388fb146103e4578063e24116251461040f578063ea42418b14610438578063f77c47911461046357610119565b80639829ba42146102e6578063b72a654014610311578063cf1b037c1461033c578063d3596e7f14610365578063d40ec0661461039057610119565b8063392e53cd116100e7578063392e53cd146101eb578063507235531461021657806357e3c1b5146102535780637e48532c14610290578063847b8150146102bb57610119565b80630de8cb931461011b5780631d148b8d1461015857806323b17abc146101955780632e0f2625146101c057610119565b5b005b34801561012757600080fd5b50610142600480360381019061013d9190613b8f565b61048e565b60405161014f9190613cae565b60405180910390f35b34801561016457600080fd5b5061017f600480360381019061017a9190613d71565b610575565b60405161018c9190613cae565b60405180910390f35b3480156101a157600080fd5b506101aa610708565b6040516101b79190613e0f565b60405180910390f35b3480156101cc57600080fd5b506101d5610724565b6040516101e29190613e4d565b60405180910390f35b3480156101f757600080fd5b50610200610729565b60405161020d9190613e77565b60405180910390f35b34801561022257600080fd5b5061023d60048036038101906102389190613e92565b61073a565b60405161024a9190613eea565b60405180910390f35b34801561025f57600080fd5b5061027a60048036038101906102759190613f63565b6107c6565b6040516102879190613cae565b60405180910390f35b34801561029c57600080fd5b506102a5610915565b6040516102b29190613cae565b60405180910390f35b3480156102c757600080fd5b506102d0610a52565b6040516102dd9190613e0f565b60405180910390f35b3480156102f257600080fd5b506102fb610a6e565b6040516103089190613e0f565b60405180910390f35b34801561031d57600080fd5b50610326610aa7565b6040516103339190613e0f565b60405180910390f35b34801561034857600080fd5b50610363600480360381019061035e9190613f63565b610ac3565b005b34801561037157600080fd5b5061037a610b98565b6040516103879190613fdd565b60405180910390f35b34801561039c57600080fd5b506103b760048036038101906103b29190613ff8565b610bab565b005b3480156103c557600080fd5b506103ce610be8565b6040516103db9190613e0f565b60405180910390f35b3480156103f057600080fd5b506103f9610c21565b6040516104069190613eea565b60405180910390f35b34801561041b57600080fd5b5061043660048036038101906104319190614080565b610c27565b005b34801561044457600080fd5b5061044d610cfd565b60405161045a91906140cf565b60405180910390f35b34801561046f57600080fd5b50610478610d23565b60405161048591906140cf565b60405180910390f35b60606104d661049b610d49565b6040518060400160405280601081526020017f4e6f7420636f6e666964656e7469616c00000000000000000000000000000000815250610e13565b60006104e18761073a565b90506104f1878288888888610e59565b63d40ec06660e01b878260405160240161050c9291906140ea565b604051602081830303815290604052907bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff838183161783525050505091505095945050505050565b6060600061058283610e92565b6040516020016105929190614214565b60405160208183030381529060405290506105ab6138cc565b6040518060400160405280600481526020017f504f5354000000000000000000000000000000000000000000000000000000008152508160200181905250818160600181905250600167ffffffffffffffff81111561060d5761060c6139b6565b5b60405190808252806020026020018201604052801561064057816020015b606081526020019060019003908161062b5790505b5081604001819052506040518060400160405280601e81526020017f436f6e74656e742d547970653a206170706c69636174696f6e2f6a736f6e0000815250816040015160008151811061069757610696614241565b5b602002602001018190525060008160800190151590811515815250506040518060600160405280602b815260200161588c602b913981600001819052506127108160a0019067ffffffffffffffff16908167ffffffffffffffff16815250506106ff81610eb8565b92505050919050565b6040518060600160405280602381526020016158b76023913981565b600481565b60008054906101000a900460ff1681565b60008061074683610f71565b9050600061075382611128565b905060006107a76107a26040518060400160405280600781526020017f22707269636522000000000000000000000000000000000000000000000000008152508461115490919063ffffffff16565b6111d7565b90506107bc6107b5826111f9565b60046112c6565b9350505050919050565b606061080e6107d3610d49565b6040518060400160405280601081526020017f4e6f7420636f6e666964656e7469616c00000000000000000000000000000000815250610e13565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff1614806108b85750600073ffffffffffffffffffffffffffffffffffffffff16600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16145b6108f7576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016108ee906142bc565b60405180910390fd5b60006109028361148d565b905061090d81610575565b915050919050565b606061095d610922610d49565b6040518060400160405280601081526020017f4e6f7420636f6e666964656e7469616c00000000000000000000000000000000815250610e13565b6109aa60008054906101000a900460ff16156040518060400160405280601381526020017f416c726561647920696e697469616c697a656400000000000000000000000000815250610e13565b60006109b6600061162b565b905060006109c382611724565b905060006109d083611790565b905063e241162560e01b81836040516024016109ed9291906142dc565b604051602081830303815290604052907bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff8381831617835250505050935050505090565b6040518060600160405280602b815260200161588c602b913981565b6040518060400160405280601281526020017f6f7261636c653a76303a706b736563726574000000000000000000000000000081525081565b6040518060600160405280603b8152602001615851603b913981565b600073ffffffffffffffffffffffffffffffffffffffff16600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1614610b54576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610b4b906142bc565b60405180910390fd5b80600260006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050565b600060019054906101000a900460801b81565b7ff61f2fd6ab65716facd3516c91d806d98dffa9670f127beac522f8cacfd1d8df8282604051610bdc9291906140ea565b60405180910390a15050565b6040518060400160405280600681526020017f307834323638000000000000000000000000000000000000000000000000000081525081565b61426881565b610c7460008054906101000a900460ff16156040518060400160405280601381526020017f416c726561647920696e697469616c697a656400000000000000000000000000815250610e13565b81600060016101000a8154816fffffffffffffffffffffffffffffffff021916908360801c021790555080600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060016000806101000a81548160ff0219169083151502179055505050565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6000806000634201000073ffffffffffffffffffffffffffffffffffffffff16604051610d7590614336565b6000604051808303816000865af19150503d8060008114610db2576040519150601f19603f3d011682016040523d82523d6000602084013e610db7565b606091505b509150915081610e04576342010000816040517f75fff467000000000000000000000000000000000000000000000000000000008152600401610dfb92919061434b565b60405180910390fd5b80516020820151935050505090565b81610e5557806040517f0c25cd98000000000000000000000000000000000000000000000000000000008152600401610e4c9190613e0f565b60405180910390fd5b5050565b6000610e678787878761196c565b90508115610e7e57610e798184611b36565b610e89565b610e8781610575565b505b50505050505050565b6060610e9d82611b4d565b90506002815101613078825260028203915080825250919050565b6060600080634320000273ffffffffffffffffffffffffffffffffffffffff1684604051602001610ee9919061458d565b604051602081830303815290604052604051610f0591906145e0565b600060405180830381855afa9150503d8060008114610f40576040519150601f19603f3d011682016040523d82523d6000602084013e610f45565b606091505b5091509150610f548282610e13565b80806020019051810190610f689190614667565b92505050919050565b60606000600167ffffffffffffffff811115610f9057610f8f6139b6565b5b604051908082528060200260200182016040528015610fc357816020015b6060815260200190600190039081610fae5790505b5090506040518060400160405280601e81526020017f436f6e74656e742d547970653a206170706c69636174696f6e2f6a736f6e0000815250816000815181106110105761100f614241565b5b602002602001018190525060006040518060c001604052806040518060600160405280603b8152602001615851603b9139866040516020016110539291906146b0565b60405160208183030381529060405281526020016040518060400160405280600381526020017f47455400000000000000000000000000000000000000000000000000000000008152508152602001838152602001600067ffffffffffffffff8111156110c3576110c26139b6565b5b6040519080825280601f01601f1916602001820160405280156110f55781602001600182028036833780820191505090505b50815260200160001515815260200161271067ffffffffffffffff16815250905061111f81610eb8565b92505050919050565b61113061390e565b80604052600061114961114284611bbb565b60ff611bc5565b905080915050919050565b61115c61390e565b806040526060905061116d83612489565b156111d1576000828051906020012090506000611189856124a0565b9050600060058251901b90505b600081146111cd57808201519550602081039050826111b4876124c2565b80519060200120036111c8578593506111cd565b611196565b5050505b92915050565b606060006111ee6111e7846124f4565b6000611bc5565b905080915050919050565b606060008290506002815111611244576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161123b90614720565b60405180910390fd5b600060028251611254919061476f565b905060008167ffffffffffffffff811115611272576112716139b6565b5b6040519080825280601f01601f1916602001820160405280156112a45781602001600182028036833780820191505090505b5090506021830160208201845182518252848452505050809350505050919050565b600080839050600080600090505b825181101561134257602e60f81b8382815181106112f5576112f4614241565b5b602001015160f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff19160361132f57809150611342565b808061133a906147a3565b9150506112d4565b5060008060006001905060008490505b60008111156113d1578160308760018461136c919061476f565b8151811061137d5761137c614241565b5b602001015160f81c60f81b60f81c61139591906147eb565b60ff166113a2919061481f565b846113ad9190614879565b9350600a826113bc919061481f565b915080806113c9906148cf565b915050611352565b506001905060008760ff16856113e79190614879565b90505b8481111561145c5781603087838151811061140857611407614241565b5b602001015160f81c60f81b60f81c61142091906147eb565b60ff1661142d919061481f565b836114389190614879565b9250600a82611447919061481f565b91508080611454906148cf565b9150506113ea565b508187600a61146b9190614a2b565b84611476919061481f565b6114809190614879565b9550505050505092915050565b606060006040518061014001604052808473ffffffffffffffffffffffffffffffffffffffff168152602001620186a0815260200164174876e800815260200160008152602001600081526020016040516024016040516020818303038152906040527f1aa3a008000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff8381831617835250505050815260200161426881526020017f111111111111111111111111111111111111111111111111111111111111111181526020017f11111111111111111111111111111111111111111111111111111111111111118152602001601b67ffffffffffffffff16815250905060006115d3826124fe565b905060006115df6127af565b9050611621826040518060400160405280600681526020017f30783432363800000000000000000000000000000000000000000000000000008152508361280a565b9350505050919050565b6060600080635320000373ffffffffffffffffffffffffffffffffffffffff168460405160200161165c9190614aed565b60405160208183030381529060405260405161167891906145e0565b6000604051808303816000865af19150503d80600081146116b5576040519150601f19603f3d011682016040523d82523d6000602084013e6116ba565b606091505b509150915081611707576353200003816040517f75fff4670000000000000000000000000000000000000000000000000000000081526004016116fe92919061434b565b60405180910390fd5b8080602001905181019061171b9190614b78565b92505050919050565b60008060405160200161173690614c0d565b604051602081830303815290604052805190602001209050600061177b826040516020016117649190614c58565b604051602081830303815290604052600086612909565b90506117878282612a19565b92505050919050565b600080600367ffffffffffffffff8111156117ae576117ad6139b6565b5b6040519080825280602002602001820160405280156117dc5781602001602082028036833780820191505090505b50905030816000815181106117f4576117f3614241565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff168152505063420300018160018151811061184757611846614241565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff168152505063420200018160028151811061189a57611899614241565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250506000611918600083846040518060400160405280601281526020017f6f7261636c653a76303a706b7365637265740000000000000000000000000000815250612a88565b905061195e81600001516040518060400160405280601281526020017f6f7261636c653a76303a706b736563726574000000000000000000000000000081525086612b90565b806000015192505050919050565b60606000604051806101400160405280600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001620186a081526020018481526020016000815260200185815260200187876040516024016119e99291906140ea565b6040516020818303038152906040527f4a432a46000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff8381831617835250505050815260200161426881526020017f111111111111111111111111111111111111111111111111111111111111111181526020017f11111111111111111111111111111111111111111111111111111111111111118152602001601b67ffffffffffffffff1681525090506000611adb826124fe565b90506000611ae76127af565b9050611b29826040518060400160405280600681526020017f30783432363800000000000000000000000000000000000000000000000000008152508361280a565b9350505050949350505050565b611b3f82612c75565b611b498282612d60565b5050565b60608151600260405101915080810182526f30313233343536373839616263646566600f52602082018184015b808514611ba857600185019450600f855116516001830153600f855160041c16518253600282019150611b7a565b6000825260208201604052505050919050565b6000819050919050565b60006123d1565b63101827966000526004601cfd5b6000815160001a9050919050565b60008190505b600115611c18576001640100002600611c0683611bda565b1c1615611c1957600181019050611bee565b5b92915050565b600063ffffffff84113d3d3e83831b8263ffffffff851b19161790509392505050565b600081831c63ffffffff16905092915050565b60006040519050611c7a8486036078611c75602086018803605888611c1f565b611c1f565b925085831781526020810160405295945050505050565b600080611ca2846018600051611c1f565b611cac8787611be8565b9150868210611cbb5750611e0e565b611cc482611bda565b600115611dff5760228103611cf85782611ce089858589612050565b9350611cf060048583868a611c55565b945050611dff565b605b8103611d1557611d0c88848488611e17565b93509350611dff565b607b8103611d3257611d2988848488611eef565b93509350611dff565b6001611ff9602d1b821c1615611d5757611d4e8884848861215f565b93509350611dff565b876004840111611dba5782835160e01c63747275658103611d8f57600485019450611d8660058684878b611c55565b95505050611dff565b636e756c6c8103611db757600485019450611dae60068684878b611c55565b95505050611dff565b50505b876005840111611df65782835160d81c6466616c73658103611df357600585019450611dea60058684878b611c55565b95505050611dff565b50505b611dfe611bcc565b5b50611e0a8783611be8565b9150505b94509492505050565b60008060006001860191505b600115611ec157868210611e3a57611e39611bcc565b5b82611e5d57611e498783611be8565b9150605d611e5683611bda565b0315611ec1575b611e6987838587611c91565b925092508215611eb257611e838160988551604017611c1f565b8352600181019050611e9482611bda565b605d8103611ea25750611ec1565b602c8103611eb05750611eb6565b505b8691505b600182019150611e23565b600182019150611ed383603887611c1f565b9450611ee3600183888888611c55565b92505094509492505050565b6000806001850190505b600115611fe257858110611f1057611f0f611bcc565b5b81611f3357611f1f8682611be8565b9050607d611f2c82611bda565b0315611fe2575b611f3d8682611be8565b905080611f4c87838587612050565b611f568882611be8565b9250603a611f6384611bda565b03611fd157611f7788600185018688611c91565b935093508315611fd057611fa36020860183036098611f9e85850360b88951608017611c1f565b611c1f565b8452611fae83611bda565b607d8103611fbe57505050611fe2565b602c8103611fce57505050611fd7565b505b5b87925050505b600181019050611ef9565b600181019050611ff482603886611c1f565b9350612004600282878787611c55565b915094509492505050565b6001667e0000007e03ff6030612026858501611bda565b031c1661203657612035611bcc565b5b6005821461204c5761204b600183018261200f565b5b5050565b600084841061206257612061611bcc565b5b6001840190505b6001156120fb5761207981611bda565b6022810361208757506120fb565b605c811461209b57600182019150506120f6565b6120a760018301611bda565b905060016a0510110400000000002001602283031c16156120ce57600282019150506120f6565b607581036120ed576120e160028361200f565b600682019150506120f6565b859150506120fb565b612069565b84811061210b5761210a611bcc565b5b600181019050949350505050565b60008190505b60011561214557600a603061213383611bda565b0310156121455760018101905061211f565b80821484161561215857612157611bcc565b5b9392505050565b600080849050602d61217082611bda565b0361217c576001810190505b600a603061218983611bda565b031061219857612197611bcc565b5b6121a181611bda565b600182019150603081146121be576121bb60008884612119565b91505b602e6121c983611bda565b036121e0576121dd60018860018501612119565b91505b815160658160001a6020170361220f5761220c6001896001860162010001600e8660011a031a01612119565b92505b61221d600384898989611c55565b9350505094509492505050565b600060405190508282019150601f1980601f8601165b60011561225a578084015181840152818101905080612240575b50848252600085602084010152846040830101604052509392505050565b6000606090508151600281600716116123645782158115176123645760208116156122af576122a8603882611c42565b9150612364565b6040519150602082016122c3603883611c42565b5b80156122f85780825280516122da601882611c42565b6122e687601884611c1f565b835280925060208401935050506122c4565b50601f1983820381018060051c85528260405261231785603886611c1f565b93508360201786526040811061236057602085018186015b60011561235d578151815183528082528482019150602083019250818310612357575061235d565b5061232f565b50505b5050505b50919050565b600060609050815180158315171561238257506123c9565b61238c8482611c42565b91508086166123c7576123a060d882611c42565b6123b46123ad8784611c42565b848361222a565b92506123c1838684611c1f565b87178452505b505b949350505050565b816000811461244a5760018114612460576003811461247657602084018451810180821461242f5761240281611bda565b602282536124168760d8602260f81b611c1f565b600052612426828460008a611c91565b93509450808253505b8315818310171561244357612442611bcc565b5b5050612482565b6124596010607860588761236a565b9150612482565b61246f600860b860988761236a565b9150612482565b61247f84612278565b91505b5092915050565b6000600260ff166007836000015116149050919050565b606060006124b76124b0846124f4565b6003611bc5565b905080915050919050565b606060006080836000015116146124ef5760006124e86124e1846124f4565b6001611bc5565b9050809150505b919050565b6000819050919050565b60606000600967ffffffffffffffff81111561251d5761251c6139b6565b5b60405190808252806020026020018201604052801561255057816020015b606081526020019060019003908161253b5790505b5090506125608360800151612ec6565b8160008151811061257457612573614241565b5b602002602001018190525061258c8360400151612ec6565b816001815181106125a05761259f614241565b5b60200260200101819052506125b88360200151612ec6565b816002815181106125cc576125cb614241565b5b6020026020010181905250600073ffffffffffffffffffffffffffffffffffffffff16836000015173ffffffffffffffffffffffffffffffffffffffff160361264b5761262760405180602001604052806000815250612ee0565b8160038151811061263b5761263a614241565b5b6020026020010181905250612678565b6126588360000151612f5e565b8160038151811061266c5761266b614241565b5b60200260200101819052505b6126858360600151612ec6565b8160048151811061269957612698614241565b5b60200260200101819052506126b18360a00151612ee0565b816005815181106126c5576126c4614241565b5b60200260200101819052506126e883610120015167ffffffffffffffff16612ec6565b816006815181106126fc576126fb614241565b5b60200260200101819052506127338360e0015160405160200161271f9190614c58565b604051602081830303815290604052612ee0565b8160078151811061274757612746614241565b5b602002602001018190525061277f83610100015160405160200161276b9190614c58565b604051602081830303815290604052612ee0565b8160088151811061279357612792614241565b5b60200260200101819052506127a781612f8f565b915050919050565b60606000612801600060019054906101000a900460801b6040518060400160405280601281526020017f6f7261636c653a76303a706b7365637265740000000000000000000000000000815250612fd3565b90508091505090565b6060600080634010000173ffffffffffffffffffffffffffffffffffffffff1686868660405160200161283f93929190614c73565b60405160208183030381529060405260405161285b91906145e0565b6000604051808303816000865af19150503d8060008114612898576040519150601f19603f3d011682016040523d82523d6000602084013e61289d565b606091505b5091509150816128ea576340100001816040517f75fff4670000000000000000000000000000000000000000000000000000000081526004016128e192919061434b565b60405180910390fd5b808060200190518101906128fe9190614667565b925050509392505050565b6060612913610d49565b61291c57600080fd5b600080634010000373ffffffffffffffffffffffffffffffffffffffff1686868660405160200161294f93929190614cbf565b60405160208183030381529060405260405161296b91906145e0565b6000604051808303816000865af19150503d80600081146129a8576040519150601f19603f3d011682016040523d82523d6000602084013e6129ad565b606091505b5091509150816129fa576340100003816040517f75fff4670000000000000000000000000000000000000000000000000000000081526004016129f192919061434b565b60405180910390fd5b80806020019051810190612a0e9190614667565b925050509392505050565b600080600080612a28856130bc565b92509250925060018682858560405160008152602001604052604051612a519493929190614d13565b6020604051602081039080840390855afa158015612a73573d6000803e3d6000fd5b50505060206040510351935050505092915050565b612a90613921565b600080634203000073ffffffffffffffffffffffffffffffffffffffff1687878787604051602001612ac59493929190614e25565b604051602081830303815290604052604051612ae191906145e0565b6000604051808303816000865af19150503d8060008114612b1e576040519150601f19603f3d011682016040523d82523d6000602084013e612b23565b606091505b509150915081612b70576342030000816040517f75fff467000000000000000000000000000000000000000000000000000000008152600401612b6792919061434b565b60405180910390fd5b80806020019051810190612b849190615084565b92505050949350505050565b600080634202000073ffffffffffffffffffffffffffffffffffffffff16858585604051602001612bc3939291906150cd565b604051602081830303815290604052604051612bdf91906145e0565b6000604051808303816000865af19150503d8060008114612c1c576040519150601f19603f3d011682016040523d82523d6000602084013e612c21565b606091505b509150915081612c6e576342020000816040517f75fff467000000000000000000000000000000000000000000000000000000008152600401612c6592919061434b565b60405180910390fd5b5050505050565b6000612c8082610e92565b604051602001612c9091906151aa565b6040516020818303038152906040529050600080634210000073ffffffffffffffffffffffffffffffffffffffff1683604051602001612cd09190613cae565b604051602081830303815290604052604051612cec91906145e0565b600060405180830381855afa9150503d8060008114612d27576040519150601f19603f3d011682016040523d82523d6000602084013e612d2c565b606091505b5091509150612d5a8282604051602001612d469190615223565b604051602081830303815290604052610e13565b50505050565b6000600167ffffffffffffffff811115612d7d57612d7c6139b6565b5b604051908082528060200260200182016040528015612db057816020015b6060815260200190600190039081612d9b5790505b5090508281600081518110612dc857612dc7614241565b5b60200260200101819052506000612de9828467ffffffffffffffff16613140565b9050600080634300000173ffffffffffffffffffffffffffffffffffffffff166040518060600160405280602381526020016158b76023913984604051602001612e34929190615291565b604051602081830303815290604052604051612e5091906145e0565b600060405180830381855afa9150503d8060008114612e8b576040519150601f19603f3d011682016040523d82523d6000602084013e612e90565b606091505b5091509150612ebe8282604051602001612eaa9190615327565b604051602081830303815290604052610e13565b505050505050565b6060612ed9612ed48361325f565b612ee0565b9050919050565b60608060018351148015612f185750608083600081518110612f0557612f04614241565b5b602001015160f81c60f81b60f81c60ff16105b15612f2557829050612f55565b612f31835160806133e2565b83604051602001612f43929190615349565b60405160208183030381529060405290505b80915050919050565b6060612f8882604051602001612f7491906153b5565b604051602081830303815290604052612ee0565b9050919050565b60606000612f9c8361362e565b9050612faa815160c06133e2565b81604051602001612fbc929190615349565b604051602081830303815290604052915050919050565b6060600080634202000173ffffffffffffffffffffffffffffffffffffffff1685856040516020016130069291906153d0565b60405160208183030381529060405260405161302291906145e0565b6000604051808303816000865af19150503d806000811461305f576040519150601f19603f3d011682016040523d82523d6000602084013e613064565b606091505b5091509150816130b1576342020001816040517f75fff4670000000000000000000000000000000000000000000000000000000081526004016130a892919061434b565b60405180910390fd5b809250505092915050565b60008060006041845114613105576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016130fc9061544c565b60405180910390fd5b6020840151925060408401519150606084015160001a9050601b8160ff16101561313957601b81613136919061546c565b90505b9193909250565b6060600061314d836137c0565b60405160200161315d919061553b565b604051602081830303815290604052905060005b8451811015613232578161319e86838151811061319157613190614241565b5b6020026020010151610e92565b6040516020016131af9291906155b4565b6040516020818303038152906040529150600185516131ce919061476f565b8110156131fc57816040516020016131e6919061563a565b604051602081830303815290604052915061321f565b8160405160200161320d91906156a8565b60405160208183030381529060405291505b808061322a906147a3565b915050613171565b50806040516020016132449190615716565b60405160208183030381529060405290508091505092915050565b60606000826040516020016132749190615759565b604051602081830303815290604052905060005b60208110156132ee57600060f81b8282815181106132a9576132a8614241565b5b602001015160f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916036132ee5780806132e6906147a3565b915050613288565b60008160206132fd919061476f565b67ffffffffffffffff811115613316576133156139b6565b5b6040519080825280601f01601f1916602001820160405280156133485781602001600182028036833780820191505090505b50905060005b81518110156133d657838380613363906147a3565b94508151811061337657613375614241565b5b602001015160f81c60f81b82828151811061339457613393614241565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a90535080806133ce906147a3565b91505061334e565b50809350505050919050565b606080603884101561349557600167ffffffffffffffff811115613409576134086139b6565b5b6040519080825280601f01601f19166020018201604052801561343b5781602001600182028036833780820191505090505b509050828461344a919061546c565b60f81b8160008151811061346157613460614241565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a905350613624565b600080600190505b600081876134ab91906157a3565b146134d35781806134bb906147a3565b925050610100816134cc919061481f565b905061349d565b6001826134e09190614879565b67ffffffffffffffff8111156134f9576134f86139b6565b5b6040519080825280601f01601f19166020018201604052801561352b5781602001600182028036833780820191505090505b5092506037858361353c919061546c565b613546919061546c565b60f81b8360008151811061355d5761355c614241565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a905350600190505b8181116136215761010081836135a7919061476f565b6101006135b491906157d4565b876135bf91906157a3565b6135c9919061581f565b60f81b8382815181106135df576135de614241565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a9053508080613619906147a3565b915050613591565b50505b8091505092915050565b6060600082510361368e57600067ffffffffffffffff811115613654576136536139b6565b5b6040519080825280601f01601f1916602001820160405280156136865781602001600182028036833780820191505090505b5090506137bb565b600080600090505b83518110156136db578381815181106136b2576136b1614241565b5b602002602001015151826136c69190614879565b915080806136d3906147a3565b915050613696565b60008267ffffffffffffffff8111156136f7576136f66139b6565b5b6040519080825280601f01601f1916602001820160405280156137295781602001600182028036833780820191505090505b5090506000602082019050600092505b85518310156137b357600086848151811061375757613756614241565b5b602002602001015190506000602082019050613775838284516137e6565b87858151811061378857613787614241565b5b6020026020010151518361379c9190614879565b9250505082806137ab906147a3565b935050613739565b819450505050505b919050565b60606137cb8261385c565b90506002815101613078825260028203915080825250919050565b6000839050600083905060008390505b60208110613834578151835260208361380f9190614879565b925060208261381e9190614879565b915060208161382d919061476f565b90506137f6565b60006001826020036101000a0390508019835116818551168181178652505050505050505050565b606060806040510190506020810160405260008152806f30313233343536373839616263646566600f52600119835b6001156138b7578184019350600f8116516001850153600f8160041c165184538060081c90508061388b575b50828203602084039350808452505050919050565b6040518060c0016040528060608152602001606081526020016060815260200160608152602001600015158152602001600067ffffffffffffffff1681525090565b6040518060200160405280600081525090565b6040518060c0016040528060006fffffffffffffffffffffffffffffffff1916815260200160006fffffffffffffffffffffffffffffffff19168152602001600067ffffffffffffffff1681526020016060815260200160608152602001606081525090565b6000604051905090565b600080fd5b600080fd5b600080fd5b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6139ee826139a5565b810181811067ffffffffffffffff82111715613a0d57613a0c6139b6565b5b80604052505050565b6000613a20613987565b9050613a2c82826139e5565b919050565b600067ffffffffffffffff821115613a4c57613a4b6139b6565b5b613a55826139a5565b9050602081019050919050565b82818337600083830152505050565b6000613a84613a7f84613a31565b613a16565b905082815260208101848484011115613aa057613a9f6139a0565b5b613aab848285613a62565b509392505050565b600082601f830112613ac857613ac761399b565b5b8135613ad8848260208601613a71565b91505092915050565b6000819050919050565b613af481613ae1565b8114613aff57600080fd5b50565b600081359050613b1181613aeb565b92915050565b600067ffffffffffffffff82169050919050565b613b3481613b17565b8114613b3f57600080fd5b50565b600081359050613b5181613b2b565b92915050565b60008115159050919050565b613b6c81613b57565b8114613b7757600080fd5b50565b600081359050613b8981613b63565b92915050565b600080600080600060a08688031215613bab57613baa613991565b5b600086013567ffffffffffffffff811115613bc957613bc8613996565b5b613bd588828901613ab3565b9550506020613be688828901613b02565b9450506040613bf788828901613b02565b9350506060613c0888828901613b42565b9250506080613c1988828901613b7a565b9150509295509295909350565b600081519050919050565b600082825260208201905092915050565b60005b83811015613c60578082015181840152602081019050613c45565b83811115613c6f576000848401525b50505050565b6000613c8082613c26565b613c8a8185613c31565b9350613c9a818560208601613c42565b613ca3816139a5565b840191505092915050565b60006020820190508181036000830152613cc88184613c75565b905092915050565b600067ffffffffffffffff821115613ceb57613cea6139b6565b5b613cf4826139a5565b9050602081019050919050565b6000613d14613d0f84613cd0565b613a16565b905082815260208101848484011115613d3057613d2f6139a0565b5b613d3b848285613a62565b509392505050565b600082601f830112613d5857613d5761399b565b5b8135613d68848260208601613d01565b91505092915050565b600060208284031215613d8757613d86613991565b5b600082013567ffffffffffffffff811115613da557613da4613996565b5b613db184828501613d43565b91505092915050565b600081519050919050565b600082825260208201905092915050565b6000613de182613dba565b613deb8185613dc5565b9350613dfb818560208601613c42565b613e04816139a5565b840191505092915050565b60006020820190508181036000830152613e298184613dd6565b905092915050565b600060ff82169050919050565b613e4781613e31565b82525050565b6000602082019050613e626000830184613e3e565b92915050565b613e7181613b57565b82525050565b6000602082019050613e8c6000830184613e68565b92915050565b600060208284031215613ea857613ea7613991565b5b600082013567ffffffffffffffff811115613ec657613ec5613996565b5b613ed284828501613ab3565b91505092915050565b613ee481613ae1565b82525050565b6000602082019050613eff6000830184613edb565b92915050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000613f3082613f05565b9050919050565b613f4081613f25565b8114613f4b57600080fd5b50565b600081359050613f5d81613f37565b92915050565b600060208284031215613f7957613f78613991565b5b6000613f8784828501613f4e565b91505092915050565b60007fffffffffffffffffffffffffffffffff0000000000000000000000000000000082169050919050565b6000613fc782613f90565b9050919050565b613fd781613fbc565b82525050565b6000602082019050613ff26000830184613fce565b92915050565b6000806040838503121561400f5761400e613991565b5b600083013567ffffffffffffffff81111561402d5761402c613996565b5b61403985828601613ab3565b925050602061404a85828601613b02565b9150509250929050565b61405d81613f90565b811461406857600080fd5b50565b60008135905061407a81614054565b92915050565b6000806040838503121561409757614096613991565b5b60006140a58582860161406b565b92505060206140b685828601613f4e565b9150509250929050565b6140c981613f25565b82525050565b60006020820190506140e460008301846140c0565b92915050565b600060408201905081810360008301526141048185613dd6565b90506141136020830184613edb565b9392505050565b600081905092915050565b7f7b226a736f6e727063223a22322e30222c226d6574686f64223a226574685f7360008201527f656e645261775472616e73616374696f6e222c22706172616d73223a5b220000602082015250565b6000614181603e8361411a565b915061418c82614125565b603e82019050919050565b60006141a282613dba565b6141ac818561411a565b93506141bc818560208601613c42565b80840191505092915050565b7f225d2c226964223a317d00000000000000000000000000000000000000000000600082015250565b60006141fe600a8361411a565b9150614209826141c8565b600a82019050919050565b600061421f82614174565b915061422b8284614197565b9150614236826141f1565b915081905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b7f416c726561647920726567697374657265640000000000000000000000000000600082015250565b60006142a6601283613dc5565b91506142b182614270565b602082019050919050565b600060208201905081810360008301526142d581614299565b9050919050565b60006040820190506142f16000830185613fce565b6142fe60208301846140c0565b9392505050565b600081905092915050565b50565b6000614320600083614305565b915061432b82614310565b600082019050919050565b600061434182614313565b9150819050919050565b600060408201905061436060008301856140c0565b81810360208301526143728184613c75565b90509392505050565b600082825260208201905092915050565b600061439782613dba565b6143a1818561437b565b93506143b1818560208601613c42565b6143ba816139a5565b840191505092915050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b60006143fd838361438c565b905092915050565b6000602082019050919050565b600061441d826143c5565b61442781856143d0565b935083602082028501614439856143e1565b8060005b85811015614475578484038952815161445685826143f1565b945061446183614405565b925060208a0199505060018101905061443d565b50829750879550505050505092915050565b600082825260208201905092915050565b60006144a382613c26565b6144ad8185614487565b93506144bd818560208601613c42565b6144c6816139a5565b840191505092915050565b6144da81613b57565b82525050565b6144e981613b17565b82525050565b600060c083016000830151848203600086015261450c828261438c565b91505060208301518482036020860152614526828261438c565b915050604083015184820360408601526145408282614412565b9150506060830151848203606086015261455a8282614498565b915050608083015161456f60808601826144d1565b5060a083015161458260a08601826144e0565b508091505092915050565b600060208201905081810360008301526145a781846144ef565b905092915050565b60006145ba82613c26565b6145c48185614305565b93506145d4818560208601613c42565b80840191505092915050565b60006145ec82846145af565b915081905092915050565b600061460a61460584613cd0565b613a16565b905082815260208101848484011115614626576146256139a0565b5b614631848285613c42565b509392505050565b600082601f83011261464e5761464d61399b565b5b815161465e8482602086016145f7565b91505092915050565b60006020828403121561467d5761467c613991565b5b600082015167ffffffffffffffff81111561469b5761469a613996565b5b6146a784828501614639565b91505092915050565b60006146bc8285614197565b91506146c88284614197565b91508190509392505050565b7f496e70757420746f6f2073686f72740000000000000000000000000000000000600082015250565b600061470a600f83613dc5565b9150614715826146d4565b602082019050919050565b60006020820190508181036000830152614739816146fd565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600061477a82613ae1565b915061478583613ae1565b92508282101561479857614797614740565b5b828203905092915050565b60006147ae82613ae1565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82036147e0576147df614740565b5b600182019050919050565b60006147f682613e31565b915061480183613e31565b92508282101561481457614813614740565b5b828203905092915050565b600061482a82613ae1565b915061483583613ae1565b9250817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff048311821515161561486e5761486d614740565b5b828202905092915050565b600061488482613ae1565b915061488f83613ae1565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff038211156148c4576148c3614740565b5b828201905092915050565b60006148da82613ae1565b9150600082036148ed576148ec614740565b5b600182039050919050565b60008160011c9050919050565b6000808291508390505b600185111561494f5780860481111561492b5761492a614740565b5b600185161561493a5780820291505b8081029050614948856148f8565b945061490f565b94509492505050565b6000826149685760019050614a24565b816149765760009050614a24565b816001811461498c5760028114614996576149c5565b6001915050614a24565b60ff8411156149a8576149a7614740565b5b8360020a9150848211156149bf576149be614740565b5b50614a24565b5060208310610133831016604e8410600b84101617156149fa5782820a9050838111156149f5576149f4614740565b5b614a24565b614a078484846001614905565b92509050818404811115614a1e57614a1d614740565b5b81810290505b9392505050565b6000614a3682613ae1565b9150614a4183613e31565b9250614a6e7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8484614958565b905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b60028110614ab657614ab5614a76565b5b50565b6000819050614ac782614aa5565b919050565b6000614ad782614ab9565b9050919050565b614ae781614acc565b82525050565b6000602082019050614b026000830184614ade565b92915050565b6000614b1b614b1684613a31565b613a16565b905082815260208101848484011115614b3757614b366139a0565b5b614b42848285613c42565b509392505050565b600082601f830112614b5f57614b5e61399b565b5b8151614b6f848260208601614b08565b91505092915050565b600060208284031215614b8e57614b8d613991565b5b600082015167ffffffffffffffff811115614bac57614bab613996565b5b614bb884828501614b4a565b91505092915050565b7f796f000000000000000000000000000000000000000000000000000000000000600082015250565b6000614bf7600283613dc5565b9150614c0282614bc1565b602082019050919050565b60006020820190508181036000830152614c2681614bea565b9050919050565b6000819050919050565b6000819050919050565b614c52614c4d82614c2d565b614c37565b82525050565b6000614c648284614c41565b60208201915081905092915050565b60006060820190508181036000830152614c8d8186613c75565b90508181036020830152614ca18185613dd6565b90508181036040830152614cb58184613dd6565b9050949350505050565b60006060820190508181036000830152614cd98186613c75565b9050614ce86020830185614ade565b8181036040830152614cfa8184613dd6565b9050949350505050565b614d0d81614c2d565b82525050565b6000608082019050614d286000830187614d04565b614d356020830186613e3e565b614d426040830185614d04565b614d4f6060830184614d04565b95945050505050565b614d6181613b17565b82525050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b614d9c81613f25565b82525050565b6000614dae8383614d93565b60208301905092915050565b6000602082019050919050565b6000614dd282614d67565b614ddc8185614d72565b9350614de783614d83565b8060005b83811015614e18578151614dff8882614da2565b9750614e0a83614dba565b925050600181019050614deb565b5085935050505092915050565b6000608082019050614e3a6000830187614d58565b8181036020830152614e4c8186614dc7565b90508181036040830152614e608185614dc7565b90508181036060830152614e748184613dd6565b905095945050505050565b600080fd5b600080fd5b600081519050614e9881614054565b92915050565b600081519050614ead81613b2b565b92915050565b600067ffffffffffffffff821115614ece57614ecd6139b6565b5b602082029050602081019050919050565b600080fd5b600081519050614ef381613f37565b92915050565b6000614f0c614f0784614eb3565b613a16565b90508083825260208201905060208402830185811115614f2f57614f2e614edf565b5b835b81811015614f585780614f448882614ee4565b845260208401935050602081019050614f31565b5050509392505050565b600082601f830112614f7757614f7661399b565b5b8151614f87848260208601614ef9565b91505092915050565b600060c08284031215614fa657614fa5614e7f565b5b614fb060c0613a16565b90506000614fc084828501614e89565b6000830152506020614fd484828501614e89565b6020830152506040614fe884828501614e9e565b604083015250606082015167ffffffffffffffff81111561500c5761500b614e84565b5b61501884828501614f62565b606083015250608082015167ffffffffffffffff81111561503c5761503b614e84565b5b61504884828501614f62565b60808301525060a082015167ffffffffffffffff81111561506c5761506b614e84565b5b61507884828501614b4a565b60a08301525092915050565b60006020828403121561509a57615099613991565b5b600082015167ffffffffffffffff8111156150b8576150b7613996565b5b6150c484828501614f90565b91505092915050565b60006060820190506150e26000830186613fce565b81810360208301526150f48185613dd6565b905081810360408301526151088184613c75565b9050949350505050565b7f7b22747873223a205b2200000000000000000000000000000000000000000000600082015250565b6000615148600a8361411a565b915061515382615112565b600a82019050919050565b7f225d7d0000000000000000000000000000000000000000000000000000000000600082015250565b600061519460038361411a565b915061519f8261515e565b600382019050919050565b60006151b58261513b565b91506151c18284614197565b91506151cc82615187565b915081905092915050565b7f42756e646c6553696d756c6174696f6e4661696c65643a200000000000000000600082015250565b600061520d60188361411a565b9150615218826151d7565b601882019050919050565b600061522e82615200565b915061523a8284614197565b915081905092915050565b7f6574685f73656e6442756e646c65000000000000000000000000000000000000600082015250565b600061527b600e83613dc5565b915061528682615245565b602082019050919050565b600060608201905081810360008301526152ab8185613dd6565b905081810360208301526152be8161526e565b905081810360408301526152d28184613c75565b90509392505050565b7f42756e646c655375626d697373696f6e4661696c65643a200000000000000000600082015250565b600061531160188361411a565b915061531c826152db565b601882019050919050565b600061533282615304565b915061533e8284614197565b915081905092915050565b600061535582856145af565b915061536182846145af565b91508190509392505050565b60008160601b9050919050565b60006153858261536d565b9050919050565b60006153978261537a565b9050919050565b6153af6153aa82613f25565b61538c565b82525050565b60006153c1828461539e565b60148201915081905092915050565b60006040820190506153e56000830185613fce565b81810360208301526153f78184613dd6565b90509392505050565b7f696e76616c6964207369676e6174757265206c656e6774680000000000000000600082015250565b6000615436601883613dc5565b915061544182615400565b602082019050919050565b6000602082019050818103600083015261546581615429565b9050919050565b600061547782613e31565b915061548283613e31565b92508260ff0382111561549857615497614740565b5b828201905092915050565b7f7b22626c6f636b4e756d626572223a2022000000000000000000000000000000600082015250565b60006154d960118361411a565b91506154e4826154a3565b601182019050919050565b7f222c2022747873223a205b000000000000000000000000000000000000000000600082015250565b6000615525600b8361411a565b9150615530826154ef565b600b82019050919050565b6000615546826154cc565b91506155528284614197565b915061555d82615518565b915081905092915050565b7f2200000000000000000000000000000000000000000000000000000000000000600082015250565b600061559e60018361411a565b91506155a982615568565b600182019050919050565b60006155c082856145af565b91506155cb82615591565b91506155d78284614197565b91506155e282615591565b91508190509392505050565b7f2c00000000000000000000000000000000000000000000000000000000000000600082015250565b600061562460018361411a565b915061562f826155ee565b600182019050919050565b600061564682846145af565b915061565182615617565b915081905092915050565b7f5d00000000000000000000000000000000000000000000000000000000000000600082015250565b600061569260018361411a565b915061569d8261565c565b600182019050919050565b60006156b482846145af565b91506156bf82615685565b915081905092915050565b7f7d00000000000000000000000000000000000000000000000000000000000000600082015250565b600061570060018361411a565b915061570b826156ca565b600182019050919050565b600061572282846145af565b915061572d826156f3565b915081905092915050565b6000819050919050565b61575361574e82613ae1565b615738565b82525050565b60006157658284615742565b60208201915081905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b60006157ae82613ae1565b91506157b983613ae1565b9250826157c9576157c8615774565b5b828204905092915050565b60006157df82613ae1565b91506157ea83613ae1565b92506158177fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8484614958565b905092915050565b600061582a82613ae1565b915061583583613ae1565b92508261584557615844615774565b5b82820690509291505056fe68747470733a2f2f646174612d6170692e62696e616e63652e766973696f6e2f6170692f76332f7469636b65722f70726963653f73796d626f6c3d68747470733a2f2f657468657265756d2d686f6c65736b792d7270632e7075626c69636e6f64652e636f6d68747470733a2f2f72656c61792d686f6c65736b792e666c617368626f74732e6e6574a2646970667358221220432fa067b94e54e62cdaa12a25113ce1168df52048191e4ffbb02624927a7e9264736f6c634300080d0033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 5525,
        "contract": "contracts/oracle/BinanceOracle.sol:BinanceOracle",
        "label": "isInitialized",
        "offset": 0,
        "slot": "0",
        "type": "t_bool"
      },
      {
        "astId": 5528,
        "contract": "contracts/oracle/BinanceOracle.sol:BinanceOracle",
        "label": "pkBidId",
        "offset": 1,
        "slot": "0",
        "type": "t_userDefinedValueType(DataId)2628"
      },
      {
        "astId": 5530,
        "contract": "contracts/oracle/BinanceOracle.sol:BinanceOracle",
        "label": "controller",
        "offset": 0,
        "slot": "1",
        "type": "t_address"
      },
      {
        "astId": 5532,
        "contract": "contracts/oracle/BinanceOracle.sol:BinanceOracle",
        "label": "settlementContract",
        "offset": 0,
        "slot": "2",
        "type": "t_address"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_userDefinedValueType(DataId)2628": {
        "encoding": "inplace",
        "label": "Suave.DataId",
        "numberOfBytes": "16"
      }
    }
  }
}