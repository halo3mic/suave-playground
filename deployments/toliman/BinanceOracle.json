{
  "address": "0xa2a2E84e6F126332b4F619D850Ebc269c0239438",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "name": "PeekerReverted",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "message",
          "type": "string"
        }
      ],
      "name": "SuaveError",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "message",
          "type": "string"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "SuaveErrorWithData",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "string",
          "name": "ticker",
          "type": "string"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "price",
          "type": "uint256"
        }
      ],
      "name": "PriceSubmission",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "response",
          "type": "bytes"
        }
      ],
      "name": "RpcResponse",
      "type": "event"
    },
    {
      "stateMutability": "payable",
      "type": "fallback"
    },
    {
      "inputs": [],
      "name": "DECIMALS",
      "outputs": [
        {
          "internalType": "uint8",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "HOLESKY_BUNDLE_ENDPOINT",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "HOLESKY_CHAINID",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "HOLESKY_CHAINID_STR",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "HOLESKY_RPC",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "S_NAMESPACE",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "URL_PARTIAL",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "confidentialConstructor",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "Suave.DataId",
          "name": "_pkBidId",
          "type": "bytes16"
        },
        {
          "internalType": "address",
          "name": "pkAddress",
          "type": "address"
        }
      ],
      "name": "confidentialConstructorCallback",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "controller",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "isInitialized",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "pkBidId",
      "outputs": [
        {
          "internalType": "Suave.DataId",
          "name": "",
          "type": "bytes16"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "ticker",
          "type": "string"
        },
        {
          "internalType": "uint256",
          "name": "nonce",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "gasPrice",
          "type": "uint256"
        },
        {
          "internalType": "uint64",
          "name": "settlementBlockNum",
          "type": "uint64"
        },
        {
          "internalType": "bool",
          "name": "privateSubmission",
          "type": "bool"
        }
      ],
      "name": "queryAndSubmit",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "ticker",
          "type": "string"
        },
        {
          "internalType": "uint256",
          "name": "price",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "rpcResponse",
          "type": "bytes"
        }
      ],
      "name": "queryAndSubmitCallback",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "ticker",
          "type": "string"
        }
      ],
      "name": "queryLatestPrice",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "price",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_settlementContract",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "rpcResponse",
          "type": "bytes"
        }
      ],
      "name": "registerCallback",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_settlementContract",
          "type": "address"
        }
      ],
      "name": "registerSettlementContract",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "txSigned",
          "type": "bytes"
        }
      ],
      "name": "sendRawTx",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "settlementContract",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xe2daa4eaf551af2cd7fe8a09730afe3677ac58f485bfd597c9f2bbdbe606009f",
  "receipt": {
    "to": null,
    "from": "0x16f2Aa8dF055b6e672b93Ded41FecCCabAB565B0",
    "contractAddress": "0xa2a2E84e6F126332b4F619D850Ebc269c0239438",
    "transactionIndex": 0,
    "gasUsed": "5012175",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x097fdba0b350375c2afef26140735b904ed58553620e37b22007a263437d228a",
    "transactionHash": "0xe2daa4eaf551af2cd7fe8a09730afe3677ac58f485bfd597c9f2bbdbe606009f",
    "logs": [],
    "blockNumber": 706419,
    "cumulativeGasUsed": "5012175",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "13d83d467b1208ef044a154ee4fa8d41",
  "metadata": "{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"PeekerReverted\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"SuaveError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SuaveErrorWithData\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"ticker\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"PriceSubmission\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"response\",\"type\":\"bytes\"}],\"name\":\"RpcResponse\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"DECIMALS\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"HOLESKY_BUNDLE_ENDPOINT\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"HOLESKY_CHAINID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"HOLESKY_CHAINID_STR\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"HOLESKY_RPC\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"S_NAMESPACE\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"URL_PARTIAL\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"confidentialConstructor\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"Suave.DataId\",\"name\":\"_pkBidId\",\"type\":\"bytes16\"},{\"internalType\":\"address\",\"name\":\"pkAddress\",\"type\":\"address\"}],\"name\":\"confidentialConstructorCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isInitialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pkBidId\",\"outputs\":[{\"internalType\":\"Suave.DataId\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"ticker\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"settlementBlockNum\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"privateSubmission\",\"type\":\"bool\"}],\"name\":\"queryAndSubmit\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"ticker\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"rpcResponse\",\"type\":\"bytes\"}],\"name\":\"queryAndSubmitCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"ticker\",\"type\":\"string\"}],\"name\":\"queryLatestPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_settlementContract\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"rpcResponse\",\"type\":\"bytes\"}],\"name\":\"registerCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_settlementContract\",\"type\":\"address\"}],\"name\":\"registerSettlementContract\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"txSigned\",\"type\":\"bytes\"}],\"name\":\"sendRawTx\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"settlementContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/oracle/BinanceOracle.sol\":\"BinanceOracle\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/blockad/lib/SuaveContract.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// Author: Miha Lotric (halo3mic)\\n\\npragma solidity ^0.8.8;\\n\\nimport { Suave } from \\\"../../standard_peekers/bids.sol\\\";\\n\\n\\nabstract contract SuaveContract {\\n\\terror SuaveError(string message);\\n\\terror SuaveErrorWithData(string message, bytes data);\\n\\n\\tmodifier onlyConfidential() {\\n\\t\\tcrequire(Suave.isConfidential(), \\\"Not confidential\\\");\\n\\t\\t_;\\n\\t}\\n\\n\\tfunction simulateBundleSafe(bytes memory bundle, bool doRevert) internal view returns (bool valid, uint64 egp) {\\n\\t\\t(bool success, bytes memory d) = Suave.SIMULATE_BUNDLE.staticcall{ gas: 20_000 }(abi.encode(bundle));\\n\\t\\tcrequire(!doRevert || success, string(d));\\n\\t\\tif (success) {\\n\\t\\t\\treturn (true, abi.decode(d, (uint64)));\\n\\t\\t}\\n\\t}\\n\\n\\tfunction crequire(bool condition, string memory message) internal pure {\\n\\t\\tif (!condition) {\\n\\t\\t\\trevert SuaveError(message);\\n\\t\\t}\\n\\t}\\n}\\n\",\"keccak256\":\"0x64eb01469afe18f29050571acd52ee35faca1da2c00a87e01d5ea0fdbcdf4bec\",\"license\":\"MIT\"},\"contracts/libraries/Bundle.sol\":{\"content\":\"// Source: https://github.com/flashbots/suave-std/blob/main/src/protocols/Bundle.sol\\n\\n\\n// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\nimport \\\"./Suave.sol\\\";\\nimport \\\"solady/src/utils/LibString.sol\\\";\\n\\n// https://docs.flashbots.net/flashbots-auction/advanced/rpc-endpoint#eth_sendbundle\\nlibrary Bundle {\\n    struct BundleObj {\\n        uint64 blockNumber;\\n        uint64 minTimestamp;\\n        uint64 maxTimestamp;\\n        bytes[] txns;\\n    }\\n\\n    function sendBundle(string memory url, BundleObj memory bundle) internal returns (bytes memory) {\\n        Suave.HttpRequest memory request = encodeBundle(bundle);\\n        request.url = url;\\n        return Suave.doHTTPRequest(request);\\n    }\\n\\n    function encodeBundle(BundleObj memory args) internal pure returns (Suave.HttpRequest memory) {\\n        require(args.txns.length > 0, \\\"Bundle: no txns\\\");\\n\\n        bytes memory params =\\n            abi.encodePacked('{\\\"blockNumber\\\": \\\"', LibString.toHexString(args.blockNumber), '\\\", \\\"txs\\\": [');\\n        for (uint256 i = 0; i < args.txns.length; i++) {\\n            params = abi.encodePacked(params, '\\\"', LibString.toHexString(args.txns[i]), '\\\"');\\n            if (i < args.txns.length - 1) {\\n                params = abi.encodePacked(params, \\\",\\\");\\n            } else {\\n                params = abi.encodePacked(params, \\\"]\\\");\\n            }\\n        }\\n        if (args.minTimestamp > 0) {\\n            params = abi.encodePacked(params, ', \\\"minTimestamp\\\": ', LibString.toString(args.minTimestamp));\\n        }\\n        if (args.maxTimestamp > 0) {\\n            params = abi.encodePacked(params, ', \\\"maxTimestamp\\\": ', LibString.toString(args.maxTimestamp));\\n        }\\n        params = abi.encodePacked(params, ', \\\"maxTimestamp\\\": ', LibString.toString(args.maxTimestamp));\\n        params = abi.encodePacked(params, \\\"}\\\");\\n\\n        bytes memory body =\\n            abi.encodePacked('{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"method\\\":\\\"eth_sendBundle\\\",\\\"params\\\":[', params, '],\\\"id\\\":1}');\\n\\n        Suave.HttpRequest memory request;\\n        request.method = \\\"POST\\\";\\n        request.body = body;\\n        request.headers = new string[](1);\\n        request.headers[0] = \\\"Content-Type: application/json\\\";\\n        request.withFlashbotsSignature = true;\\n\\n        return request;\\n    }\\n}\",\"keccak256\":\"0xb74ba160c26d46ed7a74f84a202b28f2bbf8ec5c4700032881b9186db84d5d04\",\"license\":\"Unlicense\"},\"contracts/libraries/RLPWriter.sol\":{\"content\":\"// Source: https://github.com/flashbots/suave-std/blob/main/src/utils/RLPWriter.sol\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @custom:attribution https://github.com/bakaoh/solidity-rlp-encode\\n * @title RLPWriter\\n * @author RLPWriter is a library for encoding Solidity types to RLP bytes. Adapted from Bakaoh's\\n *         RLPEncode library (https://github.com/bakaoh/solidity-rlp-encode) with minor\\n *         modifications to improve legibility.\\n */\\nlibrary RLPWriter {\\n    /**\\n     * @notice RLP encodes a byte string.\\n     *\\n     * @param _in The byte string to encode.\\n     *\\n     * @return The RLP encoded string in bytes.\\n     */\\n    function writeBytes(bytes memory _in) internal pure returns (bytes memory) {\\n        bytes memory encoded;\\n\\n        if (_in.length == 1 && uint8(_in[0]) < 128) {\\n            encoded = _in;\\n        } else {\\n            encoded = abi.encodePacked(_writeLength(_in.length, 128), _in);\\n        }\\n\\n        return encoded;\\n    }\\n\\n    /**\\n     * @notice RLP encodes a list of RLP encoded byte byte strings.\\n     *\\n     * @param _in The list of RLP encoded byte strings.\\n     *\\n     * @return The RLP encoded list of items in bytes.\\n     */\\n    function writeList(bytes[] memory _in) internal pure returns (bytes memory) {\\n        bytes memory list = _flatten(_in);\\n        return abi.encodePacked(_writeLength(list.length, 192), list);\\n    }\\n\\n    /**\\n     * @notice RLP encodes a string.\\n     *\\n     * @param _in The string to encode.\\n     *\\n     * @return The RLP encoded string in bytes.\\n     */\\n    function writeString(string memory _in) internal pure returns (bytes memory) {\\n        return writeBytes(bytes(_in));\\n    }\\n\\n    /**\\n     * @notice RLP encodes an address.\\n     *\\n     * @param _in The address to encode.\\n     *\\n     * @return The RLP encoded address in bytes.\\n     */\\n    function writeAddress(address _in) internal pure returns (bytes memory) {\\n        return writeBytes(abi.encodePacked(_in));\\n    }\\n\\n    /**\\n     * @notice RLP encodes a uint.\\n     *\\n     * @param _in The uint256 to encode.\\n     *\\n     * @return The RLP encoded uint256 in bytes.\\n     */\\n    function writeUint(uint256 _in) internal pure returns (bytes memory) {\\n        return writeBytes(_toBinary(_in));\\n    }\\n\\n    /**\\n     * @notice RLP encodes a bool.\\n     *\\n     * @param _in The bool to encode.\\n     *\\n     * @return The RLP encoded bool in bytes.\\n     */\\n    function writeBool(bool _in) internal pure returns (bytes memory) {\\n        bytes memory encoded = new bytes(1);\\n        encoded[0] = (_in ? bytes1(0x01) : bytes1(0x80));\\n        return encoded;\\n    }\\n\\n    /**\\n     * @notice Encode the first byte and then the `len` in binary form if `length` is more than 55.\\n     *\\n     * @param _len    The length of the string or the payload.\\n     * @param _offset 128 if item is string, 192 if item is list.\\n     *\\n     * @return RLP encoded bytes.\\n     */\\n    function _writeLength(uint256 _len, uint256 _offset) private pure returns (bytes memory) {\\n        bytes memory encoded;\\n\\n        if (_len < 56) {\\n            encoded = new bytes(1);\\n            encoded[0] = bytes1(uint8(_len) + uint8(_offset));\\n        } else {\\n            uint256 lenLen;\\n            uint256 i = 1;\\n            while (_len / i != 0) {\\n                lenLen++;\\n                i *= 256;\\n            }\\n\\n            encoded = new bytes(lenLen + 1);\\n            encoded[0] = bytes1(uint8(lenLen) + uint8(_offset) + 55);\\n            for (i = 1; i <= lenLen; i++) {\\n                encoded[i] = bytes1(uint8((_len / (256 ** (lenLen - i))) % 256));\\n            }\\n        }\\n\\n        return encoded;\\n    }\\n\\n    /**\\n     * @notice Encode integer in big endian binary form with no leading zeroes.\\n     *\\n     * @param _x The integer to encode.\\n     *\\n     * @return RLP encoded bytes.\\n     */\\n    function _toBinary(uint256 _x) private pure returns (bytes memory) {\\n        bytes memory b = abi.encodePacked(_x);\\n\\n        uint256 i = 0;\\n        for (; i < 32; i++) {\\n            if (b[i] != 0) {\\n                break;\\n            }\\n        }\\n\\n        bytes memory res = new bytes(32 - i);\\n        for (uint256 j = 0; j < res.length; j++) {\\n            res[j] = b[i++];\\n        }\\n\\n        return res;\\n    }\\n\\n    /**\\n     * @custom:attribution https://github.com/Arachnid/solidity-stringutils\\n     * @notice Copies a piece of memory to another location.\\n     *\\n     * @param _dest Destination location.\\n     * @param _src  Source location.\\n     * @param _len  Length of memory to copy.\\n     */\\n    function _memcpy(uint256 _dest, uint256 _src, uint256 _len) private pure {\\n        uint256 dest = _dest;\\n        uint256 src = _src;\\n        uint256 len = _len;\\n\\n        for (; len >= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        uint256 mask;\\n        unchecked {\\n            mask = 256 ** (32 - len) - 1;\\n        }\\n        assembly {\\n            let srcpart := and(mload(src), not(mask))\\n            let destpart := and(mload(dest), mask)\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n    }\\n\\n    /**\\n     * @custom:attribution https://github.com/sammayo/solidity-rlp-encoder\\n     * @notice Flattens a list of byte strings into one byte string.\\n     *\\n     * @param _list List of byte strings to flatten.\\n     *\\n     * @return The flattened byte string.\\n     */\\n    function _flatten(bytes[] memory _list) private pure returns (bytes memory) {\\n        if (_list.length == 0) {\\n            return new bytes(0);\\n        }\\n\\n        uint256 len;\\n        uint256 i = 0;\\n        for (; i < _list.length; i++) {\\n            len += _list[i].length;\\n        }\\n\\n        bytes memory flattened = new bytes(len);\\n        uint256 flattenedPtr;\\n        assembly {\\n            flattenedPtr := add(flattened, 0x20)\\n        }\\n\\n        for (i = 0; i < _list.length; i++) {\\n            bytes memory item = _list[i];\\n\\n            uint256 listPtr;\\n            assembly {\\n                listPtr := add(item, 0x20)\\n            }\\n\\n            _memcpy(flattenedPtr, listPtr, item.length);\\n            flattenedPtr += _list[i].length;\\n        }\\n\\n        return flattened;\\n    }\\n}\",\"keccak256\":\"0x56651ebc297bf3681217d96f035f3f1fdd3027ae64f55087095182c90307f703\",\"license\":\"MIT\"},\"contracts/libraries/Suave.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.8;\\n\\n/// @notice Library to interact with the Suave MEVM precompiles.\\nlibrary Suave {\\n    error PeekerReverted(address, bytes);\\n\\n    enum CryptoSignature {\\n        SECP256,\\n        BLS\\n    }\\n\\n    type DataId is bytes16;\\n\\n    /// @notice Arguments to build the block.\\n    /// @param slot Slot number of the block\\n    /// @param proposerPubkey Public key of the proposer\\n    /// @param parent Hash of the parent block\\n    /// @param timestamp Timestamp of the block\\n    /// @param feeRecipient Address of the fee recipient\\n    /// @param gasLimit Gas limit of the block\\n    /// @param random Randomness of the block\\n    /// @param withdrawals List of withdrawals\\n    /// @param extra Extra data of the block\\n    /// @param beaconRoot Root of the beacon chain\\n    /// @param fillPending Whether to fill the block with pending transactions\\n    struct BuildBlockArgs {\\n        uint64 slot;\\n        bytes proposerPubkey;\\n        bytes32 parent;\\n        uint64 timestamp;\\n        address feeRecipient;\\n        uint64 gasLimit;\\n        bytes32 random;\\n        Withdrawal[] withdrawals;\\n        bytes extra;\\n        bytes32 beaconRoot;\\n        bool fillPending;\\n    }\\n\\n    /// @notice A record of data stored in the ConfidentialStore.\\n    /// @param id ID of the data record\\n    /// @param salt Salt used to derive the encryption key\\n    /// @param decryptionCondition Up to which block this data record is valid\\n    /// @param allowedPeekers Addresses which can get data\\n    /// @param allowedStores Addresses can set data\\n    /// @param version Namespace of the data record\\n    struct DataRecord {\\n        DataId id;\\n        DataId salt;\\n        uint64 decryptionCondition;\\n        address[] allowedPeekers;\\n        address[] allowedStores;\\n        string version;\\n    }\\n\\n    /// @notice Description of an HTTP request.\\n    /// @param url Target url of the request\\n    /// @param method HTTP method of the request\\n    /// @param headers HTTP Headers\\n    /// @param body Body of the request (if Post or Put)\\n    /// @param withFlashbotsSignature Whether to include the Flashbots signature\\n    /// @param timeout Timeout of the request in milliseconds\\n    struct HttpRequest {\\n        string url;\\n        string method;\\n        string[] headers;\\n        bytes body;\\n        bool withFlashbotsSignature;\\n        uint64 timeout;\\n    }\\n\\n    /// @notice Result of a simulated transaction.\\n    /// @param egp Effective Gas Price of the transaction\\n    /// @param logs Logs emitted during the simulation\\n    /// @param success Whether the transaction was successful or not\\n    /// @param error Error message if any\\n    struct SimulateTransactionResult {\\n        uint64 egp;\\n        SimulatedLog[] logs;\\n        bool success;\\n        string error;\\n    }\\n\\n    /// @notice A log emitted during the simulation of a transaction.\\n    /// @param data Data of the log\\n    /// @param addr Address of the contract that emitted the log\\n    /// @param topics Topics of the log\\n    struct SimulatedLog {\\n        bytes data;\\n        address addr;\\n        bytes32[] topics;\\n    }\\n\\n    /// @notice A withdrawal from the beacon chain.\\n    /// @param index Index of the withdrawal\\n    /// @param validator ID of the validator\\n    /// @param Address Address to withdraw to\\n    /// @param amount Amount to be withdrawn\\n    struct Withdrawal {\\n        uint64 index;\\n        uint64 validator;\\n        address Address;\\n        uint64 amount;\\n    }\\n\\n    address public constant ANYALLOWED = 0xC8df3686b4Afb2BB53e60EAe97EF043FE03Fb829;\\n\\n    address public constant IS_CONFIDENTIAL_ADDR = 0x0000000000000000000000000000000042010000;\\n\\n    address public constant BUILD_ETH_BLOCK = 0x0000000000000000000000000000000042100001;\\n\\n    address public constant BUILD_ETH_BLOCK_TO = 0x0000000000000000000000000000000042100006;\\n\\n    address public constant CONFIDENTIAL_INPUTS = 0x0000000000000000000000000000000042010001;\\n\\n    address public constant CONFIDENTIAL_RETRIEVE = 0x0000000000000000000000000000000042020001;\\n\\n    address public constant CONFIDENTIAL_STORE = 0x0000000000000000000000000000000042020000;\\n\\n    address public constant CONTEXT_GET = 0x0000000000000000000000000000000053300003;\\n\\n    address public constant DO_HTTPREQUEST = 0x0000000000000000000000000000000043200002;\\n\\n    address public constant ETHCALL = 0x0000000000000000000000000000000042100003;\\n\\n    address public constant EXTRACT_HINT = 0x0000000000000000000000000000000042100037;\\n\\n    address public constant FETCH_DATA_RECORDS = 0x0000000000000000000000000000000042030001;\\n\\n    address public constant FILL_MEV_SHARE_BUNDLE = 0x0000000000000000000000000000000043200001;\\n\\n    address public constant NEW_BUILDER = 0x0000000000000000000000000000000053200001;\\n\\n    address public constant NEW_DATA_RECORD = 0x0000000000000000000000000000000042030000;\\n\\n    address public constant PRIVATE_KEY_GEN = 0x0000000000000000000000000000000053200003;\\n\\n    address public constant RANDOM_BYTES = 0x000000000000000000000000000000007770000b;\\n\\n    address public constant SIGN_ETH_TRANSACTION = 0x0000000000000000000000000000000040100001;\\n\\n    address public constant SIGN_MESSAGE = 0x0000000000000000000000000000000040100003;\\n\\n    address public constant SIMULATE_BUNDLE = 0x0000000000000000000000000000000042100000;\\n\\n    address public constant SIMULATE_TRANSACTION = 0x0000000000000000000000000000000053200002;\\n\\n    address public constant SUBMIT_BUNDLE_JSON_RPC = 0x0000000000000000000000000000000043000001;\\n\\n    address public constant SUBMIT_ETH_BLOCK_TO_RELAY = 0x0000000000000000000000000000000042100002;\\n\\n    /// @notice Returns whether execution is off- or on-chain\\n    /// @return b Whether execution is off- or on-chain\\n    function isConfidential() internal returns (bool b) {\\n        (bool success, bytes memory isConfidentialBytes) = IS_CONFIDENTIAL_ADDR.call(\\\"\\\");\\n        if (!success) {\\n            revert PeekerReverted(IS_CONFIDENTIAL_ADDR, isConfidentialBytes);\\n        }\\n        assembly {\\n            // Load the length of data (first 32 bytes)\\n            let len := mload(isConfidentialBytes)\\n            // Load the data after 32 bytes, so add 0x20\\n            b := mload(add(isConfidentialBytes, 0x20))\\n        }\\n    }\\n\\n    /// @notice Constructs an Ethereum block based on the provided data records. No blobs are returned.\\n    /// @param blockArgs Arguments to build the block\\n    /// @param dataId ID of the data record with mev-share bundle data\\n    /// @param relayUrl If specified the built block will be submitted to the relay\\n    /// @return blockBid Block Bid encoded in JSON\\n    /// @return executionPayload Execution payload encoded in JSON\\n    function buildEthBlock(BuildBlockArgs memory blockArgs, DataId dataId, string memory relayUrl)\\n        internal\\n        returns (bytes memory, bytes memory)\\n    {\\n        (bool success, bytes memory data) = BUILD_ETH_BLOCK.call(abi.encode(blockArgs, dataId, relayUrl));\\n        if (!success) {\\n            revert PeekerReverted(BUILD_ETH_BLOCK, data);\\n        }\\n\\n        return abi.decode(data, (bytes, bytes));\\n    }\\n\\n    /// @notice Constructs an Ethereum block based on the provided data records. No blobs are returned.\\n    /// @param executionNodeURL URL (or service name) of the execution node\\n    /// @param blockArgs Arguments to build the block\\n    /// @param dataId ID of the data record with mev-share bundle data\\n    /// @param relayUrl If specified the built block will be submitted to the relay\\n    /// @return blockBid Block Bid encoded in JSON\\n    /// @return executionPayload Execution payload encoded in JSON\\n    function buildEthBlockTo(\\n        string memory executionNodeURL,\\n        BuildBlockArgs memory blockArgs,\\n        DataId dataId,\\n        string memory relayUrl\\n    ) internal returns (bytes memory, bytes memory) {\\n        (bool success, bytes memory data) =\\n            BUILD_ETH_BLOCK_TO.call(abi.encode(executionNodeURL, blockArgs, dataId, relayUrl));\\n        if (!success) {\\n            revert PeekerReverted(BUILD_ETH_BLOCK_TO, data);\\n        }\\n\\n        return abi.decode(data, (bytes, bytes));\\n    }\\n\\n    /// @notice Provides the confidential inputs associated with a confidential computation request. Outputs are in bytes format.\\n    /// @return confindentialData Confidential inputs\\n    function confidentialInputs() internal returns (bytes memory) {\\n        (bool success, bytes memory data) = CONFIDENTIAL_INPUTS.call(abi.encode());\\n        if (!success) {\\n            revert PeekerReverted(CONFIDENTIAL_INPUTS, data);\\n        }\\n\\n        return data;\\n    }\\n\\n    /// @notice Retrieves data from the confidential store. Also mandates the caller's presence in the `AllowedPeekers` list.\\n    /// @param dataId ID of the data record to retrieve\\n    /// @param key Key slot of the data to retrieve\\n    /// @return value Value of the data\\n    function confidentialRetrieve(DataId dataId, string memory key) internal returns (bytes memory) {\\n        (bool success, bytes memory data) = CONFIDENTIAL_RETRIEVE.call(abi.encode(dataId, key));\\n        if (!success) {\\n            revert PeekerReverted(CONFIDENTIAL_RETRIEVE, data);\\n        }\\n\\n        return data;\\n    }\\n\\n    /// @notice Stores data in the confidential store. Requires the caller to be part of the `AllowedPeekers` for the associated data record.\\n    /// @param dataId ID of the data record to store\\n    /// @param key Key slot of the data to store\\n    /// @param value Value of the data to store\\n    function confidentialStore(DataId dataId, string memory key, bytes memory value) internal {\\n        (bool success, bytes memory data) = CONFIDENTIAL_STORE.call(abi.encode(dataId, key, value));\\n        if (!success) {\\n            revert PeekerReverted(CONFIDENTIAL_STORE, data);\\n        }\\n    }\\n\\n    /// @notice Retrieves a value from the context\\n    /// @param key Key of the value to retrieve\\n    /// @return value Value of the key\\n    function contextGet(string memory key) internal returns (bytes memory) {\\n        (bool success, bytes memory data) = CONTEXT_GET.call(abi.encode(key));\\n        if (!success) {\\n            revert PeekerReverted(CONTEXT_GET, data);\\n        }\\n\\n        return abi.decode(data, (bytes));\\n    }\\n\\n    /// @notice Performs an HTTP request and returns the response. `request` is the request to perform.\\n    /// @param request Request to perform\\n    /// @return httpResponse Body of the response\\n    function doHTTPRequest(HttpRequest memory request) internal returns (bytes memory) {\\n        (bool success, bytes memory data) = DO_HTTPREQUEST.call(abi.encode(request));\\n        if (!success) {\\n            revert PeekerReverted(DO_HTTPREQUEST, data);\\n        }\\n\\n        return abi.decode(data, (bytes));\\n    }\\n\\n    /// @notice Uses the `eth_call` JSON RPC method to let you simulate a function call and return the response.\\n    /// @param contractAddr Address of the contract to call\\n    /// @param input1 Data to send to the contract\\n    /// @return callOutput Output of the contract call\\n    function ethcall(address contractAddr, bytes memory input1) internal returns (bytes memory) {\\n        (bool success, bytes memory data) = ETHCALL.call(abi.encode(contractAddr, input1));\\n        if (!success) {\\n            revert PeekerReverted(ETHCALL, data);\\n        }\\n\\n        return abi.decode(data, (bytes));\\n    }\\n\\n    /// @notice Interprets the bundle data and extracts hints, such as the `To` address and calldata.\\n    /// @param bundleData Bundle object encoded in JSON\\n    /// @return hints List of hints encoded in JSON\\n    function extractHint(bytes memory bundleData) internal returns (bytes memory) {\\n        require(isConfidential());\\n        (bool success, bytes memory data) = EXTRACT_HINT.call(abi.encode(bundleData));\\n        if (!success) {\\n            revert PeekerReverted(EXTRACT_HINT, data);\\n        }\\n\\n        return data;\\n    }\\n\\n    /// @notice Retrieves all data records correlating with a specified decryption condition and namespace\\n    /// @param cond Filter for the decryption condition\\n    /// @param namespace Filter for the namespace of the data records\\n    /// @return dataRecords List of data records that match the filter\\n    function fetchDataRecords(uint64 cond, string memory namespace) internal returns (DataRecord[] memory) {\\n        (bool success, bytes memory data) = FETCH_DATA_RECORDS.call(abi.encode(cond, namespace));\\n        if (!success) {\\n            revert PeekerReverted(FETCH_DATA_RECORDS, data);\\n        }\\n\\n        return abi.decode(data, (DataRecord[]));\\n    }\\n\\n    /// @notice Joins the user's transaction and with the backrun, and returns encoded mev-share bundle. The bundle is ready to be sent via `SubmitBundleJsonRPC`.\\n    /// @param dataId ID of the data record with mev-share bundle data\\n    /// @return encodedBundle Mev-Share bundle encoded in JSON\\n    function fillMevShareBundle(DataId dataId) internal returns (bytes memory) {\\n        require(isConfidential());\\n        (bool success, bytes memory data) = FILL_MEV_SHARE_BUNDLE.call(abi.encode(dataId));\\n        if (!success) {\\n            revert PeekerReverted(FILL_MEV_SHARE_BUNDLE, data);\\n        }\\n\\n        return data;\\n    }\\n\\n    /// @notice Initializes a new remote builder session\\n    /// @return sessionid ID of the remote builder session\\n    function newBuilder() internal returns (string memory) {\\n        (bool success, bytes memory data) = NEW_BUILDER.call(abi.encode());\\n        if (!success) {\\n            revert PeekerReverted(NEW_BUILDER, data);\\n        }\\n\\n        return abi.decode(data, (string));\\n    }\\n\\n    /// @notice Initializes data records within the ConfidentialStore. Prior to storing data, all data records should undergo initialization via this precompile.\\n    /// @param decryptionCondition Up to which block this data record is valid. Used during `fillMevShareBundle` precompie.\\n    /// @param allowedPeekers Addresses which can get data\\n    /// @param allowedStores Addresses can set data\\n    /// @param dataType Namespace of the data\\n    /// @return dataRecord Data record that was created\\n    function newDataRecord(\\n        uint64 decryptionCondition,\\n        address[] memory allowedPeekers,\\n        address[] memory allowedStores,\\n        string memory dataType\\n    ) internal returns (DataRecord memory) {\\n        (bool success, bytes memory data) =\\n            NEW_DATA_RECORD.call(abi.encode(decryptionCondition, allowedPeekers, allowedStores, dataType));\\n        if (!success) {\\n            revert PeekerReverted(NEW_DATA_RECORD, data);\\n        }\\n\\n        return abi.decode(data, (DataRecord));\\n    }\\n\\n    /// @notice Generates a private key in ECDA secp256k1 format\\n    /// @param crypto Type of the private key to generate\\n    /// @return privateKey Hex encoded string of the ECDSA private key. Exactly as a signMessage precompile wants.\\n    function privateKeyGen(CryptoSignature crypto) internal returns (string memory) {\\n        (bool success, bytes memory data) = PRIVATE_KEY_GEN.call(abi.encode(crypto));\\n        if (!success) {\\n            revert PeekerReverted(PRIVATE_KEY_GEN, data);\\n        }\\n\\n        return abi.decode(data, (string));\\n    }\\n\\n    /// @notice Generates a number of random bytes, given by the argument numBytes.\\n    /// @param numBytes Number of random bytes to generate\\n    /// @return value Randomly-generated bytes\\n    function randomBytes(uint8 numBytes) internal returns (bytes memory) {\\n        (bool success, bytes memory data) = RANDOM_BYTES.call(abi.encode(numBytes));\\n        if (!success) {\\n            revert PeekerReverted(RANDOM_BYTES, data);\\n        }\\n\\n        return abi.decode(data, (bytes));\\n    }\\n\\n    /// @notice Signs an Ethereum Transaction, 1559 or Legacy, and returns raw signed transaction bytes. `txn` is binary encoding of the transaction.\\n    /// @param txn Transaction to sign (RLP encoded)\\n    /// @param chainId Id of the chain to sign for (hex encoded, with 0x prefix)\\n    /// @param signingKey Hex encoded string of the ECDSA private key (without 0x prefix)\\n    /// @return signedTxn Signed transaction encoded in RLP\\n    function signEthTransaction(bytes memory txn, string memory chainId, string memory signingKey)\\n        internal\\n        returns (bytes memory)\\n    {\\n        (bool success, bytes memory data) = SIGN_ETH_TRANSACTION.call(abi.encode(txn, chainId, signingKey));\\n        if (!success) {\\n            revert PeekerReverted(SIGN_ETH_TRANSACTION, data);\\n        }\\n\\n        return abi.decode(data, (bytes));\\n    }\\n\\n    /// @notice Signs a message and returns the signature.\\n    /// @param digest Message to sign\\n    /// @param crypto Type of the private key to generate\\n    /// @param signingKey Hex encoded string of the ECDSA private key\\n    /// @return signature Signature of the message with the private key\\n    function signMessage(bytes memory digest, CryptoSignature crypto, string memory signingKey)\\n        internal\\n        returns (bytes memory)\\n    {\\n        require(isConfidential());\\n        (bool success, bytes memory data) = SIGN_MESSAGE.call(abi.encode(digest, crypto, signingKey));\\n        if (!success) {\\n            revert PeekerReverted(SIGN_MESSAGE, data);\\n        }\\n\\n        return abi.decode(data, (bytes));\\n    }\\n\\n    /// @notice Performs a simulation of the bundle by building a block that includes it.\\n    /// @param bundleData Bundle encoded in JSON\\n    /// @return effectiveGasPrice Effective Gas Price of the resultant block\\n    function simulateBundle(bytes memory bundleData) internal returns (uint64) {\\n        (bool success, bytes memory data) = SIMULATE_BUNDLE.call(abi.encode(bundleData));\\n        if (!success) {\\n            revert PeekerReverted(SIMULATE_BUNDLE, data);\\n        }\\n\\n        return abi.decode(data, (uint64));\\n    }\\n\\n    /// @notice Simulates a transaction on a remote builder session\\n    /// @param sessionid ID of the remote builder session\\n    /// @param txn Txn to simulate encoded in RLP\\n    /// @return simulationResult Result of the simulation\\n    function simulateTransaction(string memory sessionid, bytes memory txn)\\n        internal\\n        returns (SimulateTransactionResult memory)\\n    {\\n        (bool success, bytes memory data) = SIMULATE_TRANSACTION.call(abi.encode(sessionid, txn));\\n        if (!success) {\\n            revert PeekerReverted(SIMULATE_TRANSACTION, data);\\n        }\\n\\n        return abi.decode(data, (SimulateTransactionResult));\\n    }\\n\\n    /// @notice Submits bytes as JSONRPC message to the specified URL with the specified method. As this call is intended for bundles, it also signs the params and adds `X-Flashbots-Signature` header, as usual with bundles. Regular eth bundles don't need any processing to be sent.\\n    /// @param url URL to send the request to\\n    /// @param method JSONRPC method to call\\n    /// @param params JSONRPC input params encoded in RLP\\n    /// @return errorMessage Error message if any\\n    function submitBundleJsonRPC(string memory url, string memory method, bytes memory params)\\n        internal\\n        returns (bytes memory)\\n    {\\n        require(isConfidential());\\n        (bool success, bytes memory data) = SUBMIT_BUNDLE_JSON_RPC.call(abi.encode(url, method, params));\\n        if (!success) {\\n            revert PeekerReverted(SUBMIT_BUNDLE_JSON_RPC, data);\\n        }\\n\\n        return data;\\n    }\\n\\n    /// @notice Submits a given builderBid to a mev-boost relay.\\n    /// @param relayUrl URL of the relay to submit to\\n    /// @param builderBid Block bid to submit encoded in JSON\\n    /// @return blockBid Error message if any\\n    function submitEthBlockToRelay(string memory relayUrl, bytes memory builderBid) internal returns (bytes memory) {\\n        require(isConfidential());\\n        (bool success, bytes memory data) = SUBMIT_ETH_BLOCK_TO_RELAY.call(abi.encode(relayUrl, builderBid));\\n        if (!success) {\\n            revert PeekerReverted(SUBMIT_ETH_BLOCK_TO_RELAY, data);\\n        }\\n\\n        return data;\\n    }\\n}\\n\",\"keccak256\":\"0x3cd3eda525d8403668553d130780ecdca2bdee28bb82cc58a7c138c849409f9f\",\"license\":\"UNLICENSED\"},\"contracts/libraries/Transactions.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\nimport \\\"./RLPWriter.sol\\\";\\nimport \\\"./Suave.sol\\\";\\nimport \\\"solidity-rlp/contracts/RLPReader.sol\\\";\\n\\nlibrary Transactions {\\n    using RLPReader for RLPReader.RLPItem;\\n    using RLPReader for RLPReader.Iterator;\\n    using RLPReader for bytes;\\n\\n    struct EIP155 {\\n        address to;\\n        uint256 gas;\\n        uint256 gasPrice;\\n        uint256 value;\\n        uint256 nonce;\\n        bytes data;\\n        uint256 chainId;\\n        bytes32 r;\\n        bytes32 s;\\n        uint64 v;\\n    }\\n\\n    struct EIP155Request {\\n        address to;\\n        uint256 gas;\\n        uint256 gasPrice;\\n        uint256 value;\\n        uint256 nonce;\\n        bytes data;\\n        uint256 chainId;\\n    }\\n\\n    struct EIP1559 {\\n        address to;\\n        uint64 gas;\\n        uint64 maxFeePerGas;\\n        uint64 maxPriorityFeePerGas;\\n        uint64 value;\\n        uint64 nonce;\\n        bytes data;\\n        uint64 chainId;\\n        bytes accessList;\\n        bytes32 r;\\n        bytes32 s;\\n        uint64 v;\\n    }\\n\\n    struct EIP1559Request {\\n        address to;\\n        uint64 gas;\\n        uint64 maxFeePerGas;\\n        uint64 maxPriorityFeePerGas;\\n        uint64 value;\\n        uint64 nonce;\\n        bytes data;\\n        uint64 chainId;\\n        bytes accessList;\\n    }\\n\\n    function encodeRLP(EIP155 memory txStruct) internal pure returns (bytes memory) {\\n        bytes[] memory items = new bytes[](9);\\n\\n        items[0] = RLPWriter.writeUint(txStruct.nonce);\\n        items[1] = RLPWriter.writeUint(txStruct.gasPrice);\\n        items[2] = RLPWriter.writeUint(txStruct.gas);\\n\\n        if (txStruct.to == address(0)) {\\n            items[3] = RLPWriter.writeBytes(bytes(\\\"\\\"));\\n        } else {\\n            items[3] = RLPWriter.writeAddress(txStruct.to);\\n        }\\n        items[4] = RLPWriter.writeUint(txStruct.value);\\n        items[5] = RLPWriter.writeBytes(txStruct.data);\\n        items[6] = RLPWriter.writeUint(uint256(txStruct.v));\\n        items[7] = RLPWriter.writeBytes(abi.encodePacked(txStruct.r));\\n        items[8] = RLPWriter.writeBytes(abi.encodePacked(txStruct.s));\\n\\n        return RLPWriter.writeList(items);\\n    }\\n\\n    function encodeRLP(EIP155Request memory txStruct) internal pure returns (bytes memory) {\\n        bytes[] memory items = new bytes[](9);\\n\\n        items[0] = RLPWriter.writeUint(txStruct.nonce);\\n        items[1] = RLPWriter.writeUint(txStruct.gasPrice);\\n        items[2] = RLPWriter.writeUint(txStruct.gas);\\n\\n        if (txStruct.to == address(0)) {\\n            items[3] = RLPWriter.writeBytes(bytes(\\\"\\\"));\\n        } else {\\n            items[3] = RLPWriter.writeAddress(txStruct.to);\\n        }\\n        items[4] = RLPWriter.writeUint(txStruct.value);\\n        items[5] = RLPWriter.writeBytes(txStruct.data);\\n        items[6] = RLPWriter.writeUint(txStruct.chainId);\\n        items[7] = RLPWriter.writeBytes(\\\"\\\");\\n        items[8] = RLPWriter.writeBytes(\\\"\\\");\\n\\n        return RLPWriter.writeList(items);\\n    }\\n\\n    function encodeRLP(EIP1559 memory txStruct) internal pure returns (bytes memory) {\\n        bytes[] memory items = new bytes[](12);\\n\\n        items[0] = RLPWriter.writeUint(txStruct.chainId);\\n        items[1] = RLPWriter.writeUint(txStruct.nonce);\\n        items[2] = RLPWriter.writeUint(txStruct.maxPriorityFeePerGas);\\n        items[3] = RLPWriter.writeUint(txStruct.maxFeePerGas);\\n        items[4] = RLPWriter.writeUint(txStruct.gas);\\n\\n        if (txStruct.to == address(0)) {\\n            items[5] = RLPWriter.writeBytes(bytes(\\\"\\\"));\\n        } else {\\n            items[5] = RLPWriter.writeAddress(txStruct.to);\\n        }\\n\\n        items[6] = RLPWriter.writeUint(txStruct.value);\\n        items[7] = RLPWriter.writeBytes(txStruct.data);\\n\\n        if (txStruct.accessList.length == 0) {\\n            items[8] = hex\\\"c0\\\"; // Empty list encoding\\n        } else {\\n            items[8] = RLPWriter.writeBytes(txStruct.accessList);\\n        }\\n\\n        items[9] = RLPWriter.writeUint(uint256(txStruct.v));\\n        items[10] = RLPWriter.writeBytes(abi.encodePacked(txStruct.r));\\n        items[11] = RLPWriter.writeBytes(abi.encodePacked(txStruct.s));\\n\\n        bytes memory rlpTxn = RLPWriter.writeList(items);\\n\\n        bytes memory txn = new bytes(1 + rlpTxn.length);\\n        txn[0] = 0x02;\\n\\n        for (uint256 i = 0; i < rlpTxn.length; ++i) {\\n            txn[i + 1] = rlpTxn[i];\\n        }\\n\\n        return txn;\\n    }\\n\\n    function encodeRLP(EIP1559Request memory txStruct) internal pure returns (bytes memory) {\\n        bytes[] memory items = new bytes[](9);\\n\\n        items[0] = RLPWriter.writeUint(txStruct.chainId);\\n        items[1] = RLPWriter.writeUint(txStruct.nonce);\\n        items[2] = RLPWriter.writeUint(txStruct.maxPriorityFeePerGas);\\n        items[3] = RLPWriter.writeUint(txStruct.maxFeePerGas);\\n        items[4] = RLPWriter.writeUint(txStruct.gas);\\n\\n        if (txStruct.to == address(0)) {\\n            items[5] = RLPWriter.writeBytes(bytes(\\\"\\\"));\\n        } else {\\n            items[5] = RLPWriter.writeAddress(txStruct.to);\\n        }\\n\\n        items[6] = RLPWriter.writeUint(txStruct.value);\\n        items[7] = RLPWriter.writeBytes(txStruct.data);\\n\\n        if (txStruct.accessList.length == 0) {\\n            items[8] = hex\\\"c0\\\"; // Empty list encoding\\n        } else {\\n            items[8] = RLPWriter.writeBytes(txStruct.accessList);\\n        }\\n\\n        bytes memory rlpTxn = RLPWriter.writeList(items);\\n\\n        bytes memory txn = new bytes(1 + rlpTxn.length);\\n        txn[0] = 0x02;\\n\\n        for (uint256 i = 0; i < rlpTxn.length; ++i) {\\n            txn[i + 1] = rlpTxn[i];\\n        }\\n\\n        return txn;\\n    }\\n\\n    function decodeRLP_EIP155(bytes memory rlp) internal pure returns (EIP155 memory) {\\n        EIP155 memory txStruct;\\n\\n        RLPReader.RLPItem[] memory ls = rlp.toRlpItem().toList();\\n        require(ls.length == 9, \\\"invalid transaction\\\");\\n\\n        txStruct.nonce = uint64(ls[0].toUint());\\n        txStruct.gasPrice = uint64(ls[1].toUint());\\n        txStruct.gas = uint64(ls[2].toUint());\\n\\n        if (ls[3].toRlpBytes().length == 1) {\\n            txStruct.to = address(0);\\n        } else {\\n            txStruct.to = ls[3].toAddress();\\n        }\\n\\n        txStruct.value = uint64(ls[4].toUint());\\n        txStruct.data = ls[5].toBytes();\\n        txStruct.v = uint64(ls[6].toUint());\\n        txStruct.r = bytesToBytes32(ls[7].toBytes());\\n        txStruct.s = bytesToBytes32(ls[8].toBytes());\\n\\n        return txStruct;\\n    }\\n\\n    function decodeRLP_EIP155Request(bytes memory rlp) internal pure returns (EIP155Request memory) {\\n        EIP155Request memory txStruct;\\n\\n        RLPReader.RLPItem[] memory ls = rlp.toRlpItem().toList();\\n        require(ls.length == 9, \\\"invalid transaction\\\");\\n\\n        txStruct.nonce = ls[0].toUint();\\n        txStruct.gasPrice = ls[1].toUint();\\n        txStruct.gas = ls[2].toUint();\\n\\n        if (ls[3].toRlpBytes().length == 1) {\\n            txStruct.to = address(0);\\n        } else {\\n            txStruct.to = ls[3].toAddress();\\n        }\\n\\n        txStruct.value = ls[4].toUint();\\n        txStruct.data = ls[5].toBytes();\\n        txStruct.chainId = uint64(ls[6].toUint());\\n\\n        return txStruct;\\n    }\\n\\n    function decodeRLP_EIP1559(bytes memory rlp) internal pure returns (EIP1559 memory) {\\n        EIP1559 memory txStruct;\\n\\n        bytes memory rlpWithoutPrefix = new bytes(rlp.length - 1);\\n\\n        for (uint256 i = 0; i < rlp.length - 1; ++i) {\\n            rlpWithoutPrefix[i] = rlp[i + 1];\\n        }\\n\\n        RLPReader.RLPItem[] memory ls = rlpWithoutPrefix.toRlpItem().toList();\\n        require(ls.length == 12, \\\"invalid transaction\\\");\\n\\n        txStruct.chainId = uint64(ls[0].toUint());\\n        txStruct.nonce = uint64(ls[1].toUint());\\n        txStruct.maxPriorityFeePerGas = uint64(ls[2].toUint());\\n        txStruct.maxFeePerGas = uint64(ls[3].toUint());\\n        txStruct.gas = uint64(ls[4].toUint());\\n\\n        if (ls[5].toRlpBytes().length == 1) {\\n            txStruct.to = address(0);\\n        } else {\\n            txStruct.to = ls[5].toAddress();\\n        }\\n\\n        txStruct.value = uint64(ls[6].toUint());\\n        txStruct.data = ls[7].toBytes();\\n        txStruct.accessList = ls[8].toBytes();\\n        txStruct.v = uint64(ls[9].toUint());\\n        txStruct.r = bytesToBytes32(ls[10].toBytes());\\n        txStruct.s = bytesToBytes32(ls[11].toBytes());\\n\\n        return txStruct;\\n    }\\n\\n    function decodeRLP_EIP1559Request(bytes memory rlp) internal pure returns (EIP1559Request memory) {\\n        EIP1559Request memory txStruct;\\n\\n        bytes memory rlpWithoutPrefix = new bytes(rlp.length - 1);\\n\\n        for (uint256 i = 0; i < rlp.length - 1; ++i) {\\n            rlpWithoutPrefix[i] = rlp[i + 1];\\n        }\\n\\n        RLPReader.RLPItem[] memory ls = rlpWithoutPrefix.toRlpItem().toList();\\n        require(ls.length == 8, \\\"invalid transaction\\\");\\n\\n        txStruct.chainId = uint64(ls[0].toUint());\\n        txStruct.nonce = uint64(ls[1].toUint());\\n        txStruct.maxPriorityFeePerGas = uint64(ls[2].toUint());\\n        txStruct.maxFeePerGas = uint64(ls[3].toUint());\\n        txStruct.gas = uint64(ls[4].toUint());\\n\\n        if (ls[5].toRlpBytes().length == 1) {\\n            txStruct.to = address(0);\\n        } else {\\n            txStruct.to = ls[5].toAddress();\\n        }\\n\\n        txStruct.value = uint64(ls[6].toUint());\\n        txStruct.data = ls[7].toBytes();\\n\\n        return txStruct;\\n    }\\n\\n    function bytesToBytes32(bytes memory inBytes) internal pure returns (bytes32 out) {\\n        require(inBytes.length == 32, \\\"bytesToBytes32: invalid input length\\\");\\n        assembly {\\n            out := mload(add(inBytes, 32))\\n        }\\n    }\\n\\n    function signTxn(Transactions.EIP1559Request memory request, string memory signingKey)\\n        internal\\n        returns (Transactions.EIP1559 memory response)\\n    {\\n        bytes memory rlp = Transactions.encodeRLP(request);\\n        bytes memory hash = abi.encodePacked(keccak256(rlp));\\n        bytes memory signature = Suave.signMessage(hash, Suave.CryptoSignature.SECP256, signingKey);\\n        (uint8 v, bytes32 r, bytes32 s) = decodeSignature(signature);\\n\\n        response.to = request.to;\\n        response.gas = request.gas;\\n        response.maxFeePerGas = request.maxFeePerGas;\\n        response.maxPriorityFeePerGas = request.maxPriorityFeePerGas;\\n        response.value = request.value;\\n        response.nonce = request.nonce;\\n        response.data = request.data;\\n        response.chainId = request.chainId;\\n        response.accessList = request.accessList;\\n        response.v = v;\\n        response.r = r;\\n        response.s = s;\\n\\n        return response;\\n    }\\n\\n    function signTxn(Transactions.EIP155Request memory request, string memory signingKey)\\n        internal\\n        returns (Transactions.EIP155 memory response)\\n    {\\n        bytes memory rlp = Transactions.encodeRLP(request);\\n        bytes memory hash = abi.encodePacked(keccak256(rlp));\\n        bytes memory signature = Suave.signMessage(hash, Suave.CryptoSignature.SECP256, signingKey);\\n\\n        // TODO: check overflow\\n        uint64 chainIdMul = uint64(request.chainId) * 2;\\n        (uint8 v, bytes32 r, bytes32 s) = decodeSignature(signature);\\n\\n        uint64 v64 = uint64(v) + 35;\\n        v64 += chainIdMul;\\n\\n        response.to = request.to;\\n        response.gas = request.gas;\\n        response.gasPrice = request.gasPrice;\\n        response.value = request.value;\\n        response.nonce = request.nonce;\\n        response.data = request.data;\\n        response.chainId = request.chainId;\\n        response.v = v64;\\n        response.r = r;\\n        response.s = s;\\n\\n        return response;\\n    }\\n\\n    function decodeSignature(bytes memory signature) public pure returns (uint8 v, bytes32 r, bytes32 s) {\\n        assembly {\\n            r := mload(add(signature, 0x20))\\n            s := mload(add(signature, 0x40))\\n            v := byte(0, mload(add(signature, 0x60)))\\n        }\\n    }\\n}\",\"keccak256\":\"0x89fc7ac3af9f379b723cd0647dbbbc916d28adca2ad4261f2c11febc661b9d84\",\"license\":\"Unlicense\"},\"contracts/oracle/BinanceOracle.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// Author: Miha Lotric (halo3mic)\\n\\npragma solidity ^0.8.13;\\n\\nimport { AnyBundleContract, Suave } from \\\"../standard_peekers/bids.sol\\\";\\nimport { SuaveContract } from \\\"../blockad/lib/SuaveContract.sol\\\";\\nimport \\\"solady/src/utils/JSONParserLib.sol\\\";\\nimport \\\"solady/src/utils/LibString.sol\\\";\\nimport \\\"../libraries/Transactions.sol\\\";\\nimport \\\"../libraries/Bundle.sol\\\";\\n\\n// todo: network agnostic\\ncontract BinanceOracle is SuaveContract {\\n    using JSONParserLib for *;\\n\\n    uint public constant HOLESKY_CHAINID = 17000;\\n    string public constant HOLESKY_CHAINID_STR = \\\"0x4268\\\";\\n    uint8 public constant DECIMALS = 4;\\n    string public constant S_NAMESPACE = \\\"oracle:v0:pksecret\\\";\\n    string public constant HOLESKY_RPC = \\\"holesky\\\";\\n    string public constant URL_PARTIAL = \\\"https://data-api.binance.vision/api/v3/ticker/price?symbol=\\\";\\n    string public constant HOLESKY_BUNDLE_ENDPOINT = \\\"https://relay-holesky.flashbots.net\\\";\\n    \\n    bool public isInitialized;\\n    Suave.DataId public pkBidId;\\n    address public controller;\\n    address public settlementContract;\\n\\n    event PriceSubmission(string ticker, uint price);\\n    event RpcResponse(bytes response);\\n\\n    // \\u26d3\\ufe0f EVM Methods\\n\\n    function confidentialConstructorCallback(\\n        Suave.DataId _pkBidId, \\n        address pkAddress\\n    ) public {\\n        crequire(!isInitialized, \\\"Already initialized\\\");\\n        pkBidId = _pkBidId;\\n        controller = pkAddress;\\n        isInitialized = true;\\n    }\\n\\n    function registerCallback(address _settlementContract, bytes memory rpcResponse) public {\\n        require(settlementContract == address(0), \\\"Already registered\\\");\\n        settlementContract = _settlementContract;\\n        emit RpcResponse(rpcResponse);\\n    }\\n\\n    // ! Warning: This method is not restricted and emitted events should not be relied upon\\n    function queryAndSubmitCallback(\\n        string memory ticker, \\n        uint price, \\n        bytes memory rpcResponse\\n    ) public {\\n        emit PriceSubmission(ticker, price);\\n        emit RpcResponse(rpcResponse);\\n    }\\n\\n    fallback() external payable {\\n        // Needed to accept MEVM calls with no callbacks\\n    }\\n\\n    // \\ud83e\\udd10 MEVM Methods\\n\\n    function confidentialConstructor() external onlyConfidential returns (bytes memory) {\\n        crequire(!isInitialized, \\\"Already initialized\\\");\\n\\n        string memory pk = Suave.privateKeyGen(Suave.CryptoSignature.SECP256);\\n        address pkAddress = getAddressForPk(pk);\\n\\t\\tSuave.DataId bidId = storePK(bytes(pk));\\n\\n        return abi.encodeWithSelector(\\n            this.confidentialConstructorCallback.selector, \\n            bidId, \\n            pkAddress\\n        );\\n    }\\n\\n    function registerSettlementContract(\\n        address _settlementContract\\n    ) external onlyConfidential() returns (bytes memory) {\\n        // Allow multiple registrations for the same address (consider the intial tx is not commited to the chain)\\n        require(_settlementContract == settlementContract || settlementContract == address(0), \\\"Already registered\\\");\\n        bytes memory signedTx = createRegisterTx(_settlementContract);\\n        bytes memory rpcResponse = sendRawTx(signedTx);\\n        return abi.encodeWithSelector(this.registerCallback.selector, _settlementContract, rpcResponse);\\n    }\\n\\n    function queryAndSubmit(\\n        string memory ticker,\\n        uint nonce,\\n        uint gasPrice,\\n        uint64 settlementBlockNum,\\n        bool privateSubmission\\n    ) external onlyConfidential returns (bytes memory) {\\n        uint price = queryLatestPrice(ticker);\\n        bytes memory rpcResponse = submitPriceUpdate(\\n            ticker, \\n            price, \\n            nonce, \\n            gasPrice, \\n            settlementBlockNum, \\n            privateSubmission\\n        );\\n        return abi.encodeWithSelector(\\n            this.queryAndSubmitCallback.selector, \\n            ticker, \\n            price, \\n            rpcResponse\\n        );\\n    }\\n\\n    function queryLatestPrice(string memory ticker) public view returns (uint price) {\\n        bytes memory response = doBinanceQuery(ticker);\\n        JSONParserLib.Item memory parsedRes = string(response).parse();\\n        // solhint-disable-next-line\\n        string memory priceStr = string(parsedRes.at('\\\"price\\\"').value());\\n        price = floatToInt(trimStrEdges(priceStr), DECIMALS);\\n    }\\n\\n    function submitPriceUpdate(\\n        string memory ticker,\\n        uint price, \\n        uint nonce,\\n        uint gasPrice,\\n        uint64 settlementBlockNum,\\n        bool privateSubmission\\n    ) internal returns (bytes memory rpcResponse) {\\n        bytes memory signedTx = createPriceUpdateTx(ticker, price, nonce, gasPrice);\\n        if (privateSubmission) {\\n            sendBundle(signedTx, settlementBlockNum);\\n        } else {\\n            rpcResponse = sendRawTx(signedTx);\\n        }\\n    }\\n\\n    function createRegisterTx(address _settlementContract) internal returns (bytes memory txSigned) {\\n        Transactions.EIP155Request memory transaction = Transactions.EIP155Request({\\n            nonce: 0,\\n            gasPrice: 100 gwei,\\n            gas: 100_000,\\n            to: _settlementContract,\\n            value: 0,\\n            data: abi.encodeWithSignature(\\\"register()\\\"),\\n            chainId: HOLESKY_CHAINID\\n        });\\n        bytes memory txRlp = Transactions.encodeRLP(transaction);\\n        string memory pk = retreivePK();\\n        txSigned = Suave.signEthTransaction(txRlp, HOLESKY_CHAINID_STR, pk);\\n    }\\n\\n    function createPriceUpdateTx(\\n        string memory ticker, \\n        uint price, \\n        uint nonce, \\n        uint gasPrice\\n    ) internal returns (bytes memory txSigned)  {\\n        Transactions.EIP155Request memory transaction = Transactions.EIP155Request({\\n            nonce: nonce,\\n            gasPrice: gasPrice,\\n            gas: 100_000,\\n            to: settlementContract,\\n            value: 0,\\n            data: abi.encodeWithSignature(\\\"updatePrice(string,uint256)\\\", ticker, price),\\n            chainId: HOLESKY_CHAINID\\n        });\\n        bytes memory txRlp = Transactions.encodeRLP(transaction);\\n        string memory pk = retreivePK();\\n        txSigned = Suave.signEthTransaction(txRlp, HOLESKY_CHAINID_STR, pk);\\n    }\\n\\n    function sendRawTx(bytes memory txSigned) public view returns (bytes memory) {\\n        /* solhint-disable */\\n        bytes memory body = abi.encodePacked(\\n            '{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"method\\\":\\\"eth_sendRawTransaction\\\",\\\"params\\\":[\\\"', \\n            LibString.toHexString(txSigned), \\n            '\\\"],\\\"id\\\":1}'\\n        );\\n        /* solhint-enable */\\n        Suave.HttpRequest memory request;\\n        request.method = \\\"POST\\\";\\n        request.body = body;\\n        request.headers = new string[](1);\\n        request.headers[0] = \\\"Content-Type: application/json\\\";\\n        request.withFlashbotsSignature = false;\\n        request.url = HOLESKY_RPC;\\n        request.timeout = 10000;\\n        return doHttpRequest(request);\\n    }\\n\\n    function sendBundle(bytes memory txSigned, uint64 settlementBlockNum) internal view {\\n        simulateTx(txSigned);\\n        sendTxViaBundle(txSigned, settlementBlockNum);\\n    }\\n\\n    function simulateTx(bytes memory signedTx) internal view {\\n        // solhint-disable-next-line\\n        bytes memory bundle = abi.encodePacked('{\\\"txs\\\": [\\\"', LibString.toHexString(signedTx), '\\\"]}');\\n        (bool successSim, bytes memory data) = Suave.SIMULATE_BUNDLE.staticcall(abi.encode(bundle));\\n        crequire(successSim,  string(abi.encodePacked(\\\"BundleSimulationFailed: \\\", string(data))));\\n    }\\n\\n    function doBinanceQuery(string memory ticker) internal view returns (bytes memory) {\\n        string[] memory headers = new string[](1);\\n        headers[0] = \\\"Content-Type: application/json\\\";\\n        Suave.HttpRequest memory request = Suave.HttpRequest({\\n            url: string(abi.encodePacked(URL_PARTIAL, ticker)),\\n            method: \\\"GET\\\",\\n            headers: headers,\\n            body: new bytes(0),\\n            withFlashbotsSignature: false,\\n            timeout: 10_000\\n        });\\n        return doHttpRequest(request);\\n    }\\n\\n    function doHttpRequest(Suave.HttpRequest memory request) internal view returns (bytes memory) {\\n        (bool success, bytes memory data) = Suave.DO_HTTPREQUEST.staticcall(abi.encode(request));\\n        crequire(success, string(data));\\n        return abi.decode(data, (bytes));\\n    }\\n\\n    function sendTxViaBundle(bytes memory txSigned, uint64 settlementBlockNum) internal view {\\n        bytes[] memory txns = new bytes[](1);\\n        txns[0] = txSigned;\\n        bytes memory bundleReqParams = bundleRequestParams(txns, settlementBlockNum);\\n        (bool successReq, bytes memory dataReq) = Suave.SUBMIT_BUNDLE_JSON_RPC.staticcall(abi.encode(\\n            HOLESKY_BUNDLE_ENDPOINT, \\n            \\\"eth_sendBundle\\\", \\n            bundleReqParams\\n        ));\\n        crequire(successReq, string(abi.encodePacked(\\\"BundleSubmissionFailed: \\\", string(dataReq))));\\n    }\\n\\n    function bundleRequestParams(bytes[] memory txns, uint blockNumber) internal pure returns (bytes memory) {\\n        // solhint-disable-next-line\\n        bytes memory params = abi.encodePacked('{\\\"blockNumber\\\": \\\"', LibString.toHexString(blockNumber), '\\\", \\\"txs\\\": [');\\n        for (uint256 i = 0; i < txns.length; i++) {\\n            // solhint-disable-next-line\\n            params = abi.encodePacked(params, '\\\"', LibString.toHexString(txns[i]), '\\\"');\\n            if (i < txns.length - 1) {\\n                params = abi.encodePacked(params, \\\",\\\");\\n            } else {\\n                params = abi.encodePacked(params, \\\"]\\\");\\n            }\\n        }\\n        params = abi.encodePacked(params, \\\"}\\\");\\n\\n        return params;\\n    }\\n\\n    function storePK(bytes memory pk) internal returns (Suave.DataId) {\\n\\t\\taddress[] memory peekers = new address[](3);\\n\\t\\tpeekers[0] = address(this);\\n\\t\\tpeekers[1] = Suave.FETCH_DATA_RECORDS;\\n\\t\\tpeekers[2] = Suave.CONFIDENTIAL_RETRIEVE;\\n\\t\\tSuave.DataRecord memory secretBid = Suave.newDataRecord(0, peekers, peekers, S_NAMESPACE);\\n\\t\\tSuave.confidentialStore(secretBid.id, S_NAMESPACE, pk);\\n\\t\\treturn secretBid.id;\\n\\t}\\n\\n    function retreivePK() internal returns (string memory) {\\n        bytes memory pkBytes =  Suave.confidentialRetrieve(pkBidId, S_NAMESPACE);\\n        return string(pkBytes);\\n    }\\n\\n}\\n\\n// \\ud83d\\udd27 Utils\\n\\nfunction floatToInt(string memory floatString, uint8 decimals) pure returns (uint) {\\n    bytes memory stringBytes = bytes(floatString);\\n    uint dotPosition;\\n    \\n    // Find the position of the dot\\n    for (uint i = 0; i < stringBytes.length; i++) {\\n        if (stringBytes[i] == 0x2E) {\\n            dotPosition = i;\\n            break;\\n        }\\n    }\\n    \\n    uint integerPart = 0;\\n    uint decimalPart = 0;\\n    uint tenPower = 1;\\n    \\n    // Convert integer part\\n    for (uint i = dotPosition; i > 0; i--) {\\n        integerPart += (uint8(stringBytes[i - 1]) - 48) * tenPower;\\n        tenPower *= 10;\\n    }\\n    // Reset power of ten\\n    tenPower = 1;\\n    // Convert decimal part\\n    for (uint i = dotPosition+decimals; i > dotPosition; i--) {\\n        decimalPart += (uint8(stringBytes[i]) - 48) * tenPower;\\n        tenPower *= 10;\\n    }\\n    // Combine integer and decimal parts\\n    return integerPart * (10**decimals) + decimalPart;\\n}\\n\\nfunction trimStrEdges(string memory _input) pure returns (string memory) {\\n    bytes memory input = bytes(_input);\\n    require(input.length > 2, \\\"Input too short\\\");\\n\\n    uint newLength = input.length - 2;\\n    bytes memory result = new bytes(newLength);\\n\\n    assembly {\\n        let inputPtr := add(input, 0x21)\\n        let resultPtr := add(result, 0x20)\\n        let length := mload(input)\\n        mstore(resultPtr, mload(inputPtr))\\n        mstore(result, newLength)\\n    }\\n    return string(result);\\n}\\n\\nfunction getAddressForPk(string memory pk) returns (address) {\\n    bytes32 digest = keccak256(abi.encode(\\\"yo\\\"));\\n    bytes memory sig = Suave.signMessage(abi.encodePacked(digest), Suave.CryptoSignature.SECP256, pk);\\n    return recoverSigner(digest, sig);\\n}\\n\\nfunction recoverSigner(bytes32 _ethSignedMessageHash, bytes memory _signature) pure returns (address) {\\n    (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);\\n    return ecrecover(_ethSignedMessageHash, v, r, s);\\n}\\n\\nfunction splitSignature(bytes memory sig) pure returns (bytes32 r, bytes32 s, uint8 v) {\\n    require(sig.length == 65, \\\"invalid signature length\\\");\\n    assembly {\\n        r := mload(add(sig, 32))\\n        s := mload(add(sig, 64))\\n        v := byte(0, mload(add(sig, 96)))\\n    }\\n    if (v < 27) {\\n        v += 27;\\n    }\\n}\",\"keccak256\":\"0x11734b37aa42b40a59399eba97c14cc6b56c96ddabbd2cfb93be73f0bb198538\",\"license\":\"MIT\"},\"contracts/standard_peekers/bids.sol\":{\"content\":\"pragma solidity ^0.8.8;\\n\\nimport \\\"../libraries/Suave.sol\\\";\\n\\ncontract AnyBundleContract {\\n    event DataRecordEvent(Suave.DataId dataId, uint64 decryptionCondition, address[] allowedPeekers);\\n\\n    function fetchConfidentialBundleData() public returns (bytes memory) {\\n        require(Suave.isConfidential());\\n\\n        bytes memory confidentialInputs = Suave.confidentialInputs();\\n        return abi.decode(confidentialInputs, (bytes));\\n    }\\n\\n    function emitDataRecord(Suave.DataRecord calldata dataRecord) public {\\n        emit DataRecordEvent(dataRecord.id, dataRecord.decryptionCondition, dataRecord.allowedPeekers);\\n    }\\n}\\n\\ncontract BundleContract is AnyBundleContract {\\n    function newBundle(\\n        uint64 decryptionCondition,\\n        address[] memory dataAllowedPeekers,\\n        address[] memory dataAllowedStores\\n    ) external payable returns (bytes memory) {\\n        require(Suave.isConfidential());\\n\\n        bytes memory bundleData = this.fetchConfidentialBundleData();\\n\\n        uint64 egp = Suave.simulateBundle(bundleData);\\n\\n        Suave.DataRecord memory dataRecord =\\n            Suave.newDataRecord(decryptionCondition, dataAllowedPeekers, dataAllowedStores, \\\"default:v0:ethBundles\\\");\\n\\n        Suave.confidentialStore(dataRecord.id, \\\"default:v0:ethBundles\\\", bundleData);\\n        Suave.confidentialStore(dataRecord.id, \\\"default:v0:ethBundleSimResults\\\", abi.encode(egp));\\n\\n        return emitAndReturn(dataRecord, bundleData);\\n    }\\n\\n    function emitAndReturn(Suave.DataRecord memory dataRecord, bytes memory) internal virtual returns (bytes memory) {\\n        emit DataRecordEvent(dataRecord.id, dataRecord.decryptionCondition, dataRecord.allowedPeekers);\\n        return bytes.concat(this.emitDataRecord.selector, abi.encode(dataRecord));\\n    }\\n}\\n\\ncontract EthBundleSenderContract is BundleContract {\\n    string[] public builderUrls;\\n\\n    constructor(string[] memory builderUrls_) {\\n        builderUrls = builderUrls_;\\n    }\\n\\n    function emitAndReturn(Suave.DataRecord memory dataRecord, bytes memory bundleData)\\n        internal\\n        virtual\\n        override\\n        returns (bytes memory)\\n    {\\n        for (uint256 i = 0; i < builderUrls.length; i++) {\\n            Suave.submitBundleJsonRPC(builderUrls[i], \\\"eth_sendBundle\\\", bundleData);\\n        }\\n\\n        return BundleContract.emitAndReturn(dataRecord, bundleData);\\n    }\\n}\\n\\ncontract MevShareContract is AnyBundleContract {\\n    event HintEvent(Suave.DataId dataId, bytes hint);\\n\\n    event MatchEvent(Suave.DataId matchDataId, bytes matchHint);\\n\\n    function newTransaction(\\n        uint64 decryptionCondition,\\n        address[] memory dataAllowedPeekers,\\n        address[] memory dataAllowedStores\\n    ) external payable returns (bytes memory) {\\n        // 0. check confidential execution\\n        require(Suave.isConfidential());\\n\\n        // 1. fetch bundle data\\n        bytes memory bundleData = this.fetchConfidentialBundleData();\\n\\n        // 2. sim bundle\\n        uint64 egp = Suave.simulateBundle(bundleData);\\n\\n        // 3. extract hint\\n        bytes memory hint = Suave.extractHint(bundleData);\\n\\n        // // 4. store bundle and sim results\\n        Suave.DataRecord memory dataRecord = Suave.newDataRecord(\\n            decryptionCondition, dataAllowedPeekers, dataAllowedStores, \\\"mevshare:v0:unmatchedBundles\\\"\\n        );\\n        Suave.confidentialStore(dataRecord.id, \\\"mevshare:v0:ethBundles\\\", bundleData);\\n        Suave.confidentialStore(dataRecord.id, \\\"mevshare:v0:ethBundleSimResults\\\", abi.encode(egp));\\n        emit DataRecordEvent(dataRecord.id, dataRecord.decryptionCondition, dataRecord.allowedPeekers);\\n        emit HintEvent(dataRecord.id, hint);\\n\\n        // // 5. return \\\"callback\\\" to emit hint onchain\\n        return bytes.concat(this.emitDataRecordAndHint.selector, abi.encode(dataRecord, hint));\\n    }\\n\\n    function emitDataRecordAndHint(Suave.DataRecord calldata dataRecord, bytes memory hint) public {\\n        emit DataRecordEvent(dataRecord.id, dataRecord.decryptionCondition, dataRecord.allowedPeekers);\\n        emit HintEvent(dataRecord.id, hint);\\n    }\\n\\n    function newMatch(\\n        uint64 decryptionCondition,\\n        address[] memory dataAllowedPeekers,\\n        address[] memory dataAllowedStores,\\n        Suave.DataId sharedataId\\n    ) external payable returns (bytes memory) {\\n        // WARNING : this function will copy the original mev share bid\\n        // into a new key with potentially different permsissions\\n\\n        require(Suave.isConfidential());\\n        // 1. fetch confidential data\\n        bytes memory matchBundleData = this.fetchConfidentialBundleData();\\n\\n        // 2. sim match alone for validity\\n        uint64 egp = Suave.simulateBundle(matchBundleData);\\n\\n        // 3. extract hint\\n        bytes memory matchHint = Suave.extractHint(matchBundleData);\\n\\n        Suave.DataRecord memory dataRecord = Suave.newDataRecord(\\n            decryptionCondition, dataAllowedPeekers, dataAllowedStores, \\\"mevshare:v0:matchDataRecords\\\"\\n        );\\n        Suave.confidentialStore(dataRecord.id, \\\"mevshare:v0:ethBundles\\\", matchBundleData);\\n        Suave.confidentialStore(dataRecord.id, \\\"mevshare:v0:ethBundleSimResults\\\", abi.encode(0));\\n\\n        //4. merge data records\\n        Suave.DataId[] memory dataRecords = new Suave.DataId[](2);\\n        dataRecords[0] = sharedataId;\\n        dataRecords[1] = dataRecord.id;\\n        Suave.confidentialStore(dataRecord.id, \\\"mevshare:v0:mergedDataRecords\\\", abi.encode(dataRecords));\\n\\n        return emitMatchDataRecordAndHint(dataRecord, matchHint);\\n    }\\n\\n    function emitMatchDataRecordAndHint(Suave.DataRecord memory dataRecord, bytes memory matchHint)\\n        internal\\n        virtual\\n        returns (bytes memory)\\n    {\\n        emit DataRecordEvent(dataRecord.id, dataRecord.decryptionCondition, dataRecord.allowedPeekers);\\n        emit MatchEvent(dataRecord.id, matchHint);\\n\\n        return bytes.concat(this.emitDataRecord.selector, abi.encode(dataRecord));\\n    }\\n}\\n\\ncontract MevShareBundleSenderContract is MevShareContract {\\n    string[] public builderUrls;\\n\\n    constructor(string[] memory builderUrls_) {\\n        builderUrls = builderUrls_;\\n    }\\n\\n    function emitMatchDataRecordAndHint(Suave.DataRecord memory dataRecord, bytes memory matchHint)\\n        internal\\n        virtual\\n        override\\n        returns (bytes memory)\\n    {\\n        bytes memory bundleData = Suave.fillMevShareBundle(dataRecord.id);\\n        for (uint256 i = 0; i < builderUrls.length; i++) {\\n            Suave.submitBundleJsonRPC(builderUrls[i], \\\"mev_sendBundle\\\", bundleData);\\n        }\\n\\n        return MevShareContract.emitMatchDataRecordAndHint(dataRecord, matchHint);\\n    }\\n}\\n\\n/* Not tested or implemented on the precompile side */\\nstruct EgpRecordPair {\\n    uint64 egp; // in wei, beware overflow\\n    Suave.DataId dataId;\\n}\\n\\ncontract EthBlockContract is AnyBundleContract {\\n    event BuilderBoostBidEvent(Suave.DataId dataId, bytes builderBid);\\n\\n    function idsEqual(Suave.DataId _l, Suave.DataId _r) public pure returns (bool) {\\n        bytes memory l = abi.encodePacked(_l);\\n        bytes memory r = abi.encodePacked(_r);\\n        for (uint256 i = 0; i < l.length; i++) {\\n            if (bytes(l)[i] != r[i]) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    function buildMevShare(Suave.BuildBlockArgs memory blockArgs, uint64 blockHeight) public returns (bytes memory) {\\n        require(Suave.isConfidential());\\n\\n        Suave.DataRecord[] memory allShareMatchDataRecords =\\n            Suave.fetchDataRecords(blockHeight, \\\"mevshare:v0:matchDataRecords\\\");\\n        Suave.DataRecord[] memory allShareUserDataRecords =\\n            Suave.fetchDataRecords(blockHeight, \\\"mevshare:v0:unmatchedBundles\\\");\\n\\n        if (allShareUserDataRecords.length == 0) {\\n            revert Suave.PeekerReverted(address(this), \\\"no data records\\\");\\n        }\\n\\n        Suave.DataRecord[] memory allRecords = new Suave.DataRecord[](allShareUserDataRecords.length);\\n        for (uint256 i = 0; i < allShareUserDataRecords.length; i++) {\\n            // TODO: sort matches by egp first!\\n            Suave.DataRecord memory dataRecordToInsert = allShareUserDataRecords[i]; // will be updated with the best match if any\\n            for (uint256 j = 0; j < allShareMatchDataRecords.length; j++) {\\n                // TODO: should be done once at the start and sorted\\n                Suave.DataId[] memory mergeddataIds = abi.decode(\\n                    Suave.confidentialRetrieve(allShareMatchDataRecords[j].id, \\\"mevshare:v0:mergedDataRecords\\\"),\\n                    (Suave.DataId[])\\n                );\\n                if (idsEqual(mergeddataIds[0], allShareUserDataRecords[i].id)) {\\n                    dataRecordToInsert = allShareMatchDataRecords[j];\\n                    break;\\n                }\\n            }\\n            allRecords[i] = dataRecordToInsert;\\n        }\\n\\n        EgpRecordPair[] memory bidsByEGP = new EgpRecordPair[](allRecords.length);\\n        for (uint256 i = 0; i < allRecords.length; i++) {\\n            bytes memory simResults = Suave.confidentialRetrieve(allRecords[i].id, \\\"mevshare:v0:ethBundleSimResults\\\");\\n            uint64 egp = abi.decode(simResults, (uint64));\\n            bidsByEGP[i] = EgpRecordPair(egp, allRecords[i].id);\\n        }\\n\\n        // Bubble sort, cause why not\\n        uint256 n = bidsByEGP.length;\\n        for (uint256 i = 0; i < n - 1; i++) {\\n            for (uint256 j = i + 1; j < n; j++) {\\n                if (bidsByEGP[i].egp < bidsByEGP[j].egp) {\\n                    EgpRecordPair memory temp = bidsByEGP[i];\\n                    bidsByEGP[i] = bidsByEGP[j];\\n                    bidsByEGP[j] = temp;\\n                }\\n            }\\n        }\\n\\n        Suave.DataId[] memory alldataIds = new Suave.DataId[](allRecords.length);\\n        for (uint256 i = 0; i < bidsByEGP.length; i++) {\\n            alldataIds[i] = bidsByEGP[i].dataId;\\n        }\\n\\n        return buildAndEmit(blockArgs, blockHeight, alldataIds, \\\"mevshare:v0\\\");\\n    }\\n\\n    function buildFromPool(Suave.BuildBlockArgs memory blockArgs, uint64 blockHeight) public returns (bytes memory) {\\n        require(Suave.isConfidential());\\n\\n        Suave.DataRecord[] memory allRecords = Suave.fetchDataRecords(blockHeight, \\\"default:v0:ethBundles\\\");\\n        if (allRecords.length == 0) {\\n            revert Suave.PeekerReverted(address(this), \\\"no data records\\\");\\n        }\\n\\n        EgpRecordPair[] memory bidsByEGP = new EgpRecordPair[](allRecords.length);\\n        for (uint256 i = 0; i < allRecords.length; i++) {\\n            bytes memory simResults = Suave.confidentialRetrieve(allRecords[i].id, \\\"default:v0:ethBundleSimResults\\\");\\n            uint64 egp = abi.decode(simResults, (uint64));\\n            bidsByEGP[i] = EgpRecordPair(egp, allRecords[i].id);\\n        }\\n\\n        // Bubble sort, cause why not\\n        uint256 n = bidsByEGP.length;\\n        for (uint256 i = 0; i < n - 1; i++) {\\n            for (uint256 j = i + 1; j < n; j++) {\\n                if (bidsByEGP[i].egp < bidsByEGP[j].egp) {\\n                    EgpRecordPair memory temp = bidsByEGP[i];\\n                    bidsByEGP[i] = bidsByEGP[j];\\n                    bidsByEGP[j] = temp;\\n                }\\n            }\\n        }\\n\\n        Suave.DataId[] memory alldataIds = new Suave.DataId[](allRecords.length);\\n        for (uint256 i = 0; i < bidsByEGP.length; i++) {\\n            alldataIds[i] = bidsByEGP[i].dataId;\\n        }\\n\\n        return buildAndEmit(blockArgs, blockHeight, alldataIds, \\\"\\\");\\n    }\\n\\n    function buildAndEmit(\\n        Suave.BuildBlockArgs memory blockArgs,\\n        uint64 blockHeight,\\n        Suave.DataId[] memory records,\\n        string memory relayUrl\\n    ) public virtual returns (bytes memory) {\\n        require(Suave.isConfidential());\\n\\n        (Suave.DataRecord memory blockBid, bytes memory builderBid) =\\n            this.doBuild(blockArgs, blockHeight, records, relayUrl);\\n\\n        emit BuilderBoostBidEvent(blockBid.id, builderBid);\\n        emit DataRecordEvent(blockBid.id, blockBid.decryptionCondition, blockBid.allowedPeekers);\\n        return bytes.concat(this.emitBuilderBidAndBid.selector, abi.encode(blockBid, builderBid));\\n    }\\n\\n    function doBuild(\\n        Suave.BuildBlockArgs memory blockArgs,\\n        uint64 blockHeight,\\n        Suave.DataId[] memory records,\\n        string memory relayUrl\\n    ) public returns (Suave.DataRecord memory, bytes memory) {\\n        address[] memory allowedPeekers = new address[](2);\\n        allowedPeekers[0] = address(this);\\n        allowedPeekers[1] = Suave.BUILD_ETH_BLOCK;\\n\\n        Suave.DataRecord memory blockBid =\\n            Suave.newDataRecord(blockHeight, allowedPeekers, allowedPeekers, \\\"default:v0:mergedDataRecords\\\");\\n        Suave.confidentialStore(blockBid.id, \\\"default:v0:mergedDataRecords\\\", abi.encode(records));\\n\\n        // todo: specify the builder - mainnet/holesky\\n        (bytes memory builderBid, bytes memory payload) = Suave.buildEthBlock(blockArgs, blockBid.id, relayUrl);\\n        Suave.confidentialStore(blockBid.id, \\\"default:v0:builderPayload\\\", payload); // only through this.unlock\\n\\n        return (blockBid, builderBid);\\n    }\\n\\n    function emitBuilderBidAndBid(Suave.DataRecord memory dataRecord, bytes memory builderBid)\\n        public\\n        returns (Suave.DataRecord memory, bytes memory)\\n    {\\n        emit BuilderBoostBidEvent(dataRecord.id, builderBid);\\n        emit DataRecordEvent(dataRecord.id, dataRecord.decryptionCondition, dataRecord.allowedPeekers);\\n        return (dataRecord, builderBid);\\n    }\\n\\n    function unlock(Suave.DataId dataId, bytes memory signedBlindedHeader) public returns (bytes memory) {\\n        require(Suave.isConfidential());\\n\\n        // TODO: verify the header is correct\\n        // TODO: incorporate protocol name\\n        bytes memory payload = Suave.confidentialRetrieve(dataId, \\\"default:v0:builderPayload\\\");\\n        return payload;\\n    }\\n}\\n\\ncontract EthBlockBidSenderContract is EthBlockContract {\\n    string boostRelayUrl;\\n\\n    constructor(string memory boostRelayUrl_) {\\n        boostRelayUrl = boostRelayUrl_;\\n    }\\n\\n    function buildAndEmit(\\n        Suave.BuildBlockArgs memory blockArgs,\\n        uint64 blockHeight,\\n        Suave.DataId[] memory dataRecords,\\n        string memory namespace\\n    ) public virtual override returns (bytes memory) {\\n        require(Suave.isConfidential());\\n\\n        (Suave.DataRecord memory blockDataRecord, bytes memory builderBid) =\\n            this.doBuild(blockArgs, blockHeight, dataRecords, namespace);\\n        Suave.submitEthBlockToRelay(boostRelayUrl, builderBid);\\n\\n        emit DataRecordEvent(blockDataRecord.id, blockDataRecord.decryptionCondition, blockDataRecord.allowedPeekers);\\n        return bytes.concat(this.emitDataRecord.selector, abi.encode(blockDataRecord));\\n    }\\n}\\n\",\"keccak256\":\"0x02df5891b0edb36844256712b85fd15bf3b5778204bee20b69d3ce3b51c2d14d\"},\"solady/src/utils/JSONParserLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library for parsing JSONs.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/JSONParserLib.sol)\\nlibrary JSONParserLib {\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The input is invalid.\\n    error ParsingFailed();\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    // There are 6 types of variables in JSON (excluding undefined).\\n\\n    /// @dev For denoting that an item has not been initialized.\\n    /// A item returned from `parse` will never be of an undefined type.\\n    /// Parsing a invalid JSON string will simply revert.\\n    uint8 internal constant TYPE_UNDEFINED = 0;\\n\\n    /// @dev Type representing an array (e.g. `[1,2,3]`).\\n    uint8 internal constant TYPE_ARRAY = 1;\\n\\n    /// @dev Type representing an object (e.g. `{\\\"a\\\":\\\"A\\\",\\\"b\\\":\\\"B\\\"}`).\\n    uint8 internal constant TYPE_OBJECT = 2;\\n\\n    /// @dev Type representing a number (e.g. `-1.23e+21`).\\n    uint8 internal constant TYPE_NUMBER = 3;\\n\\n    /// @dev Type representing a string (e.g. `\\\"hello\\\"`).\\n    uint8 internal constant TYPE_STRING = 4;\\n\\n    /// @dev Type representing a boolean (i.e. `true` or `false`).\\n    uint8 internal constant TYPE_BOOLEAN = 5;\\n\\n    /// @dev Type representing null (i.e. `null`).\\n    uint8 internal constant TYPE_NULL = 6;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                          STRUCTS                           */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev A pointer to a parsed JSON node.\\n    struct Item {\\n        // Do NOT modify the `_data` directly.\\n        uint256 _data;\\n    }\\n\\n    // Private constants for packing `_data`.\\n\\n    uint256 private constant _BITPOS_STRING = 32 * 7 - 8;\\n    uint256 private constant _BITPOS_KEY_LENGTH = 32 * 6 - 8;\\n    uint256 private constant _BITPOS_KEY = 32 * 5 - 8;\\n    uint256 private constant _BITPOS_VALUE_LENGTH = 32 * 4 - 8;\\n    uint256 private constant _BITPOS_VALUE = 32 * 3 - 8;\\n    uint256 private constant _BITPOS_CHILD = 32 * 2 - 8;\\n    uint256 private constant _BITPOS_SIBLING_OR_PARENT = 32 * 1 - 8;\\n    uint256 private constant _BITMASK_POINTER = 0xffffffff;\\n    uint256 private constant _BITMASK_TYPE = 7;\\n    uint256 private constant _KEY_INITED = 1 << 3;\\n    uint256 private constant _VALUE_INITED = 1 << 4;\\n    uint256 private constant _CHILDREN_INITED = 1 << 5;\\n    uint256 private constant _PARENT_IS_ARRAY = 1 << 6;\\n    uint256 private constant _PARENT_IS_OBJECT = 1 << 7;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                   JSON PARSING OPERATION                   */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Parses the JSON string `s`, and returns the root.\\n    /// Reverts if `s` is not a valid JSON as specified in RFC 8259.\\n    /// Object items WILL simply contain all their children, inclusive of repeated keys,\\n    /// in the same order which they appear in the JSON string.\\n    ///\\n    /// Note: For efficiency, this function WILL NOT make a copy of `s`.\\n    /// The parsed tree WILL contain offsets to `s`.\\n    /// Do NOT pass in a string that WILL be modified later on.\\n    function parse(string memory s) internal pure returns (Item memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x40, result) // We will use our own allocation instead.\\n        }\\n        bytes32 r = _query(_toInput(s), 255);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := r\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                    JSON ITEM OPERATIONS                    */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    // Note:\\n    // - An item is a node in the JSON tree.\\n    // - The value of a string item WILL be double-quoted, JSON encoded.\\n    // - We make a distinction between `index` and `key`.\\n    //   - Items in arrays are located by `index` (uint256).\\n    //   - Items in objects are located by `key` (string).\\n    // - Keys are always strings, double-quoted, JSON encoded.\\n    //\\n    // These design choices are made to balance between efficiency and ease-of-use.\\n\\n    /// @dev Returns the string value of the item.\\n    /// This is its exact string representation in the original JSON string.\\n    /// The returned string WILL have leading and trailing whitespace trimmed.\\n    /// All inner whitespace WILL be preserved, exactly as it is in the original JSON string.\\n    /// If the item's type is string, the returned string WILL be double-quoted, JSON encoded.\\n    ///\\n    /// Note: This function lazily instantiates and caches the returned string.\\n    /// Do NOT modify the returned string.\\n    function value(Item memory item) internal pure returns (string memory result) {\\n        bytes32 r = _query(_toInput(item), 0);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := r\\n        }\\n    }\\n\\n    /// @dev Returns the index of the item in the array.\\n    /// It the item's parent is not an array, returns 0.\\n    function index(Item memory item) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if and(mload(item), _PARENT_IS_ARRAY) {\\n                result := and(_BITMASK_POINTER, shr(_BITPOS_KEY, mload(item)))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the key of the item in the object.\\n    /// It the item's parent is not an object, returns an empty string.\\n    /// The returned string WILL be double-quoted, JSON encoded.\\n    ///\\n    /// Note: This function lazily instantiates and caches the returned string.\\n    /// Do NOT modify the returned string.\\n    function key(Item memory item) internal pure returns (string memory result) {\\n        if (item._data & _PARENT_IS_OBJECT != 0) {\\n            bytes32 r = _query(_toInput(item), 1);\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                result := r\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the key of the item in the object.\\n    /// It the item is neither an array nor object, returns an empty array.\\n    ///\\n    /// Note: This function lazily instantiates and caches the returned array.\\n    /// Do NOT modify the returned array.\\n    function children(Item memory item) internal pure returns (Item[] memory result) {\\n        bytes32 r = _query(_toInput(item), 3);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := r\\n        }\\n    }\\n\\n    /// @dev Returns the number of children.\\n    /// It the item is neither an array nor object, returns zero.\\n    function size(Item memory item) internal pure returns (uint256 result) {\\n        bytes32 r = _query(_toInput(item), 3);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(r)\\n        }\\n    }\\n\\n    /// @dev Returns the item at index `i` for (array).\\n    /// If `item` is not an array, the result's type WILL be undefined.\\n    /// If there is no item with the index, the result's type WILL be undefined.\\n    function at(Item memory item, uint256 i) internal pure returns (Item memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x40, result) // Free the default allocation. We'll allocate manually.\\n        }\\n        bytes32 r = _query(_toInput(item), 3);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(add(add(r, 0x20), shl(5, i)))\\n            if iszero(and(lt(i, mload(r)), eq(and(mload(item), _BITMASK_TYPE), TYPE_ARRAY))) {\\n                result := 0x60 // Reset to the zero pointer.\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the item at key `k` for (object).\\n    /// If `item` is not an object, the result's type WILL be undefined.\\n    /// The key MUST be double-quoted, JSON encoded. This is for efficiency reasons.\\n    /// - Correct : `item.at('\\\"k\\\"')`.\\n    /// - Wrong   : `item.at(\\\"k\\\")`.\\n    /// For duplicated keys, the last item with the key WILL be returned.\\n    /// If there is no item with the key, the result's type WILL be undefined.\\n    function at(Item memory item, string memory k) internal pure returns (Item memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x40, result) // Free the default allocation. We'll allocate manually.\\n            result := 0x60 // Initialize to the zero pointer.\\n        }\\n        if (isObject(item)) {\\n            bytes32 kHash = keccak256(bytes(k));\\n            Item[] memory r = children(item);\\n            // We'll just do a linear search. The alternatives are very bloated.\\n            for (uint256 i = r.length << 5; i != 0;) {\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    item := mload(add(r, i))\\n                    i := sub(i, 0x20)\\n                }\\n                if (keccak256(bytes(key(item))) != kHash) continue;\\n                result = item;\\n                break;\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the item's type.\\n    function getType(Item memory item) internal pure returns (uint8 result) {\\n        result = uint8(item._data & _BITMASK_TYPE);\\n    }\\n\\n    /// Note: All types are mutually exclusive.\\n\\n    /// @dev Returns whether the item is of type undefined.\\n    function isUndefined(Item memory item) internal pure returns (bool result) {\\n        result = item._data & _BITMASK_TYPE == TYPE_UNDEFINED;\\n    }\\n\\n    /// @dev Returns whether the item is of type array.\\n    function isArray(Item memory item) internal pure returns (bool result) {\\n        result = item._data & _BITMASK_TYPE == TYPE_ARRAY;\\n    }\\n\\n    /// @dev Returns whether the item is of type object.\\n    function isObject(Item memory item) internal pure returns (bool result) {\\n        result = item._data & _BITMASK_TYPE == TYPE_OBJECT;\\n    }\\n\\n    /// @dev Returns whether the item is of type number.\\n    function isNumber(Item memory item) internal pure returns (bool result) {\\n        result = item._data & _BITMASK_TYPE == TYPE_NUMBER;\\n    }\\n\\n    /// @dev Returns whether the item is of type string.\\n    function isString(Item memory item) internal pure returns (bool result) {\\n        result = item._data & _BITMASK_TYPE == TYPE_STRING;\\n    }\\n\\n    /// @dev Returns whether the item is of type boolean.\\n    function isBoolean(Item memory item) internal pure returns (bool result) {\\n        result = item._data & _BITMASK_TYPE == TYPE_BOOLEAN;\\n    }\\n\\n    /// @dev Returns whether the item is of type null.\\n    function isNull(Item memory item) internal pure returns (bool result) {\\n        result = item._data & _BITMASK_TYPE == TYPE_NULL;\\n    }\\n\\n    /// @dev Returns the item's parent.\\n    /// If the item does not have a parent, the result's type will be undefined.\\n    function parent(Item memory item) internal pure returns (Item memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x40, result) // Free the default allocation. We've already allocated.\\n            result := and(shr(_BITPOS_SIBLING_OR_PARENT, mload(item)), _BITMASK_POINTER)\\n            if iszero(result) { result := 0x60 } // Reset to the zero pointer.\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                     UTILITY FUNCTIONS                      */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Parses an unsigned integer from a string (in decimal, i.e. base 10).\\n    /// Reverts if `s` is not a valid uint256 string matching the RegEx `^[0-9]+$`,\\n    /// or if the parsed number is too big for a uint256.\\n    function parseUint(string memory s) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let n := mload(s)\\n            let preMulOverflowThres := div(not(0), 10)\\n            for { let i := 0 } 1 {} {\\n                i := add(i, 1)\\n                let digit := sub(and(mload(add(s, i)), 0xff), 48)\\n                let mulOverflowed := gt(result, preMulOverflowThres)\\n                let product := mul(10, result)\\n                result := add(product, digit)\\n                n := mul(n, iszero(or(or(mulOverflowed, lt(result, product)), gt(digit, 9))))\\n                if iszero(lt(i, n)) { break }\\n            }\\n            if iszero(n) {\\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Parses a signed integer from a string (in decimal, i.e. base 10).\\n    /// Reverts if `s` is not a valid int256 string matching the RegEx `^[+-]?[0-9]+$`,\\n    /// or if the parsed number cannot fit within `[-2**255 .. 2**255 - 1]`.\\n    function parseInt(string memory s) internal pure returns (int256 result) {\\n        uint256 n = bytes(s).length;\\n        uint256 sign;\\n        uint256 isNegative;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if n {\\n                let c := and(mload(add(s, 1)), 0xff)\\n                isNegative := eq(c, 45)\\n                if or(eq(c, 43), isNegative) {\\n                    sign := c\\n                    s := add(s, 1)\\n                    mstore(s, sub(n, 1))\\n                }\\n                if iszero(or(sign, lt(sub(c, 48), 10))) { s := 0x60 }\\n            }\\n        }\\n        uint256 x = parseUint(s);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(lt(x, add(shl(255, 1), isNegative))) {\\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if sign {\\n                mstore(s, sign)\\n                s := sub(s, 1)\\n                mstore(s, n)\\n            }\\n            result := xor(x, mul(xor(x, add(not(x), 1)), isNegative))\\n        }\\n    }\\n\\n    /// @dev Parses an unsigned integer from a string (in hexadecimal, i.e. base 16).\\n    /// Reverts if `s` is not a valid uint256 hex string matching the RegEx\\n    /// `^(0[xX])?[0-9a-fA-F]+$`, or if the parsed number cannot fit within `[0 .. 2**256 - 1]`.\\n    function parseUintFromHex(string memory s) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let n := mload(s)\\n            // Skip two if starts with '0x' or '0X'.\\n            let i := shl(1, and(eq(0x3078, or(shr(240, mload(add(s, 0x20))), 0x20)), gt(n, 1)))\\n            for {} 1 {} {\\n                i := add(i, 1)\\n                let c :=\\n                    byte(\\n                        and(0x1f, shr(and(mload(add(s, i)), 0xff), 0x3e4088843e41bac000000000000)),\\n                        0x3010a071000000b0104040208000c05090d060e0f\\n                    )\\n                n := mul(n, iszero(or(iszero(c), shr(252, result))))\\n                result := add(shl(4, result), sub(c, 1))\\n                if iszero(lt(i, n)) { break }\\n            }\\n            if iszero(n) {\\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Decodes a JSON encoded string.\\n    /// The string MUST be double-quoted, JSON encoded.\\n    /// Reverts if the string is invalid.\\n    /// As you can see, it's pretty complex for a deceptively simple looking task.\\n    function decodeString(string memory s) internal pure returns (string memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            function fail() {\\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n\\n            function decodeUnicodeEscapeSequence(pIn_, end_) -> _unicode, _pOut {\\n                _pOut := add(pIn_, 4)\\n                let b_ := iszero(gt(_pOut, end_))\\n                let t_ := mload(pIn_) // Load the whole word.\\n                for { let i_ := 0 } iszero(eq(i_, 4)) { i_ := add(i_, 1) } {\\n                    let c_ := sub(byte(i_, t_), 48)\\n                    if iszero(and(shr(c_, 0x7e0000007e03ff), b_)) { fail() } // Not hexadecimal.\\n                    c_ := sub(c_, add(mul(gt(c_, 16), 7), shl(5, gt(c_, 48))))\\n                    _unicode := add(shl(4, _unicode), c_)\\n                }\\n            }\\n\\n            function decodeUnicodeCodePoint(pIn_, end_) -> _unicode, _pOut {\\n                _unicode, _pOut := decodeUnicodeEscapeSequence(pIn_, end_)\\n                if iszero(or(lt(_unicode, 0xd800), gt(_unicode, 0xdbff))) {\\n                    let t_ := mload(_pOut) // Load the whole word.\\n                    end_ := mul(end_, eq(shr(240, t_), 0x5c75)) // Fail if not starting with '\\\\\\\\u'.\\n                    t_, _pOut := decodeUnicodeEscapeSequence(add(_pOut, 2), end_)\\n                    _unicode := add(0x10000, add(shl(10, and(0x3ff, _unicode)), and(0x3ff, t_)))\\n                }\\n            }\\n\\n            function appendCodePointAsUTF8(pIn_, c_) -> _pOut {\\n                if iszero(gt(c_, 0x7f)) {\\n                    mstore8(pIn_, c_)\\n                    _pOut := add(pIn_, 1)\\n                    leave\\n                }\\n                mstore8(0x1f, c_)\\n                mstore8(0x1e, shr(6, c_))\\n                if iszero(gt(c_, 0x7ff)) {\\n                    mstore(pIn_, shl(240, or(0xc080, and(0x1f3f, mload(0x00)))))\\n                    _pOut := add(pIn_, 2)\\n                    leave\\n                }\\n                mstore8(0x1d, shr(12, c_))\\n                if iszero(gt(c_, 0xffff)) {\\n                    mstore(pIn_, shl(232, or(0xe08080, and(0x0f3f3f, mload(0x00)))))\\n                    _pOut := add(pIn_, 3)\\n                    leave\\n                }\\n                mstore8(0x1c, shr(18, c_))\\n                mstore(pIn_, shl(224, or(0xf0808080, and(0x073f3f3f, mload(0x00)))))\\n                _pOut := add(pIn_, shl(2, lt(c_, 0x110000)))\\n            }\\n\\n            function chr(p_) -> _c {\\n                _c := byte(0, mload(p_))\\n            }\\n\\n            let n := mload(s)\\n            let end := add(add(s, n), 0x1f)\\n            if iszero(and(gt(n, 1), eq(0x2222, or(and(0xff00, mload(add(s, 2))), chr(end))))) {\\n                fail() // Fail if not double-quoted.\\n            }\\n            let out := add(mload(0x40), 0x20)\\n            for { let curr := add(s, 0x21) } iszero(eq(curr, end)) {} {\\n                let c := chr(curr)\\n                curr := add(curr, 1)\\n                // Not '\\\\\\\\'.\\n                if iszero(eq(c, 92)) {\\n                    // Not '\\\"'.\\n                    if iszero(eq(c, 34)) {\\n                        mstore8(out, c)\\n                        out := add(out, 1)\\n                        continue\\n                    }\\n                    curr := end\\n                }\\n                if iszero(eq(curr, end)) {\\n                    let escape := chr(curr)\\n                    curr := add(curr, 1)\\n                    // '\\\"', '/', '\\\\\\\\'.\\n                    if and(shr(escape, 0x100000000000800400000000), 1) {\\n                        mstore8(out, escape)\\n                        out := add(out, 1)\\n                        continue\\n                    }\\n                    // 'u'.\\n                    if eq(escape, 117) {\\n                        escape, curr := decodeUnicodeCodePoint(curr, end)\\n                        out := appendCodePointAsUTF8(out, escape)\\n                        continue\\n                    }\\n                    // `{'b':'\\\\b', 'f':'\\\\f', 'n':'\\\\n', 'r':'\\\\r', 't':'\\\\t'}`.\\n                    escape := byte(sub(escape, 85), 0x080000000c000000000000000a0000000d0009)\\n                    if escape {\\n                        mstore8(out, escape)\\n                        out := add(out, 1)\\n                        continue\\n                    }\\n                }\\n                fail()\\n                break\\n            }\\n            mstore(out, 0) // Zeroize the last slot.\\n            result := mload(0x40)\\n            mstore(result, sub(out, add(result, 0x20))) // Store the length.\\n            mstore(0x40, add(out, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                      PRIVATE HELPERS                       */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Performs a query on the input with the given mode.\\n    function _query(bytes32 input, uint256 mode) private pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            function fail() {\\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n\\n            function chr(p_) -> _c {\\n                _c := byte(0, mload(p_))\\n            }\\n\\n            function skipWhitespace(pIn_, end_) -> _pOut {\\n                for { _pOut := pIn_ } 1 { _pOut := add(_pOut, 1) } {\\n                    if iszero(and(shr(chr(_pOut), 0x100002600), 1)) { leave } // Not in ' \\\\n\\\\r\\\\t'.\\n                }\\n            }\\n\\n            function setP(packed_, bitpos_, p_) -> _packed {\\n                // Perform an out-of-gas revert if `p_` exceeds `_BITMASK_POINTER`.\\n                returndatacopy(returndatasize(), returndatasize(), gt(p_, _BITMASK_POINTER))\\n                _packed := or(and(not(shl(bitpos_, _BITMASK_POINTER)), packed_), shl(bitpos_, p_))\\n            }\\n\\n            function getP(packed_, bitpos_) -> _p {\\n                _p := and(_BITMASK_POINTER, shr(bitpos_, packed_))\\n            }\\n\\n            function mallocItem(s_, packed_, pStart_, pCurr_, type_) -> _item {\\n                _item := mload(0x40)\\n                // forgefmt: disable-next-item\\n                packed_ := setP(setP(packed_, _BITPOS_VALUE, sub(pStart_, add(s_, 0x20))),\\n                    _BITPOS_VALUE_LENGTH, sub(pCurr_, pStart_))\\n                mstore(_item, or(packed_, type_))\\n                mstore(0x40, add(_item, 0x20)) // Allocate memory.\\n            }\\n\\n            function parseValue(s_, sibling_, pIn_, end_) -> _item, _pOut {\\n                let packed_ := setP(mload(0x00), _BITPOS_SIBLING_OR_PARENT, sibling_)\\n                _pOut := skipWhitespace(pIn_, end_)\\n                if iszero(lt(_pOut, end_)) { leave }\\n                for { let c_ := chr(_pOut) } 1 {} {\\n                    // If starts with '\\\"'.\\n                    if eq(c_, 34) {\\n                        let pStart_ := _pOut\\n                        _pOut := parseStringSub(s_, packed_, _pOut, end_)\\n                        _item := mallocItem(s_, packed_, pStart_, _pOut, TYPE_STRING)\\n                        break\\n                    }\\n                    // If starts with '['.\\n                    if eq(c_, 91) {\\n                        _item, _pOut := parseArray(s_, packed_, _pOut, end_)\\n                        break\\n                    }\\n                    // If starts with '{'.\\n                    if eq(c_, 123) {\\n                        _item, _pOut := parseObject(s_, packed_, _pOut, end_)\\n                        break\\n                    }\\n                    // If starts with any in '0123456789-'.\\n                    if and(shr(c_, shl(45, 0x1ff9)), 1) {\\n                        _item, _pOut := parseNumber(s_, packed_, _pOut, end_)\\n                        break\\n                    }\\n                    if iszero(gt(add(_pOut, 4), end_)) {\\n                        let pStart_ := _pOut\\n                        let w_ := shr(224, mload(_pOut))\\n                        // 'true' in hex format.\\n                        if eq(w_, 0x74727565) {\\n                            _pOut := add(_pOut, 4)\\n                            _item := mallocItem(s_, packed_, pStart_, _pOut, TYPE_BOOLEAN)\\n                            break\\n                        }\\n                        // 'null' in hex format.\\n                        if eq(w_, 0x6e756c6c) {\\n                            _pOut := add(_pOut, 4)\\n                            _item := mallocItem(s_, packed_, pStart_, _pOut, TYPE_NULL)\\n                            break\\n                        }\\n                    }\\n                    if iszero(gt(add(_pOut, 5), end_)) {\\n                        let pStart_ := _pOut\\n                        let w_ := shr(216, mload(_pOut))\\n                        // 'false' in hex format.\\n                        if eq(w_, 0x66616c7365) {\\n                            _pOut := add(_pOut, 5)\\n                            _item := mallocItem(s_, packed_, pStart_, _pOut, TYPE_BOOLEAN)\\n                            break\\n                        }\\n                    }\\n                    fail()\\n                    break\\n                }\\n                _pOut := skipWhitespace(_pOut, end_)\\n            }\\n\\n            function parseArray(s_, packed_, pIn_, end_) -> _item, _pOut {\\n                let j_ := 0\\n                for { _pOut := add(pIn_, 1) } 1 { _pOut := add(_pOut, 1) } {\\n                    if iszero(lt(_pOut, end_)) { fail() }\\n                    if iszero(_item) {\\n                        _pOut := skipWhitespace(_pOut, end_)\\n                        if eq(chr(_pOut), 93) { break } // ']'.\\n                    }\\n                    _item, _pOut := parseValue(s_, _item, _pOut, end_)\\n                    if _item {\\n                        // forgefmt: disable-next-item\\n                        mstore(_item, setP(or(_PARENT_IS_ARRAY, mload(_item)),\\n                            _BITPOS_KEY, j_))\\n                        j_ := add(j_, 1)\\n                        let c_ := chr(_pOut)\\n                        if eq(c_, 93) { break } // ']'.\\n                        if eq(c_, 44) { continue } // ','.\\n                    }\\n                    _pOut := end_\\n                }\\n                _pOut := add(_pOut, 1)\\n                packed_ := setP(packed_, _BITPOS_CHILD, _item)\\n                _item := mallocItem(s_, packed_, pIn_, _pOut, TYPE_ARRAY)\\n            }\\n\\n            function parseObject(s_, packed_, pIn_, end_) -> _item, _pOut {\\n                for { _pOut := add(pIn_, 1) } 1 { _pOut := add(_pOut, 1) } {\\n                    if iszero(lt(_pOut, end_)) { fail() }\\n                    if iszero(_item) {\\n                        _pOut := skipWhitespace(_pOut, end_)\\n                        if eq(chr(_pOut), 125) { break } // '}'.\\n                    }\\n                    _pOut := skipWhitespace(_pOut, end_)\\n                    let pKeyStart_ := _pOut\\n                    let pKeyEnd_ := parseStringSub(s_, _item, _pOut, end_)\\n                    _pOut := skipWhitespace(pKeyEnd_, end_)\\n                    // If ':'.\\n                    if eq(chr(_pOut), 58) {\\n                        _item, _pOut := parseValue(s_, _item, add(_pOut, 1), end_)\\n                        if _item {\\n                            // forgefmt: disable-next-item\\n                            mstore(_item, setP(setP(or(_PARENT_IS_OBJECT, mload(_item)),\\n                                _BITPOS_KEY_LENGTH, sub(pKeyEnd_, pKeyStart_)),\\n                                    _BITPOS_KEY, sub(pKeyStart_, add(s_, 0x20))))\\n                            let c_ := chr(_pOut)\\n                            if eq(c_, 125) { break } // '}'.\\n                            if eq(c_, 44) { continue } // ','.\\n                        }\\n                    }\\n                    _pOut := end_\\n                }\\n                _pOut := add(_pOut, 1)\\n                packed_ := setP(packed_, _BITPOS_CHILD, _item)\\n                _item := mallocItem(s_, packed_, pIn_, _pOut, TYPE_OBJECT)\\n            }\\n\\n            function checkStringU(p_, o_) {\\n                // If not in '0123456789abcdefABCDEF', revert.\\n                if iszero(and(shr(sub(chr(add(p_, o_)), 48), 0x7e0000007e03ff), 1)) { fail() }\\n                if iszero(eq(o_, 5)) { checkStringU(p_, add(o_, 1)) }\\n            }\\n\\n            function parseStringSub(s_, packed_, pIn_, end_) -> _pOut {\\n                if iszero(lt(pIn_, end_)) { fail() }\\n                for { _pOut := add(pIn_, 1) } 1 {} {\\n                    let c_ := chr(_pOut)\\n                    if eq(c_, 34) { break } // '\\\"'.\\n                    // Not '\\\\'.\\n                    if iszero(eq(c_, 92)) {\\n                        _pOut := add(_pOut, 1)\\n                        continue\\n                    }\\n                    c_ := chr(add(_pOut, 1))\\n                    // '\\\"', '\\\\', '//', 'b', 'f', 'n', 'r', 't'.\\n                    if and(shr(sub(c_, 34), 0x510110400000000002001), 1) {\\n                        _pOut := add(_pOut, 2)\\n                        continue\\n                    }\\n                    // 'u'.\\n                    if eq(c_, 117) {\\n                        checkStringU(_pOut, 2)\\n                        _pOut := add(_pOut, 6)\\n                        continue\\n                    }\\n                    _pOut := end_\\n                    break\\n                }\\n                if iszero(lt(_pOut, end_)) { fail() }\\n                _pOut := add(_pOut, 1)\\n            }\\n\\n            function skip0To9s(pIn_, end_, atLeastOne_) -> _pOut {\\n                for { _pOut := pIn_ } 1 { _pOut := add(_pOut, 1) } {\\n                    if iszero(lt(sub(chr(_pOut), 48), 10)) { break } // Not '0'..'9'.\\n                }\\n                if and(atLeastOne_, eq(pIn_, _pOut)) { fail() }\\n            }\\n\\n            function parseNumber(s_, packed_, pIn_, end_) -> _item, _pOut {\\n                _pOut := pIn_\\n                if eq(chr(_pOut), 45) { _pOut := add(_pOut, 1) } // '-'.\\n                if iszero(lt(sub(chr(_pOut), 48), 10)) { fail() } // Not '0'..'9'.\\n                let c_ := chr(_pOut)\\n                _pOut := add(_pOut, 1)\\n                if iszero(eq(c_, 48)) { _pOut := skip0To9s(_pOut, end_, 0) } // Not '0'.\\n                if eq(chr(_pOut), 46) { _pOut := skip0To9s(add(_pOut, 1), end_, 1) } // '.'.\\n                let t_ := mload(_pOut)\\n                // 'E', 'e'.\\n                if eq(or(0x20, byte(0, t_)), 101) {\\n                    // forgefmt: disable-next-item\\n                    _pOut := skip0To9s(add(byte(sub(byte(1, t_), 14), 0x010001), // '+', '-'.\\n                        add(_pOut, 1)), end_, 1)\\n                }\\n                _item := mallocItem(s_, packed_, pIn_, _pOut, TYPE_NUMBER)\\n            }\\n\\n            function copyStr(s_, offset_, len_) -> _sCopy {\\n                _sCopy := mload(0x40)\\n                s_ := add(s_, offset_)\\n                let w_ := not(0x1f)\\n                for { let i_ := and(add(len_, 0x1f), w_) } 1 {} {\\n                    mstore(add(_sCopy, i_), mload(add(s_, i_)))\\n                    i_ := add(i_, w_) // `sub(i_, 0x20)`.\\n                    if iszero(i_) { break }\\n                }\\n                mstore(_sCopy, len_) // Copy the length.\\n                mstore(add(add(_sCopy, 0x20), len_), 0) // Zeroize the last slot.\\n                mstore(0x40, add(add(_sCopy, 0x40), len_)) // Allocate memory.\\n            }\\n\\n            function value(item_) -> _value {\\n                let packed_ := mload(item_)\\n                _value := getP(packed_, _BITPOS_VALUE) // The offset in the string.\\n                if iszero(and(_VALUE_INITED, packed_)) {\\n                    let s_ := getP(packed_, _BITPOS_STRING)\\n                    _value := copyStr(s_, _value, getP(packed_, _BITPOS_VALUE_LENGTH))\\n                    packed_ := setP(packed_, _BITPOS_VALUE, _value)\\n                    mstore(s_, or(_VALUE_INITED, packed_))\\n                }\\n            }\\n\\n            function children(item_) -> _arr {\\n                _arr := 0x60 // Initialize to the zero pointer.\\n                let packed_ := mload(item_)\\n                for {} iszero(gt(and(_BITMASK_TYPE, packed_), TYPE_OBJECT)) {} {\\n                    if or(iszero(packed_), iszero(item_)) { break }\\n                    if and(packed_, _CHILDREN_INITED) {\\n                        _arr := getP(packed_, _BITPOS_CHILD)\\n                        break\\n                    }\\n                    _arr := mload(0x40)\\n                    let o_ := add(_arr, 0x20)\\n                    for { let h_ := getP(packed_, _BITPOS_CHILD) } h_ {} {\\n                        mstore(o_, h_)\\n                        let q_ := mload(h_)\\n                        let y_ := getP(q_, _BITPOS_SIBLING_OR_PARENT)\\n                        mstore(h_, setP(q_, _BITPOS_SIBLING_OR_PARENT, item_))\\n                        h_ := y_\\n                        o_ := add(o_, 0x20)\\n                    }\\n                    let w_ := not(0x1f)\\n                    let n_ := add(w_, sub(o_, _arr))\\n                    mstore(_arr, shr(5, n_))\\n                    mstore(0x40, o_) // Allocate memory.\\n                    packed_ := setP(packed_, _BITPOS_CHILD, _arr)\\n                    mstore(item_, or(_CHILDREN_INITED, packed_))\\n                    // Reverse the array.\\n                    if iszero(lt(n_, 0x40)) {\\n                        let lo_ := add(_arr, 0x20)\\n                        let hi_ := add(_arr, n_)\\n                        for {} 1 {} {\\n                            let temp_ := mload(lo_)\\n                            mstore(lo_, mload(hi_))\\n                            mstore(hi_, temp_)\\n                            hi_ := add(hi_, w_)\\n                            lo_ := add(lo_, 0x20)\\n                            if iszero(lt(lo_, hi_)) { break }\\n                        }\\n                    }\\n                    break\\n                }\\n            }\\n\\n            function getStr(item_, bitpos_, bitposLength_, bitmaskInited_) -> _result {\\n                _result := 0x60 // Initialize to the zero pointer.\\n                let packed_ := mload(item_)\\n                if or(iszero(item_), iszero(packed_)) { leave }\\n                _result := getP(packed_, bitpos_)\\n                if iszero(and(bitmaskInited_, packed_)) {\\n                    let s_ := getP(packed_, _BITPOS_STRING)\\n                    _result := copyStr(s_, _result, getP(packed_, bitposLength_))\\n                    mstore(item_, or(bitmaskInited_, setP(packed_, bitpos_, _result)))\\n                }\\n            }\\n\\n            switch mode\\n            // Get value.\\n            case 0 { result := getStr(input, _BITPOS_VALUE, _BITPOS_VALUE_LENGTH, _VALUE_INITED) }\\n            // Get key.\\n            case 1 { result := getStr(input, _BITPOS_KEY, _BITPOS_KEY_LENGTH, _KEY_INITED) }\\n            // Get children.\\n            case 3 { result := children(input) }\\n            // Parse.\\n            default {\\n                let p := add(input, 0x20)\\n                let e := add(p, mload(input))\\n                if iszero(eq(p, e)) {\\n                    let c := chr(e)\\n                    mstore8(e, 34) // Place a '\\\"' at the end to speed up parsing.\\n                    // The `34 << 248` makes `mallocItem` preserve '\\\"' at the end.\\n                    mstore(0x00, setP(shl(248, 34), _BITPOS_STRING, input))\\n                    result, p := parseValue(input, 0, p, e)\\n                    mstore8(e, c) // Restore the original char at the end.\\n                }\\n                if or(lt(p, e), iszero(result)) { fail() }\\n            }\\n        }\\n    }\\n\\n    /// @dev Casts the input to a bytes32.\\n    function _toInput(string memory input) private pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := input\\n        }\\n    }\\n\\n    /// @dev Casts the input to a bytes32.\\n    function _toInput(Item memory input) private pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := input\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x24ddc4015b10af1bcf9eb4fd69d1e03a575698b0104b9ecc60c0c25464cd4d03\",\"license\":\"MIT\"},\"solady/src/utils/LibString.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library for converting numbers into strings and other string operations.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibString.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)\\n///\\n/// Note:\\n/// For performance and bytecode compactness, most of the string operations are restricted to\\n/// byte strings (7-bit ASCII), except where otherwise specified.\\n/// Usage of byte string operations on charsets with runes spanning two or more bytes\\n/// can lead to undefined behavior.\\nlibrary LibString {\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                        CUSTOM ERRORS                       */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The length of the output is too small to contain all the hex digits.\\n    error HexLengthInsufficient();\\n\\n    /// @dev The length of the string is more than 32 bytes.\\n    error TooBigForSmallString();\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The constant returned when the `search` is not found in the string.\\n    uint256 internal constant NOT_FOUND = type(uint256).max;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                     DECIMAL OPERATIONS                     */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns the base 10 decimal representation of `value`.\\n    function toString(uint256 value) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\\n            // and 3 words for a maximum of 78 digits.\\n            str := add(mload(0x40), 0x80)\\n            // Update the free memory pointer to allocate.\\n            mstore(0x40, add(str, 0x20))\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end of the memory to calculate the length later.\\n            let end := str\\n\\n            let w := not(0) // Tsk.\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for { let temp := value } 1 {} {\\n                str := add(str, w) // `sub(str, 1)`.\\n                // Write the character to the pointer.\\n                // The ASCII index of the '0' character is 48.\\n                mstore8(str, add(48, mod(temp, 10)))\\n                // Keep dividing `temp` until zero.\\n                temp := div(temp, 10)\\n                if iszero(temp) { break }\\n            }\\n\\n            let length := sub(end, str)\\n            // Move the pointer 32 bytes leftwards to make room for the length.\\n            str := sub(str, 0x20)\\n            // Store the length.\\n            mstore(str, length)\\n        }\\n    }\\n\\n    /// @dev Returns the base 10 decimal representation of `value`.\\n    function toString(int256 value) internal pure returns (string memory str) {\\n        if (value >= 0) {\\n            return toString(uint256(value));\\n        }\\n        unchecked {\\n            str = toString(~uint256(value) + 1);\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We still have some spare memory space on the left,\\n            // as we have allocated 3 words (96 bytes) for up to 78 digits.\\n            let length := mload(str) // Load the string length.\\n            mstore(str, 0x2d) // Store the '-' character.\\n            str := sub(str, 1) // Move back the string pointer by a byte.\\n            mstore(str, add(length, 1)) // Update the string length.\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                   HEXADECIMAL OPERATIONS                   */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns the hexadecimal representation of `value`,\\n    /// left-padded to an input length of `length` bytes.\\n    /// The output is prefixed with \\\"0x\\\" encoded using 2 hexadecimal digits per byte,\\n    /// giving a total length of `length * 2 + 2` bytes.\\n    /// Reverts if `length` is too small for the output to contain all the digits.\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value, length);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Write the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`,\\n    /// left-padded to an input length of `length` bytes.\\n    /// The output is prefixed with \\\"0x\\\" encoded using 2 hexadecimal digits per byte,\\n    /// giving a total length of `length * 2` bytes.\\n    /// Reverts if `length` is too small for the output to contain all the digits.\\n    function toHexStringNoPrefix(uint256 value, uint256 length)\\n        internal\\n        pure\\n        returns (string memory str)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes\\n            // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.\\n            // We add 0x20 to the total and round down to a multiple of 0x20.\\n            // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.\\n            str := add(mload(0x40), and(add(shl(1, length), 0x42), not(0x1f)))\\n            // Allocate the memory.\\n            mstore(0x40, add(str, 0x20))\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end to calculate the length later.\\n            let end := str\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            let start := sub(str, add(length, length))\\n            let w := not(1) // Tsk.\\n            let temp := value\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for {} 1 {} {\\n                str := add(str, w) // `sub(str, 2)`.\\n                mstore8(add(str, 1), mload(and(temp, 15)))\\n                mstore8(str, mload(and(shr(4, temp), 15)))\\n                temp := shr(8, temp)\\n                if iszero(xor(str, start)) { break }\\n            }\\n\\n            if temp {\\n                mstore(0x00, 0x2194895a) // `HexLengthInsufficient()`.\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Compute the string's length.\\n            let strLength := sub(end, str)\\n            // Move the pointer and write the length.\\n            str := sub(str, 0x20)\\n            mstore(str, strLength)\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\" and encoded using 2 hexadecimal digits per byte.\\n    /// As address are 20 bytes long, the output will left-padded to have\\n    /// a length of `20 * 2 + 2` bytes.\\n    function toHexString(uint256 value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Write the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\".\\n    /// The output excludes leading \\\"0\\\" from the `toHexString` output.\\n    /// `0x00: \\\"0x0\\\", 0x01: \\\"0x1\\\", 0x12: \\\"0x12\\\", 0x123: \\\"0x123\\\"`.\\n    function toMinimalHexString(uint256 value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(add(str, o), 0x3078) // Write the \\\"0x\\\" prefix, accounting for leading zero.\\n            str := sub(add(str, o), 2) // Move the pointer, accounting for leading zero.\\n            mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output excludes leading \\\"0\\\" from the `toHexStringNoPrefix` output.\\n    /// `0x00: \\\"0\\\", 0x01: \\\"1\\\", 0x12: \\\"12\\\", 0x123: \\\"123\\\"`.\\n    function toMinimalHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\\n            let strLength := mload(str) // Get the length.\\n            str := add(str, o) // Move the pointer, accounting for leading zero.\\n            mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    /// As address are 20 bytes long, the output will left-padded to have\\n    /// a length of `20 * 2` bytes.\\n    function toHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\\n            // 0x02 bytes for the prefix, and 0x40 bytes for the digits.\\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.\\n            str := add(mload(0x40), 0x80)\\n            // Allocate the memory.\\n            mstore(0x40, add(str, 0x20))\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end to calculate the length later.\\n            let end := str\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            let w := not(1) // Tsk.\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for { let temp := value } 1 {} {\\n                str := add(str, w) // `sub(str, 2)`.\\n                mstore8(add(str, 1), mload(and(temp, 15)))\\n                mstore8(str, mload(and(shr(4, temp), 15)))\\n                temp := shr(8, temp)\\n                if iszero(temp) { break }\\n            }\\n\\n            // Compute the string's length.\\n            let strLength := sub(end, str)\\n            // Move the pointer and write the length.\\n            str := sub(str, 0x20)\\n            mstore(str, strLength)\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\", encoded using 2 hexadecimal digits per byte,\\n    /// and the alphabets are capitalized conditionally according to\\n    /// https://eips.ethereum.org/EIPS/eip-55\\n    function toHexStringChecksummed(address value) internal pure returns (string memory str) {\\n        str = toHexString(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`\\n            let o := add(str, 0x22)\\n            let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `\\n            let t := shl(240, 136) // `0b10001000 << 240`\\n            for { let i := 0 } 1 {} {\\n                mstore(add(i, i), mul(t, byte(i, hashed)))\\n                i := add(i, 1)\\n                if eq(i, 20) { break }\\n            }\\n            mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))\\n            o := add(o, 0x20)\\n            mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\" and encoded using 2 hexadecimal digits per byte.\\n    function toHexString(address value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Write the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    function toHexStringNoPrefix(address value) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            str := mload(0x40)\\n\\n            // Allocate the memory.\\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\\n            // 0x02 bytes for the prefix, and 0x28 bytes for the digits.\\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.\\n            mstore(0x40, add(str, 0x80))\\n\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            str := add(str, 2)\\n            mstore(str, 40)\\n\\n            let o := add(str, 0x20)\\n            mstore(add(o, 40), 0)\\n\\n            value := shl(96, value)\\n\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for { let i := 0 } 1 {} {\\n                let p := add(o, add(i, i))\\n                let temp := byte(i, value)\\n                mstore8(add(p, 1), mload(and(temp, 15)))\\n                mstore8(p, mload(shr(4, temp)))\\n                i := add(i, 1)\\n                if eq(i, 20) { break }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the hex encoded string from the raw bytes.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    function toHexString(bytes memory raw) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(raw);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Write the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hex encoded string from the raw bytes.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    function toHexStringNoPrefix(bytes memory raw) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let length := mload(raw)\\n            str := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.\\n            mstore(str, add(length, length)) // Store the length of the output.\\n\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            let o := add(str, 0x20)\\n            let end := add(raw, length)\\n\\n            for {} iszero(eq(raw, end)) {} {\\n                raw := add(raw, 1)\\n                mstore8(add(o, 1), mload(and(mload(raw), 15)))\\n                mstore8(o, mload(and(shr(4, mload(raw)), 15)))\\n                o := add(o, 2)\\n            }\\n            mstore(o, 0) // Zeroize the slot after the string.\\n            mstore(0x40, add(o, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                   RUNE STRING OPERATIONS                   */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns the number of UTF characters in the string.\\n    function runeCount(string memory s) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if mload(s) {\\n                mstore(0x00, div(not(0), 255))\\n                mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)\\n                let o := add(s, 0x20)\\n                let end := add(o, mload(s))\\n                for { result := 1 } 1 { result := add(result, 1) } {\\n                    o := add(o, byte(0, mload(shr(250, mload(o)))))\\n                    if iszero(lt(o, end)) { break }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns if this string is a 7-bit ASCII string.\\n    /// (i.e. all characters codes are in [0..127])\\n    function is7BitASCII(string memory s) internal pure returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let mask := shl(7, div(not(0), 255))\\n            result := 1\\n            let n := mload(s)\\n            if n {\\n                let o := add(s, 0x20)\\n                let end := add(o, n)\\n                let last := mload(end)\\n                mstore(end, 0)\\n                for {} 1 {} {\\n                    if and(mask, mload(o)) {\\n                        result := 0\\n                        break\\n                    }\\n                    o := add(o, 0x20)\\n                    if iszero(lt(o, end)) { break }\\n                }\\n                mstore(end, last)\\n            }\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                   BYTE STRING OPERATIONS                   */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    // For performance and bytecode compactness, byte string operations are restricted\\n    // to 7-bit ASCII strings. All offsets are byte offsets, not UTF character offsets.\\n    // Usage of byte string operations on charsets with runes spanning two or more bytes\\n    // can lead to undefined behavior.\\n\\n    /// @dev Returns `subject` all occurrences of `search` replaced with `replacement`.\\n    function replace(string memory subject, string memory search, string memory replacement)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            let searchLength := mload(search)\\n            let replacementLength := mload(replacement)\\n\\n            subject := add(subject, 0x20)\\n            search := add(search, 0x20)\\n            replacement := add(replacement, 0x20)\\n            result := add(mload(0x40), 0x20)\\n\\n            let subjectEnd := add(subject, subjectLength)\\n            if iszero(gt(searchLength, subjectLength)) {\\n                let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)\\n                let h := 0\\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\\n                let s := mload(search)\\n                for {} 1 {} {\\n                    let t := mload(subject)\\n                    // Whether the first `searchLength % 32` bytes of\\n                    // `subject` and `search` matches.\\n                    if iszero(shr(m, xor(t, s))) {\\n                        if h {\\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\\n                                mstore(result, t)\\n                                result := add(result, 1)\\n                                subject := add(subject, 1)\\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\\n                                continue\\n                            }\\n                        }\\n                        // Copy the `replacement` one word at a time.\\n                        for { let o := 0 } 1 {} {\\n                            mstore(add(result, o), mload(add(replacement, o)))\\n                            o := add(o, 0x20)\\n                            if iszero(lt(o, replacementLength)) { break }\\n                        }\\n                        result := add(result, replacementLength)\\n                        subject := add(subject, searchLength)\\n                        if searchLength {\\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\\n                            continue\\n                        }\\n                    }\\n                    mstore(result, t)\\n                    result := add(result, 1)\\n                    subject := add(subject, 1)\\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\\n                }\\n            }\\n\\n            let resultRemainder := result\\n            result := add(mload(0x40), 0x20)\\n            let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))\\n            // Copy the rest of the string one word at a time.\\n            for {} lt(subject, subjectEnd) {} {\\n                mstore(resultRemainder, mload(subject))\\n                resultRemainder := add(resultRemainder, 0x20)\\n                subject := add(subject, 0x20)\\n            }\\n            result := sub(result, 0x20)\\n            let last := add(add(result, 0x20), k) // Zeroize the slot after the string.\\n            mstore(last, 0)\\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n            mstore(result, k) // Store the length.\\n        }\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from left to right, starting from `from`.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function indexOf(string memory subject, string memory search, uint256 from)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for { let subjectLength := mload(subject) } 1 {} {\\n                if iszero(mload(search)) {\\n                    if iszero(gt(from, subjectLength)) {\\n                        result := from\\n                        break\\n                    }\\n                    result := subjectLength\\n                    break\\n                }\\n                let searchLength := mload(search)\\n                let subjectStart := add(subject, 0x20)\\n\\n                result := not(0) // Initialize to `NOT_FOUND`.\\n\\n                subject := add(subjectStart, from)\\n                let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)\\n\\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\\n                let s := mload(add(search, 0x20))\\n\\n                if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }\\n\\n                if iszero(lt(searchLength, 0x20)) {\\n                    for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\\n                        if iszero(shr(m, xor(mload(subject), s))) {\\n                            if eq(keccak256(subject, searchLength), h) {\\n                                result := sub(subject, subjectStart)\\n                                break\\n                            }\\n                        }\\n                        subject := add(subject, 1)\\n                        if iszero(lt(subject, end)) { break }\\n                    }\\n                    break\\n                }\\n                for {} 1 {} {\\n                    if iszero(shr(m, xor(mload(subject), s))) {\\n                        result := sub(subject, subjectStart)\\n                        break\\n                    }\\n                    subject := add(subject, 1)\\n                    if iszero(lt(subject, end)) { break }\\n                }\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from left to right.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function indexOf(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        result = indexOf(subject, search, 0);\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from right to left, starting from `from`.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function lastIndexOf(string memory subject, string memory search, uint256 from)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {} 1 {} {\\n                result := not(0) // Initialize to `NOT_FOUND`.\\n                let searchLength := mload(search)\\n                if gt(searchLength, mload(subject)) { break }\\n                let w := result\\n\\n                let fromMax := sub(mload(subject), searchLength)\\n                if iszero(gt(fromMax, from)) { from := fromMax }\\n\\n                let end := add(add(subject, 0x20), w)\\n                subject := add(add(subject, 0x20), from)\\n                if iszero(gt(subject, end)) { break }\\n                // As this function is not too often used,\\n                // we shall simply use keccak256 for smaller bytecode size.\\n                for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\\n                    if eq(keccak256(subject, searchLength), h) {\\n                        result := sub(subject, add(end, 1))\\n                        break\\n                    }\\n                    subject := add(subject, w) // `sub(subject, 1)`.\\n                    if iszero(gt(subject, end)) { break }\\n                }\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from right to left.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function lastIndexOf(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        result = lastIndexOf(subject, search, uint256(int256(-1)));\\n    }\\n\\n    /// @dev Returns true if `search` is found in `subject`, false otherwise.\\n    function contains(string memory subject, string memory search) internal pure returns (bool) {\\n        return indexOf(subject, search) != NOT_FOUND;\\n    }\\n\\n    /// @dev Returns whether `subject` starts with `search`.\\n    function startsWith(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (bool result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let searchLength := mload(search)\\n            // Just using keccak256 directly is actually cheaper.\\n            // forgefmt: disable-next-item\\n            result := and(\\n                iszero(gt(searchLength, mload(subject))),\\n                eq(\\n                    keccak256(add(subject, 0x20), searchLength),\\n                    keccak256(add(search, 0x20), searchLength)\\n                )\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns whether `subject` ends with `search`.\\n    function endsWith(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (bool result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let searchLength := mload(search)\\n            let subjectLength := mload(subject)\\n            // Whether `search` is not longer than `subject`.\\n            let withinRange := iszero(gt(searchLength, subjectLength))\\n            // Just using keccak256 directly is actually cheaper.\\n            // forgefmt: disable-next-item\\n            result := and(\\n                withinRange,\\n                eq(\\n                    keccak256(\\n                        // `subject + 0x20 + max(subjectLength - searchLength, 0)`.\\n                        add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),\\n                        searchLength\\n                    ),\\n                    keccak256(add(search, 0x20), searchLength)\\n                )\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns `subject` repeated `times`.\\n    function repeat(string memory subject, uint256 times)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            if iszero(or(iszero(times), iszero(subjectLength))) {\\n                subject := add(subject, 0x20)\\n                result := mload(0x40)\\n                let output := add(result, 0x20)\\n                for {} 1 {} {\\n                    // Copy the `subject` one word at a time.\\n                    for { let o := 0 } 1 {} {\\n                        mstore(add(output, o), mload(add(subject, o)))\\n                        o := add(o, 0x20)\\n                        if iszero(lt(o, subjectLength)) { break }\\n                    }\\n                    output := add(output, subjectLength)\\n                    times := sub(times, 1)\\n                    if iszero(times) { break }\\n                }\\n                mstore(output, 0) // Zeroize the slot after the string.\\n                let resultLength := sub(output, add(result, 0x20))\\n                mstore(result, resultLength) // Store the length.\\n                // Allocate the memory.\\n                mstore(0x40, add(result, add(resultLength, 0x20)))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\\n    /// `start` and `end` are byte offsets.\\n    function slice(string memory subject, uint256 start, uint256 end)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            if iszero(gt(subjectLength, end)) { end := subjectLength }\\n            if iszero(gt(subjectLength, start)) { start := subjectLength }\\n            if lt(start, end) {\\n                result := mload(0x40)\\n                let resultLength := sub(end, start)\\n                mstore(result, resultLength)\\n                subject := add(subject, start)\\n                let w := not(0x1f)\\n                // Copy the `subject` one word at a time, backwards.\\n                for { let o := and(add(resultLength, 0x1f), w) } 1 {} {\\n                    mstore(add(result, o), mload(add(subject, o)))\\n                    o := add(o, w) // `sub(o, 0x20)`.\\n                    if iszero(o) { break }\\n                }\\n                // Zeroize the slot after the string.\\n                mstore(add(add(result, 0x20), resultLength), 0)\\n                // Allocate memory for the length and the bytes,\\n                // rounded up to a multiple of 32.\\n                mstore(0x40, add(result, and(add(resultLength, 0x3f), w)))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the string.\\n    /// `start` is a byte offset.\\n    function slice(string memory subject, uint256 start)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        result = slice(subject, start, uint256(int256(-1)));\\n    }\\n\\n    /// @dev Returns all the indices of `search` in `subject`.\\n    /// The indices are byte offsets.\\n    function indicesOf(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (uint256[] memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            let searchLength := mload(search)\\n\\n            if iszero(gt(searchLength, subjectLength)) {\\n                subject := add(subject, 0x20)\\n                search := add(search, 0x20)\\n                result := add(mload(0x40), 0x20)\\n\\n                let subjectStart := subject\\n                let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)\\n                let h := 0\\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\\n                let s := mload(search)\\n                for {} 1 {} {\\n                    let t := mload(subject)\\n                    // Whether the first `searchLength % 32` bytes of\\n                    // `subject` and `search` matches.\\n                    if iszero(shr(m, xor(t, s))) {\\n                        if h {\\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\\n                                subject := add(subject, 1)\\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\\n                                continue\\n                            }\\n                        }\\n                        // Append to `result`.\\n                        mstore(result, sub(subject, subjectStart))\\n                        result := add(result, 0x20)\\n                        // Advance `subject` by `searchLength`.\\n                        subject := add(subject, searchLength)\\n                        if searchLength {\\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\\n                            continue\\n                        }\\n                    }\\n                    subject := add(subject, 1)\\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\\n                }\\n                let resultEnd := result\\n                // Assign `result` to the free memory pointer.\\n                result := mload(0x40)\\n                // Store the length of `result`.\\n                mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))\\n                // Allocate memory for result.\\n                // We allocate one more word, so this array can be recycled for {split}.\\n                mstore(0x40, add(resultEnd, 0x20))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a arrays of strings based on the `delimiter` inside of the `subject` string.\\n    function split(string memory subject, string memory delimiter)\\n        internal\\n        pure\\n        returns (string[] memory result)\\n    {\\n        uint256[] memory indices = indicesOf(subject, delimiter);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let w := not(0x1f)\\n            let indexPtr := add(indices, 0x20)\\n            let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))\\n            mstore(add(indicesEnd, w), mload(subject))\\n            mstore(indices, add(mload(indices), 1))\\n            let prevIndex := 0\\n            for {} 1 {} {\\n                let index := mload(indexPtr)\\n                mstore(indexPtr, 0x60)\\n                if iszero(eq(index, prevIndex)) {\\n                    let element := mload(0x40)\\n                    let elementLength := sub(index, prevIndex)\\n                    mstore(element, elementLength)\\n                    // Copy the `subject` one word at a time, backwards.\\n                    for { let o := and(add(elementLength, 0x1f), w) } 1 {} {\\n                        mstore(add(element, o), mload(add(add(subject, prevIndex), o)))\\n                        o := add(o, w) // `sub(o, 0x20)`.\\n                        if iszero(o) { break }\\n                    }\\n                    // Zeroize the slot after the string.\\n                    mstore(add(add(element, 0x20), elementLength), 0)\\n                    // Allocate memory for the length and the bytes,\\n                    // rounded up to a multiple of 32.\\n                    mstore(0x40, add(element, and(add(elementLength, 0x3f), w)))\\n                    // Store the `element` into the array.\\n                    mstore(indexPtr, element)\\n                }\\n                prevIndex := add(index, mload(delimiter))\\n                indexPtr := add(indexPtr, 0x20)\\n                if iszero(lt(indexPtr, indicesEnd)) { break }\\n            }\\n            result := indices\\n            if iszero(mload(delimiter)) {\\n                result := add(indices, 0x20)\\n                mstore(result, sub(mload(indices), 2))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a concatenated string of `a` and `b`.\\n    /// Cheaper than `string.concat()` and does not de-align the free memory pointer.\\n    function concat(string memory a, string memory b)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let w := not(0x1f)\\n            result := mload(0x40)\\n            let aLength := mload(a)\\n            // Copy `a` one word at a time, backwards.\\n            for { let o := and(add(aLength, 0x20), w) } 1 {} {\\n                mstore(add(result, o), mload(add(a, o)))\\n                o := add(o, w) // `sub(o, 0x20)`.\\n                if iszero(o) { break }\\n            }\\n            let bLength := mload(b)\\n            let output := add(result, aLength)\\n            // Copy `b` one word at a time, backwards.\\n            for { let o := and(add(bLength, 0x20), w) } 1 {} {\\n                mstore(add(output, o), mload(add(b, o)))\\n                o := add(o, w) // `sub(o, 0x20)`.\\n                if iszero(o) { break }\\n            }\\n            let totalLength := add(aLength, bLength)\\n            let last := add(add(result, 0x20), totalLength)\\n            // Zeroize the slot after the string.\\n            mstore(last, 0)\\n            // Stores the length.\\n            mstore(result, totalLength)\\n            // Allocate memory for the length and the bytes,\\n            // rounded up to a multiple of 32.\\n            mstore(0x40, and(add(last, 0x1f), w))\\n        }\\n    }\\n\\n    /// @dev Returns a copy of the string in either lowercase or UPPERCASE.\\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\\n    function toCase(string memory subject, bool toUpper)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let length := mload(subject)\\n            if length {\\n                result := add(mload(0x40), 0x20)\\n                subject := add(subject, 1)\\n                let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)\\n                let w := not(0)\\n                for { let o := length } 1 {} {\\n                    o := add(o, w)\\n                    let b := and(0xff, mload(add(subject, o)))\\n                    mstore8(add(result, o), xor(b, and(shr(b, flags), 0x20)))\\n                    if iszero(o) { break }\\n                }\\n                result := mload(0x40)\\n                mstore(result, length) // Store the length.\\n                let last := add(add(result, 0x20), length)\\n                mstore(last, 0) // Zeroize the slot after the string.\\n                mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a string from a small bytes32 string.\\n    /// `s` must be null-terminated, or behavior will be undefined.\\n    function fromSmallString(bytes32 s) internal pure returns (string memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            let n := 0\\n            for {} byte(n, s) { n := add(n, 1) } {} // Scan for '\\\\0'.\\n            mstore(result, n)\\n            let o := add(result, 0x20)\\n            mstore(o, s)\\n            mstore(add(o, n), 0)\\n            mstore(0x40, add(result, 0x40))\\n        }\\n    }\\n\\n    /// @dev Returns the small string, with all bytes after the first null byte zeroized.\\n    function normalizeSmallString(bytes32 s) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {} byte(result, s) { result := add(result, 1) } {} // Scan for '\\\\0'.\\n            mstore(0x00, s)\\n            mstore(result, 0x00)\\n            result := mload(0x00)\\n        }\\n    }\\n\\n    /// @dev Returns the string as a normalized null-terminated small string.\\n    function toSmallString(string memory s) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(s)\\n            if iszero(lt(result, 33)) {\\n                mstore(0x00, 0xec92f9a3) // `TooBigForSmallString()`.\\n                revert(0x1c, 0x04)\\n            }\\n            result := shl(shl(3, sub(32, result)), mload(add(s, result)))\\n        }\\n    }\\n\\n    /// @dev Returns a lowercased copy of the string.\\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\\n    function lower(string memory subject) internal pure returns (string memory result) {\\n        result = toCase(subject, false);\\n    }\\n\\n    /// @dev Returns an UPPERCASED copy of the string.\\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\\n    function upper(string memory subject) internal pure returns (string memory result) {\\n        result = toCase(subject, true);\\n    }\\n\\n    /// @dev Escapes the string to be used within HTML tags.\\n    function escapeHTML(string memory s) internal pure returns (string memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let end := add(s, mload(s))\\n            result := add(mload(0x40), 0x20)\\n            // Store the bytes of the packed offsets and strides into the scratch space.\\n            // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.\\n            mstore(0x1f, 0x900094)\\n            mstore(0x08, 0xc0000000a6ab)\\n            // Store \\\"&quot;&amp;&#39;&lt;&gt;\\\" into the scratch space.\\n            mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))\\n            for {} iszero(eq(s, end)) {} {\\n                s := add(s, 1)\\n                let c := and(mload(s), 0xff)\\n                // Not in `[\\\"\\\\\\\"\\\",\\\"'\\\",\\\"&\\\",\\\"<\\\",\\\">\\\"]`.\\n                if iszero(and(shl(c, 1), 0x500000c400000000)) {\\n                    mstore8(result, c)\\n                    result := add(result, 1)\\n                    continue\\n                }\\n                let t := shr(248, mload(c))\\n                mstore(result, mload(and(t, 0x1f)))\\n                result := add(result, shr(5, t))\\n            }\\n            let last := result\\n            mstore(last, 0) // Zeroize the slot after the string.\\n            result := mload(0x40)\\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\\n    /// If `addDoubleQuotes` is true, the result will be enclosed in double-quotes.\\n    function escapeJSON(string memory s, bool addDoubleQuotes)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let end := add(s, mload(s))\\n            result := add(mload(0x40), 0x20)\\n            if addDoubleQuotes {\\n                mstore8(result, 34)\\n                result := add(1, result)\\n            }\\n            // Store \\\"\\\\\\\\u0000\\\" in scratch space.\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            // Also, store `{0x08:\\\"b\\\", 0x09:\\\"t\\\", 0x0a:\\\"n\\\", 0x0c:\\\"f\\\", 0x0d:\\\"r\\\"}`.\\n            // into the scratch space.\\n            mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)\\n            // Bitmask for detecting `[\\\"\\\\\\\"\\\",\\\"\\\\\\\\\\\"]`.\\n            let e := or(shl(0x22, 1), shl(0x5c, 1))\\n            for {} iszero(eq(s, end)) {} {\\n                s := add(s, 1)\\n                let c := and(mload(s), 0xff)\\n                if iszero(lt(c, 0x20)) {\\n                    if iszero(and(shl(c, 1), e)) {\\n                        // Not in `[\\\"\\\\\\\"\\\",\\\"\\\\\\\\\\\"]`.\\n                        mstore8(result, c)\\n                        result := add(result, 1)\\n                        continue\\n                    }\\n                    mstore8(result, 0x5c) // \\\"\\\\\\\\\\\".\\n                    mstore8(add(result, 1), c)\\n                    result := add(result, 2)\\n                    continue\\n                }\\n                if iszero(and(shl(c, 1), 0x3700)) {\\n                    // Not in `[\\\"\\\\b\\\",\\\"\\\\t\\\",\\\"\\\\n\\\",\\\"\\\\f\\\",\\\"\\\\d\\\"]`.\\n                    mstore8(0x1d, mload(shr(4, c))) // Hex value.\\n                    mstore8(0x1e, mload(and(c, 15))) // Hex value.\\n                    mstore(result, mload(0x19)) // \\\"\\\\\\\\u00XX\\\".\\n                    result := add(result, 6)\\n                    continue\\n                }\\n                mstore8(result, 0x5c) // \\\"\\\\\\\\\\\".\\n                mstore8(add(result, 1), mload(add(c, 8)))\\n                result := add(result, 2)\\n            }\\n            if addDoubleQuotes {\\n                mstore8(result, 34)\\n                result := add(1, result)\\n            }\\n            let last := result\\n            mstore(last, 0) // Zeroize the slot after the string.\\n            result := mload(0x40)\\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\\n    function escapeJSON(string memory s) internal pure returns (string memory result) {\\n        result = escapeJSON(s, false);\\n    }\\n\\n    /// @dev Returns whether `a` equals `b`.\\n    function eq(string memory a, string memory b) internal pure returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))\\n        }\\n    }\\n\\n    /// @dev Returns whether `a` equals `b`, where `b` is a null-terminated small string.\\n    function eqs(string memory a, bytes32 b) internal pure returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // These should be evaluated on compile time, as far as possible.\\n            let m := not(shl(7, div(not(iszero(b)), 255))) // `0x7f7f ...`.\\n            let x := not(or(m, or(b, add(m, and(b, m)))))\\n            let r := shl(7, iszero(iszero(shr(128, x))))\\n            r := or(r, shl(6, iszero(iszero(shr(64, shr(r, x))))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\\n            // forgefmt: disable-next-item\\n            result := gt(eq(mload(a), add(iszero(x), xor(31, shr(3, r)))),\\n                xor(shr(add(8, r), b), shr(add(8, r), mload(add(a, 0x20)))))\\n        }\\n    }\\n\\n    /// @dev Packs a single string with its length into a single word.\\n    /// Returns `bytes32(0)` if the length is zero or greater than 31.\\n    function packOne(string memory a) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We don't need to zero right pad the string,\\n            // since this is our own custom non-standard packing scheme.\\n            result :=\\n                mul(\\n                    // Load the length and the bytes.\\n                    mload(add(a, 0x1f)),\\n                    // `length != 0 && length < 32`. Abuses underflow.\\n                    // Assumes that the length is valid and within the block gas limit.\\n                    lt(sub(mload(a), 1), 0x1f)\\n                )\\n        }\\n    }\\n\\n    /// @dev Unpacks a string packed using {packOne}.\\n    /// Returns the empty string if `packed` is `bytes32(0)`.\\n    /// If `packed` is not an output of {packOne}, the output behavior is undefined.\\n    function unpackOne(bytes32 packed) internal pure returns (string memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Grab the free memory pointer.\\n            result := mload(0x40)\\n            // Allocate 2 words (1 for the length, 1 for the bytes).\\n            mstore(0x40, add(result, 0x40))\\n            // Zeroize the length slot.\\n            mstore(result, 0)\\n            // Store the length and bytes.\\n            mstore(add(result, 0x1f), packed)\\n            // Right pad with zeroes.\\n            mstore(add(add(result, 0x20), mload(result)), 0)\\n        }\\n    }\\n\\n    /// @dev Packs two strings with their lengths into a single word.\\n    /// Returns `bytes32(0)` if combined length is zero or greater than 30.\\n    function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let aLength := mload(a)\\n            // We don't need to zero right pad the strings,\\n            // since this is our own custom non-standard packing scheme.\\n            result :=\\n                mul(\\n                    // Load the length and the bytes of `a` and `b`.\\n                    or(\\n                        shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))),\\n                        mload(sub(add(b, 0x1e), aLength))\\n                    ),\\n                    // `totalLength != 0 && totalLength < 31`. Abuses underflow.\\n                    // Assumes that the lengths are valid and within the block gas limit.\\n                    lt(sub(add(aLength, mload(b)), 1), 0x1e)\\n                )\\n        }\\n    }\\n\\n    /// @dev Unpacks strings packed using {packTwo}.\\n    /// Returns the empty strings if `packed` is `bytes32(0)`.\\n    /// If `packed` is not an output of {packTwo}, the output behavior is undefined.\\n    function unpackTwo(bytes32 packed)\\n        internal\\n        pure\\n        returns (string memory resultA, string memory resultB)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Grab the free memory pointer.\\n            resultA := mload(0x40)\\n            resultB := add(resultA, 0x40)\\n            // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.\\n            mstore(0x40, add(resultB, 0x40))\\n            // Zeroize the length slots.\\n            mstore(resultA, 0)\\n            mstore(resultB, 0)\\n            // Store the lengths and bytes.\\n            mstore(add(resultA, 0x1f), packed)\\n            mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))\\n            // Right pad with zeroes.\\n            mstore(add(add(resultA, 0x20), mload(resultA)), 0)\\n            mstore(add(add(resultB, 0x20), mload(resultB)), 0)\\n        }\\n    }\\n\\n    /// @dev Directly returns `a` without copying.\\n    function directReturn(string memory a) internal pure {\\n        assembly {\\n            // Assumes that the string does not start from the scratch space.\\n            let retStart := sub(a, 0x20)\\n            let retSize := add(mload(a), 0x40)\\n            // Right pad with zeroes. Just in case the string is produced\\n            // by a method that doesn't zero right pad.\\n            mstore(add(retStart, retSize), 0)\\n            // Store the return offset.\\n            mstore(retStart, 0x20)\\n            // End the transaction, returning the string.\\n            return(retStart, retSize)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf9089e94e05f506f21357bc513c166d58f4d6a02d589741c72e8a7722cefeda2\",\"license\":\"MIT\"},\"solidity-rlp/contracts/RLPReader.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * @author Hamdi Allam hamdi.allam97@gmail.com\\n * Please reach out with any questions or concerns\\n */\\npragma solidity >=0.5.10 <0.9.0;\\n\\nlibrary RLPReader {\\n    uint8 constant STRING_SHORT_START = 0x80;\\n    uint8 constant STRING_LONG_START = 0xb8;\\n    uint8 constant LIST_SHORT_START = 0xc0;\\n    uint8 constant LIST_LONG_START = 0xf8;\\n    uint8 constant WORD_SIZE = 32;\\n\\n    struct RLPItem {\\n        uint256 len;\\n        uint256 memPtr;\\n    }\\n\\n    struct Iterator {\\n        RLPItem item; // Item that's being iterated over.\\n        uint256 nextPtr; // Position of the next item in the list.\\n    }\\n\\n    /*\\n     * @dev Returns the next element in the iteration. Reverts if it has not next element.\\n     * @param self The iterator.\\n     * @return The next element in the iteration.\\n     */\\n    function next(Iterator memory self) internal pure returns (RLPItem memory) {\\n        require(hasNext(self));\\n\\n        uint256 ptr = self.nextPtr;\\n        uint256 itemLength = _itemLength(ptr);\\n        self.nextPtr = ptr + itemLength;\\n\\n        return RLPItem(itemLength, ptr);\\n    }\\n\\n    /*\\n     * @dev Returns true if the iteration has more elements.\\n     * @param self The iterator.\\n     * @return true if the iteration has more elements.\\n     */\\n    function hasNext(Iterator memory self) internal pure returns (bool) {\\n        RLPItem memory item = self.item;\\n        return self.nextPtr < item.memPtr + item.len;\\n    }\\n\\n    /*\\n     * @param item RLP encoded bytes\\n     */\\n    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\\n        uint256 memPtr;\\n        assembly {\\n            memPtr := add(item, 0x20)\\n        }\\n\\n        return RLPItem(item.length, memPtr);\\n    }\\n\\n    /*\\n     * @dev Create an iterator. Reverts if item is not a list.\\n     * @param self The RLP item.\\n     * @return An 'Iterator' over the item.\\n     */\\n    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {\\n        require(isList(self));\\n\\n        uint256 ptr = self.memPtr + _payloadOffset(self.memPtr);\\n        return Iterator(self, ptr);\\n    }\\n\\n    /*\\n     * @param the RLP item.\\n     */\\n    function rlpLen(RLPItem memory item) internal pure returns (uint256) {\\n        return item.len;\\n    }\\n\\n    /*\\n     * @param the RLP item.\\n     * @return (memPtr, len) pair: location of the item's payload in memory.\\n     */\\n    function payloadLocation(RLPItem memory item) internal pure returns (uint256, uint256) {\\n        uint256 offset = _payloadOffset(item.memPtr);\\n        uint256 memPtr = item.memPtr + offset;\\n        uint256 len = item.len - offset; // data length\\n        return (memPtr, len);\\n    }\\n\\n    /*\\n     * @param the RLP item.\\n     */\\n    function payloadLen(RLPItem memory item) internal pure returns (uint256) {\\n        (, uint256 len) = payloadLocation(item);\\n        return len;\\n    }\\n\\n    /*\\n     * @param the RLP item containing the encoded list.\\n     */\\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {\\n        require(isList(item));\\n\\n        uint256 items = numItems(item);\\n        RLPItem[] memory result = new RLPItem[](items);\\n\\n        uint256 memPtr = item.memPtr + _payloadOffset(item.memPtr);\\n        uint256 dataLen;\\n        for (uint256 i = 0; i < items; i++) {\\n            dataLen = _itemLength(memPtr);\\n            result[i] = RLPItem(dataLen, memPtr);\\n            memPtr = memPtr + dataLen;\\n        }\\n\\n        return result;\\n    }\\n\\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\\n    function isList(RLPItem memory item) internal pure returns (bool) {\\n        if (item.len == 0) return false;\\n\\n        uint8 byte0;\\n        uint256 memPtr = item.memPtr;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 < LIST_SHORT_START) return false;\\n        return true;\\n    }\\n\\n    /*\\n     * @dev A cheaper version of keccak256(toRlpBytes(item)) that avoids copying memory.\\n     * @return keccak256 hash of RLP encoded bytes.\\n     */\\n    function rlpBytesKeccak256(RLPItem memory item) internal pure returns (bytes32) {\\n        uint256 ptr = item.memPtr;\\n        uint256 len = item.len;\\n        bytes32 result;\\n        assembly {\\n            result := keccak256(ptr, len)\\n        }\\n        return result;\\n    }\\n\\n    /*\\n     * @dev A cheaper version of keccak256(toBytes(item)) that avoids copying memory.\\n     * @return keccak256 hash of the item payload.\\n     */\\n    function payloadKeccak256(RLPItem memory item) internal pure returns (bytes32) {\\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\\n        bytes32 result;\\n        assembly {\\n            result := keccak256(memPtr, len)\\n        }\\n        return result;\\n    }\\n\\n    /** RLPItem conversions into data types **/\\n\\n    // @returns raw rlp encoding in bytes\\n    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {\\n        bytes memory result = new bytes(item.len);\\n        if (result.length == 0) return result;\\n\\n        uint256 ptr;\\n        assembly {\\n            ptr := add(0x20, result)\\n        }\\n\\n        copy(item.memPtr, ptr, item.len);\\n        return result;\\n    }\\n\\n    // any non-zero byte except \\\"0x80\\\" is considered true\\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\\n        require(item.len == 1);\\n        uint256 result;\\n        uint256 memPtr = item.memPtr;\\n        assembly {\\n            result := byte(0, mload(memPtr))\\n        }\\n\\n        // SEE Github Issue #5.\\n        // Summary: Most commonly used RLP libraries (i.e Geth) will encode\\n        // \\\"0\\\" as \\\"0x80\\\" instead of as \\\"0\\\". We handle this edge case explicitly\\n        // here.\\n        if (result == 0 || result == STRING_SHORT_START) {\\n            return false;\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    function toAddress(RLPItem memory item) internal pure returns (address) {\\n        // 1 byte for the length prefix\\n        require(item.len == 21);\\n\\n        return address(uint160(toUint(item)));\\n    }\\n\\n    function toUint(RLPItem memory item) internal pure returns (uint256) {\\n        require(item.len > 0 && item.len <= 33);\\n\\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\\n\\n        uint256 result;\\n        assembly {\\n            result := mload(memPtr)\\n\\n            // shift to the correct location if neccesary\\n            if lt(len, 32) {\\n                result := div(result, exp(256, sub(32, len)))\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    // enforces 32 byte length\\n    function toUintStrict(RLPItem memory item) internal pure returns (uint256) {\\n        // one byte prefix\\n        require(item.len == 33);\\n\\n        uint256 result;\\n        uint256 memPtr = item.memPtr + 1;\\n        assembly {\\n            result := mload(memPtr)\\n        }\\n\\n        return result;\\n    }\\n\\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\\n        require(item.len > 0);\\n\\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\\n        bytes memory result = new bytes(len);\\n\\n        uint256 destPtr;\\n        assembly {\\n            destPtr := add(0x20, result)\\n        }\\n\\n        copy(memPtr, destPtr, len);\\n        return result;\\n    }\\n\\n    /*\\n     * Private Helpers\\n     */\\n\\n    // @return number of payload items inside an encoded list.\\n    function numItems(RLPItem memory item) private pure returns (uint256) {\\n        if (item.len == 0) return 0;\\n\\n        uint256 count = 0;\\n        uint256 currPtr = item.memPtr + _payloadOffset(item.memPtr);\\n        uint256 endPtr = item.memPtr + item.len;\\n        while (currPtr < endPtr) {\\n            currPtr = currPtr + _itemLength(currPtr); // skip over an item\\n            count++;\\n        }\\n\\n        return count;\\n    }\\n\\n    // @return entire rlp item byte length\\n    function _itemLength(uint256 memPtr) private pure returns (uint256) {\\n        uint256 itemLen;\\n        uint256 byte0;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 < STRING_SHORT_START) {\\n            itemLen = 1;\\n        } else if (byte0 < STRING_LONG_START) {\\n            itemLen = byte0 - STRING_SHORT_START + 1;\\n        } else if (byte0 < LIST_SHORT_START) {\\n            assembly {\\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\\n                memPtr := add(memPtr, 1) // skip over the first byte\\n\\n                /* 32 byte word size */\\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\\n                itemLen := add(dataLen, add(byteLen, 1))\\n            }\\n        } else if (byte0 < LIST_LONG_START) {\\n            itemLen = byte0 - LIST_SHORT_START + 1;\\n        } else {\\n            assembly {\\n                let byteLen := sub(byte0, 0xf7)\\n                memPtr := add(memPtr, 1)\\n\\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\\n                itemLen := add(dataLen, add(byteLen, 1))\\n            }\\n        }\\n\\n        return itemLen;\\n    }\\n\\n    // @return number of bytes until the data\\n    function _payloadOffset(uint256 memPtr) private pure returns (uint256) {\\n        uint256 byte0;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 < STRING_SHORT_START) {\\n            return 0;\\n        } else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START)) {\\n            return 1;\\n        } else if (byte0 < LIST_SHORT_START) {\\n            // being explicit\\n            return byte0 - (STRING_LONG_START - 1) + 1;\\n        } else {\\n            return byte0 - (LIST_LONG_START - 1) + 1;\\n        }\\n    }\\n\\n    /*\\n     * @param src Pointer to source\\n     * @param dest Pointer to destination\\n     * @param len Amount of memory to copy from the source\\n     */\\n    function copy(uint256 src, uint256 dest, uint256 len) private pure {\\n        if (len == 0) return;\\n\\n        // copy as many word sizes as possible\\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n\\n            src += WORD_SIZE;\\n            dest += WORD_SIZE;\\n        }\\n\\n        if (len > 0) {\\n            // left over bytes. Mask is used to remove unwanted bytes from the word\\n            uint256 mask = 256**(WORD_SIZE - len) - 1;\\n            assembly {\\n                let srcpart := and(mload(src), not(mask)) // zero out src\\n                let destpart := and(mload(dest), mask) // retrieve the bytes\\n                mstore(dest, or(destpart, srcpart))\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x3a44f2de3c752fa4f926f3fd4cad8338dab742484150c0d7d2f785409ed8db4d\",\"license\":\"Apache-2.0\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b506159f780620000216000396000f3fe6080604052600436106101185760003560e01c80639829ba42116100a0578063e0a388fb11610064578063e0a388fb146103bb578063e2411625146103e6578063ea42418b1461040f578063f77c47911461043a578063fdd13fe71461046557610119565b80639829ba42146102e65780639893306514610311578063b72a65401461033a578063d3596e7f14610365578063d86cd69a1461039057610119565b80632e0f2625116100e75780632e0f2625146101eb578063392e53cd14610216578063507235531461024157806357e3c1b51461027e5780637e48532c146102bb57610119565b80630de8cb931461011b5780631d148b8d1461015857806323b17abc146101955780632bc361db146101c057610119565b5b005b34801561012757600080fd5b50610142600480360381019061013d9190613bd2565b61048e565b60405161014f9190613cf1565b60405180910390f35b34801561016457600080fd5b5061017f600480360381019061017a9190613db4565b61057c565b60405161018c9190613cf1565b60405180910390f35b3480156101a157600080fd5b506101aa61072c565b6040516101b79190613e52565b60405180910390f35b3480156101cc57600080fd5b506101d5610748565b6040516101e29190613e52565b60405180910390f35b3480156101f757600080fd5b50610200610781565b60405161020d9190613e90565b60405180910390f35b34801561022257600080fd5b5061022b610786565b6040516102389190613eba565b60405180910390f35b34801561024d57600080fd5b5061026860048036038101906102639190613ed5565b610797565b6040516102759190613f2d565b60405180910390f35b34801561028a57600080fd5b506102a560048036038101906102a09190613fa6565b610823565b6040516102b29190613cf1565b60405180910390f35b3480156102c757600080fd5b506102d06109ef565b6040516102dd9190613cf1565b60405180910390f35b3480156102f257600080fd5b506102fb610b2c565b6040516103089190613e52565b60405180910390f35b34801561031d57600080fd5b5061033860048036038101906103339190613fd3565b610b65565b005b34801561034657600080fd5b5061034f610c72565b60405161035c9190613e52565b60405180910390f35b34801561037157600080fd5b5061037a610c8e565b604051610387919061407c565b60405180910390f35b34801561039c57600080fd5b506103a5610ca1565b6040516103b29190613e52565b60405180910390f35b3480156103c757600080fd5b506103d0610cda565b6040516103dd9190613f2d565b60405180910390f35b3480156103f257600080fd5b5061040d600480360381019061040891906140c3565b610ce0565b005b34801561041b57600080fd5b50610424610db6565b6040516104319190614112565b60405180910390f35b34801561044657600080fd5b5061044f610ddc565b60405161045c9190614112565b60405180910390f35b34801561047157600080fd5b5061048c6004803603810190610487919061412d565b610e02565b005b60606104d661049b610e77565b6040518060400160405280601081526020017f4e6f7420636f6e666964656e7469616c00000000000000000000000000000000815250610f41565b60006104e187610797565b905060006104f3888389898989610f87565b905063fdd13fe760e01b888383604051602401610512939291906141b8565b604051602081830303815290604052907bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff83818316178352505050509250505095945050505050565b6060600061058983610fc5565b60405160200161059991906142f7565b60405160208183030381529060405290506105b261390f565b6040518060400160405280600481526020017f504f5354000000000000000000000000000000000000000000000000000000008152508160200181905250818160600181905250600167ffffffffffffffff811115610614576106136139f9565b5b60405190808252806020026020018201604052801561064757816020015b60608152602001906001900390816106325790505b5081604001819052506040518060400160405280601e81526020017f436f6e74656e742d547970653a206170706c69636174696f6e2f6a736f6e0000815250816040015160008151811061069e5761069d614324565b5b602002602001018190525060008160800190151590811515815250506040518060400160405280600781526020017f686f6c65736b790000000000000000000000000000000000000000000000000081525081600001819052506127108160a0019067ffffffffffffffff16908167ffffffffffffffff168152505061072381610feb565b92505050919050565b60405180606001604052806023815260200161599f6023913981565b6040518060400160405280600781526020017f686f6c65736b790000000000000000000000000000000000000000000000000081525081565b600481565b60008054906101000a900460ff1681565b6000806107a3836110a4565b905060006107b08261125b565b905060006108046107ff6040518060400160405280600781526020017f22707269636522000000000000000000000000000000000000000000000000008152508461128790919063ffffffff16565b61130a565b90506108196108128261132c565b60046113f9565b9350505050919050565b606061086b610830610e77565b6040518060400160405280601081526020017f4e6f7420636f6e666964656e7469616c00000000000000000000000000000000815250610f41565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff1614806109155750600073ffffffffffffffffffffffffffffffffffffffff16600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16145b610954576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161094b9061439f565b60405180910390fd5b600061095f836115c0565b9050600061096c8261057c565b9050639893306560e01b84826040516024016109899291906143bf565b604051602081830303815290604052907bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff838183161783525050505092505050919050565b6060610a376109fc610e77565b6040518060400160405280601081526020017f4e6f7420636f6e666964656e7469616c00000000000000000000000000000000815250610f41565b610a8460008054906101000a900460ff16156040518060400160405280601381526020017f416c726561647920696e697469616c697a656400000000000000000000000000815250610f41565b6000610a906000611700565b90506000610a9d826117f9565b90506000610aaa83611865565b905063e241162560e01b8183604051602401610ac79291906143ef565b604051602081830303815290604052907bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff8381831617835250505050935050505090565b6040518060400160405280601281526020017f6f7261636c653a76303a706b736563726574000000000000000000000000000081525081565b600073ffffffffffffffffffffffffffffffffffffffff16600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1614610bf6576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610bed9061439f565b60405180910390fd5b81600260006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055507fa93bc9ff6ba5c181f59d418898928cae5d5f4c5ecc1003043191481dd769d4cc81604051610c669190613cf1565b60405180910390a15050565b6040518060600160405280603b8152602001615964603b913981565b600060019054906101000a900460801b81565b6040518060400160405280600681526020017f307834323638000000000000000000000000000000000000000000000000000081525081565b61426881565b610d2d60008054906101000a900460ff16156040518060400160405280601381526020017f416c726561647920696e697469616c697a656400000000000000000000000000815250610f41565b81600060016101000a8154816fffffffffffffffffffffffffffffffff021916908360801c021790555080600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060016000806101000a81548160ff0219169083151502179055505050565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b7ff61f2fd6ab65716facd3516c91d806d98dffa9670f127beac522f8cacfd1d8df8383604051610e33929190614418565b60405180910390a17fa93bc9ff6ba5c181f59d418898928cae5d5f4c5ecc1003043191481dd769d4cc81604051610e6a9190613cf1565b60405180910390a1505050565b6000806000634201000073ffffffffffffffffffffffffffffffffffffffff16604051610ea390614479565b6000604051808303816000865af19150503d8060008114610ee0576040519150601f19603f3d011682016040523d82523d6000602084013e610ee5565b606091505b509150915081610f32576342010000816040517f75fff467000000000000000000000000000000000000000000000000000000008152600401610f299291906143bf565b60405180910390fd5b80516020820151935050505090565b81610f8357806040517f0c25cd98000000000000000000000000000000000000000000000000000000008152600401610f7a9190613e52565b60405180910390fd5b5050565b60606000610f9788888888611a41565b90508215610fae57610fa98185611bad565b610fba565b610fb78161057c565b91505b509695505050505050565b6060610fd082611bc4565b90506002815101613078825260028203915080825250919050565b6060600080634320000273ffffffffffffffffffffffffffffffffffffffff168460405160200161101c91906146a0565b60405160208183030381529060405260405161103891906146f3565b600060405180830381855afa9150503d8060008114611073576040519150601f19603f3d011682016040523d82523d6000602084013e611078565b606091505b50915091506110878282610f41565b8080602001905181019061109b919061477a565b92505050919050565b60606000600167ffffffffffffffff8111156110c3576110c26139f9565b5b6040519080825280602002602001820160405280156110f657816020015b60608152602001906001900390816110e15790505b5090506040518060400160405280601e81526020017f436f6e74656e742d547970653a206170706c69636174696f6e2f6a736f6e00008152508160008151811061114357611142614324565b5b602002602001018190525060006040518060c001604052806040518060600160405280603b8152602001615964603b9139866040516020016111869291906147c3565b60405160208183030381529060405281526020016040518060400160405280600381526020017f47455400000000000000000000000000000000000000000000000000000000008152508152602001838152602001600067ffffffffffffffff8111156111f6576111f56139f9565b5b6040519080825280601f01601f1916602001820160405280156112285781602001600182028036833780820191505090505b50815260200160001515815260200161271067ffffffffffffffff16815250905061125281610feb565b92505050919050565b611263613951565b80604052600061127c61127584611c32565b60ff611c3c565b905080915050919050565b61128f613951565b80604052606090506112a083612500565b156113045760008280519060200120905060006112bc85612517565b9050600060058251901b90505b6000811461130057808201519550602081039050826112e787612539565b80519060200120036112fb57859350611300565b6112c9565b5050505b92915050565b6060600061132161131a8461256b565b6000611c3c565b905080915050919050565b606060008290506002815111611377576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161136e90614833565b60405180910390fd5b6000600282516113879190614882565b905060008167ffffffffffffffff8111156113a5576113a46139f9565b5b6040519080825280601f01601f1916602001820160405280156113d75781602001600182028036833780820191505090505b5090506021830160208201845182518252848452505050809350505050919050565b600080839050600080600090505b825181101561147557602e60f81b83828151811061142857611427614324565b5b602001015160f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff19160361146257809150611475565b808061146d906148b6565b915050611407565b5060008060006001905060008490505b6000811115611504578160308760018461149f9190614882565b815181106114b0576114af614324565b5b602001015160f81c60f81b60f81c6114c891906148fe565b60ff166114d59190614932565b846114e0919061498c565b9350600a826114ef9190614932565b915080806114fc906149e2565b915050611485565b506001905060008760ff168561151a919061498c565b90505b8481111561158f5781603087838151811061153b5761153a614324565b5b602001015160f81c60f81b60f81c61155391906148fe565b60ff166115609190614932565b8361156b919061498c565b9250600a8261157a9190614932565b91508080611587906149e2565b91505061151d565b508187600a61159e9190614b3e565b846115a99190614932565b6115b3919061498c565b9550505050505092915050565b606060006040518060e001604052808473ffffffffffffffffffffffffffffffffffffffff168152602001620186a0815260200164174876e800815260200160008152602001600081526020016040516024016040516020818303038152906040527f1aa3a008000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff83818316178352505050508152602001614268815250905060006116a882612575565b905060006116b46127f2565b90506116f6826040518060400160405280600681526020017f30783432363800000000000000000000000000000000000000000000000000008152508361284d565b9350505050919050565b6060600080635320000373ffffffffffffffffffffffffffffffffffffffff16846040516020016117319190614c00565b60405160208183030381529060405260405161174d91906146f3565b6000604051808303816000865af19150503d806000811461178a576040519150601f19603f3d011682016040523d82523d6000602084013e61178f565b606091505b5091509150816117dc576353200003816040517f75fff4670000000000000000000000000000000000000000000000000000000081526004016117d39291906143bf565b60405180910390fd5b808060200190518101906117f09190614c8b565b92505050919050565b60008060405160200161180b90614d20565b6040516020818303038152906040528051906020012090506000611850826040516020016118399190614d6b565b60405160208183030381529060405260008661294c565b905061185c8282612a5c565b92505050919050565b600080600367ffffffffffffffff811115611883576118826139f9565b5b6040519080825280602002602001820160405280156118b15781602001602082028036833780820191505090505b50905030816000815181106118c9576118c8614324565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff168152505063420300018160018151811061191c5761191b614324565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff168152505063420200018160028151811061196f5761196e614324565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff168152505060006119ed600083846040518060400160405280601281526020017f6f7261636c653a76303a706b7365637265740000000000000000000000000000815250612acb565b9050611a3381600001516040518060400160405280601281526020017f6f7261636c653a76303a706b736563726574000000000000000000000000000081525086612bd3565b806000015192505050919050565b606060006040518060e00160405280600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001620186a08152602001848152602001600081526020018581526020018787604051602401611abd929190614418565b6040516020818303038152906040527f4a432a46000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff8381831617835250505050815260200161426881525090506000611b5282612575565b90506000611b5e6127f2565b9050611ba0826040518060400160405280600681526020017f30783432363800000000000000000000000000000000000000000000000000008152508361284d565b9350505050949350505050565b611bb682612cb8565b611bc08282612da3565b5050565b60608151600260405101915080810182526f30313233343536373839616263646566600f52602082018184015b808514611c1f57600185019450600f855116516001830153600f855160041c16518253600282019150611bf1565b6000825260208201604052505050919050565b6000819050919050565b6000612448565b63101827966000526004601cfd5b6000815160001a9050919050565b60008190505b600115611c8f576001640100002600611c7d83611c51565b1c1615611c9057600181019050611c65565b5b92915050565b600063ffffffff84113d3d3e83831b8263ffffffff851b19161790509392505050565b600081831c63ffffffff16905092915050565b60006040519050611cf18486036078611cec602086018803605888611c96565b611c96565b925085831781526020810160405295945050505050565b600080611d19846018600051611c96565b611d238787611c5f565b9150868210611d325750611e85565b611d3b82611c51565b600115611e765760228103611d6f5782611d57898585896120c7565b9350611d6760048583868a611ccc565b945050611e76565b605b8103611d8c57611d8388848488611e8e565b93509350611e76565b607b8103611da957611da088848488611f66565b93509350611e76565b6001611ff9602d1b821c1615611dce57611dc5888484886121d6565b93509350611e76565b876004840111611e315782835160e01c63747275658103611e0657600485019450611dfd60058684878b611ccc565b95505050611e76565b636e756c6c8103611e2e57600485019450611e2560068684878b611ccc565b95505050611e76565b50505b876005840111611e6d5782835160d81c6466616c73658103611e6a57600585019450611e6160058684878b611ccc565b95505050611e76565b50505b611e75611c43565b5b50611e818783611c5f565b9150505b94509492505050565b60008060006001860191505b600115611f3857868210611eb157611eb0611c43565b5b82611ed457611ec08783611c5f565b9150605d611ecd83611c51565b0315611f38575b611ee087838587611d08565b925092508215611f2957611efa8160988551604017611c96565b8352600181019050611f0b82611c51565b605d8103611f195750611f38565b602c8103611f275750611f2d565b505b8691505b600182019150611e9a565b600182019150611f4a83603887611c96565b9450611f5a600183888888611ccc565b92505094509492505050565b6000806001850190505b60011561205957858110611f8757611f86611c43565b5b81611faa57611f968682611c5f565b9050607d611fa382611c51565b0315612059575b611fb48682611c5f565b905080611fc3878385876120c7565b611fcd8882611c5f565b9250603a611fda84611c51565b0361204857611fee88600185018688611d08565b9350935083156120475761201a602086018303609861201585850360b88951608017611c96565b611c96565b845261202583611c51565b607d810361203557505050612059565b602c81036120455750505061204e565b505b5b87925050505b600181019050611f70565b60018101905061206b82603886611c96565b935061207b600282878787611ccc565b915094509492505050565b6001667e0000007e03ff603061209d858501611c51565b031c166120ad576120ac611c43565b5b600582146120c3576120c26001830182612086565b5b5050565b60008484106120d9576120d8611c43565b5b6001840190505b600115612172576120f081611c51565b602281036120fe5750612172565b605c8114612112576001820191505061216d565b61211e60018301611c51565b905060016a0510110400000000002001602283031c1615612145576002820191505061216d565b6075810361216457612158600283612086565b6006820191505061216d565b85915050612172565b6120e0565b84811061218257612181611c43565b5b600181019050949350505050565b60008190505b6001156121bc57600a60306121aa83611c51565b0310156121bc57600181019050612196565b8082148416156121cf576121ce611c43565b5b9392505050565b600080849050602d6121e782611c51565b036121f3576001810190505b600a603061220083611c51565b031061220f5761220e611c43565b5b61221881611c51565b600182019150603081146122355761223260008884612190565b91505b602e61224083611c51565b036122575761225460018860018501612190565b91505b815160658160001a60201703612286576122836001896001860162010001600e8660011a031a01612190565b92505b612294600384898989611ccc565b9350505094509492505050565b600060405190508282019150601f1980601f8601165b6001156122d15780840151818401528181019050806122b7575b50848252600085602084010152846040830101604052509392505050565b6000606090508151600281600716116123db5782158115176123db5760208116156123265761231f603882611cb9565b91506123db565b60405191506020820161233a603883611cb9565b5b801561236f578082528051612351601882611cb9565b61235d87601884611c96565b8352809250602084019350505061233b565b50601f1983820381018060051c85528260405261238e85603886611c96565b9350836020178652604081106123d757602085018186015b6001156123d45781518151835280825284820191506020830192508183106123ce57506123d4565b506123a6565b50505b5050505b50919050565b60006060905081518015831517156123f95750612440565b6124038482611cb9565b915080861661243e5761241760d882611cb9565b61242b6124248784611cb9565b84836122a1565b9250612438838684611c96565b87178452505b505b949350505050565b81600081146124c157600181146124d757600381146124ed5760208401845181018082146124a65761247981611c51565b6022825361248d8760d8602260f81b611c96565b60005261249d828460008a611d08565b93509450808253505b831581831017156124ba576124b9611c43565b5b50506124f9565b6124d0601060786058876123e1565b91506124f9565b6124e6600860b86098876123e1565b91506124f9565b6124f6846122ef565b91505b5092915050565b6000600260ff166007836000015116149050919050565b6060600061252e6125278461256b565b6003611c3c565b905080915050919050565b6060600060808360000151161461256657600061255f6125588461256b565b6001611c3c565b9050809150505b919050565b6000819050919050565b60606000600967ffffffffffffffff811115612594576125936139f9565b5b6040519080825280602002602001820160405280156125c757816020015b60608152602001906001900390816125b25790505b5090506125d78360800151612f09565b816000815181106125eb576125ea614324565b5b60200260200101819052506126038360400151612f09565b8160018151811061261757612616614324565b5b602002602001018190525061262f8360200151612f09565b8160028151811061264357612642614324565b5b6020026020010181905250600073ffffffffffffffffffffffffffffffffffffffff16836000015173ffffffffffffffffffffffffffffffffffffffff16036126c25761269e60405180602001604052806000815250612f23565b816003815181106126b2576126b1614324565b5b60200260200101819052506126ef565b6126cf8360000151612fa1565b816003815181106126e3576126e2614324565b5b60200260200101819052505b6126fc8360600151612f09565b816004815181106127105761270f614324565b5b60200260200101819052506127288360a00151612f23565b8160058151811061273c5761273b614324565b5b60200260200101819052506127548360c00151612f09565b8160068151811061276857612767614324565b5b602002602001018190525061278b60405180602001604052806000815250612f23565b8160078151811061279f5761279e614324565b5b60200260200101819052506127c260405180602001604052806000815250612f23565b816008815181106127d6576127d5614324565b5b60200260200101819052506127ea81612fd2565b915050919050565b60606000612844600060019054906101000a900460801b6040518060400160405280601281526020017f6f7261636c653a76303a706b7365637265740000000000000000000000000000815250613016565b90508091505090565b6060600080634010000173ffffffffffffffffffffffffffffffffffffffff1686868660405160200161288293929190614d86565b60405160208183030381529060405260405161289e91906146f3565b6000604051808303816000865af19150503d80600081146128db576040519150601f19603f3d011682016040523d82523d6000602084013e6128e0565b606091505b50915091508161292d576340100001816040517f75fff4670000000000000000000000000000000000000000000000000000000081526004016129249291906143bf565b60405180910390fd5b80806020019051810190612941919061477a565b925050509392505050565b6060612956610e77565b61295f57600080fd5b600080634010000373ffffffffffffffffffffffffffffffffffffffff1686868660405160200161299293929190614dd2565b6040516020818303038152906040526040516129ae91906146f3565b6000604051808303816000865af19150503d80600081146129eb576040519150601f19603f3d011682016040523d82523d6000602084013e6129f0565b606091505b509150915081612a3d576340100003816040517f75fff467000000000000000000000000000000000000000000000000000000008152600401612a349291906143bf565b60405180910390fd5b80806020019051810190612a51919061477a565b925050509392505050565b600080600080612a6b856130ff565b92509250925060018682858560405160008152602001604052604051612a949493929190614e26565b6020604051602081039080840390855afa158015612ab6573d6000803e3d6000fd5b50505060206040510351935050505092915050565b612ad3613964565b600080634203000073ffffffffffffffffffffffffffffffffffffffff1687878787604051602001612b089493929190614f38565b604051602081830303815290604052604051612b2491906146f3565b6000604051808303816000865af19150503d8060008114612b61576040519150601f19603f3d011682016040523d82523d6000602084013e612b66565b606091505b509150915081612bb3576342030000816040517f75fff467000000000000000000000000000000000000000000000000000000008152600401612baa9291906143bf565b60405180910390fd5b80806020019051810190612bc79190615197565b92505050949350505050565b600080634202000073ffffffffffffffffffffffffffffffffffffffff16858585604051602001612c06939291906151e0565b604051602081830303815290604052604051612c2291906146f3565b6000604051808303816000865af19150503d8060008114612c5f576040519150601f19603f3d011682016040523d82523d6000602084013e612c64565b606091505b509150915081612cb1576342020000816040517f75fff467000000000000000000000000000000000000000000000000000000008152600401612ca89291906143bf565b60405180910390fd5b5050505050565b6000612cc382610fc5565b604051602001612cd391906152bd565b6040516020818303038152906040529050600080634210000073ffffffffffffffffffffffffffffffffffffffff1683604051602001612d139190613cf1565b604051602081830303815290604052604051612d2f91906146f3565b600060405180830381855afa9150503d8060008114612d6a576040519150601f19603f3d011682016040523d82523d6000602084013e612d6f565b606091505b5091509150612d9d8282604051602001612d899190615336565b604051602081830303815290604052610f41565b50505050565b6000600167ffffffffffffffff811115612dc057612dbf6139f9565b5b604051908082528060200260200182016040528015612df357816020015b6060815260200190600190039081612dde5790505b5090508281600081518110612e0b57612e0a614324565b5b60200260200101819052506000612e2c828467ffffffffffffffff16613183565b9050600080634300000173ffffffffffffffffffffffffffffffffffffffff1660405180606001604052806023815260200161599f6023913984604051602001612e779291906153a4565b604051602081830303815290604052604051612e9391906146f3565b600060405180830381855afa9150503d8060008114612ece576040519150601f19603f3d011682016040523d82523d6000602084013e612ed3565b606091505b5091509150612f018282604051602001612eed919061543a565b604051602081830303815290604052610f41565b505050505050565b6060612f1c612f17836132a2565b612f23565b9050919050565b60608060018351148015612f5b5750608083600081518110612f4857612f47614324565b5b602001015160f81c60f81b60f81c60ff16105b15612f6857829050612f98565b612f7483516080613425565b83604051602001612f8692919061545c565b60405160208183030381529060405290505b80915050919050565b6060612fcb82604051602001612fb791906154c8565b604051602081830303815290604052612f23565b9050919050565b60606000612fdf83613671565b9050612fed815160c0613425565b81604051602001612fff92919061545c565b604051602081830303815290604052915050919050565b6060600080634202000173ffffffffffffffffffffffffffffffffffffffff1685856040516020016130499291906154e3565b60405160208183030381529060405260405161306591906146f3565b6000604051808303816000865af19150503d80600081146130a2576040519150601f19603f3d011682016040523d82523d6000602084013e6130a7565b606091505b5091509150816130f4576342020001816040517f75fff4670000000000000000000000000000000000000000000000000000000081526004016130eb9291906143bf565b60405180910390fd5b809250505092915050565b60008060006041845114613148576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161313f9061555f565b60405180910390fd5b6020840151925060408401519150606084015160001a9050601b8160ff16101561317c57601b81613179919061557f565b90505b9193909250565b6060600061319083613803565b6040516020016131a0919061564e565b604051602081830303815290604052905060005b845181101561327557816131e18683815181106131d4576131d3614324565b5b6020026020010151610fc5565b6040516020016131f29291906156c7565b6040516020818303038152906040529150600185516132119190614882565b81101561323f5781604051602001613229919061574d565b6040516020818303038152906040529150613262565b8160405160200161325091906157bb565b60405160208183030381529060405291505b808061326d906148b6565b9150506131b4565b50806040516020016132879190615829565b60405160208183030381529060405290508091505092915050565b60606000826040516020016132b7919061586c565b604051602081830303815290604052905060005b602081101561333157600060f81b8282815181106132ec576132eb614324565b5b602001015160f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191603613331578080613329906148b6565b9150506132cb565b60008160206133409190614882565b67ffffffffffffffff811115613359576133586139f9565b5b6040519080825280601f01601f19166020018201604052801561338b5781602001600182028036833780820191505090505b50905060005b8151811015613419578383806133a6906148b6565b9450815181106133b9576133b8614324565b5b602001015160f81c60f81b8282815181106133d7576133d6614324565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a9053508080613411906148b6565b915050613391565b50809350505050919050565b60608060388410156134d857600167ffffffffffffffff81111561344c5761344b6139f9565b5b6040519080825280601f01601f19166020018201604052801561347e5781602001600182028036833780820191505090505b509050828461348d919061557f565b60f81b816000815181106134a4576134a3614324565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a905350613667565b600080600190505b600081876134ee91906158b6565b146135165781806134fe906148b6565b9250506101008161350f9190614932565b90506134e0565b600182613523919061498c565b67ffffffffffffffff81111561353c5761353b6139f9565b5b6040519080825280601f01601f19166020018201604052801561356e5781602001600182028036833780820191505090505b5092506037858361357f919061557f565b613589919061557f565b60f81b836000815181106135a05761359f614324565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a905350600190505b8181116136645761010081836135ea9190614882565b6101006135f791906158e7565b8761360291906158b6565b61360c9190615932565b60f81b83828151811061362257613621614324565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a905350808061365c906148b6565b9150506135d4565b50505b8091505092915050565b606060008251036136d157600067ffffffffffffffff811115613697576136966139f9565b5b6040519080825280601f01601f1916602001820160405280156136c95781602001600182028036833780820191505090505b5090506137fe565b600080600090505b835181101561371e578381815181106136f5576136f4614324565b5b60200260200101515182613709919061498c565b91508080613716906148b6565b9150506136d9565b60008267ffffffffffffffff81111561373a576137396139f9565b5b6040519080825280601f01601f19166020018201604052801561376c5781602001600182028036833780820191505090505b5090506000602082019050600092505b85518310156137f657600086848151811061379a57613799614324565b5b6020026020010151905060006020820190506137b883828451613829565b8785815181106137cb576137ca614324565b5b602002602001015151836137df919061498c565b9250505082806137ee906148b6565b93505061377c565b819450505050505b919050565b606061380e8261389f565b90506002815101613078825260028203915080825250919050565b6000839050600083905060008390505b602081106138775781518352602083613852919061498c565b9250602082613861919061498c565b91506020816138709190614882565b9050613839565b60006001826020036101000a0390508019835116818551168181178652505050505050505050565b606060806040510190506020810160405260008152806f30313233343536373839616263646566600f52600119835b6001156138fa578184019350600f8116516001850153600f8160041c165184538060081c9050806138ce575b50828203602084039350808452505050919050565b6040518060c0016040528060608152602001606081526020016060815260200160608152602001600015158152602001600067ffffffffffffffff1681525090565b6040518060200160405280600081525090565b6040518060c0016040528060006fffffffffffffffffffffffffffffffff1916815260200160006fffffffffffffffffffffffffffffffff19168152602001600067ffffffffffffffff1681526020016060815260200160608152602001606081525090565b6000604051905090565b600080fd5b600080fd5b600080fd5b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b613a31826139e8565b810181811067ffffffffffffffff82111715613a5057613a4f6139f9565b5b80604052505050565b6000613a636139ca565b9050613a6f8282613a28565b919050565b600067ffffffffffffffff821115613a8f57613a8e6139f9565b5b613a98826139e8565b9050602081019050919050565b82818337600083830152505050565b6000613ac7613ac284613a74565b613a59565b905082815260208101848484011115613ae357613ae26139e3565b5b613aee848285613aa5565b509392505050565b600082601f830112613b0b57613b0a6139de565b5b8135613b1b848260208601613ab4565b91505092915050565b6000819050919050565b613b3781613b24565b8114613b4257600080fd5b50565b600081359050613b5481613b2e565b92915050565b600067ffffffffffffffff82169050919050565b613b7781613b5a565b8114613b8257600080fd5b50565b600081359050613b9481613b6e565b92915050565b60008115159050919050565b613baf81613b9a565b8114613bba57600080fd5b50565b600081359050613bcc81613ba6565b92915050565b600080600080600060a08688031215613bee57613bed6139d4565b5b600086013567ffffffffffffffff811115613c0c57613c0b6139d9565b5b613c1888828901613af6565b9550506020613c2988828901613b45565b9450506040613c3a88828901613b45565b9350506060613c4b88828901613b85565b9250506080613c5c88828901613bbd565b9150509295509295909350565b600081519050919050565b600082825260208201905092915050565b60005b83811015613ca3578082015181840152602081019050613c88565b83811115613cb2576000848401525b50505050565b6000613cc382613c69565b613ccd8185613c74565b9350613cdd818560208601613c85565b613ce6816139e8565b840191505092915050565b60006020820190508181036000830152613d0b8184613cb8565b905092915050565b600067ffffffffffffffff821115613d2e57613d2d6139f9565b5b613d37826139e8565b9050602081019050919050565b6000613d57613d5284613d13565b613a59565b905082815260208101848484011115613d7357613d726139e3565b5b613d7e848285613aa5565b509392505050565b600082601f830112613d9b57613d9a6139de565b5b8135613dab848260208601613d44565b91505092915050565b600060208284031215613dca57613dc96139d4565b5b600082013567ffffffffffffffff811115613de857613de76139d9565b5b613df484828501613d86565b91505092915050565b600081519050919050565b600082825260208201905092915050565b6000613e2482613dfd565b613e2e8185613e08565b9350613e3e818560208601613c85565b613e47816139e8565b840191505092915050565b60006020820190508181036000830152613e6c8184613e19565b905092915050565b600060ff82169050919050565b613e8a81613e74565b82525050565b6000602082019050613ea56000830184613e81565b92915050565b613eb481613b9a565b82525050565b6000602082019050613ecf6000830184613eab565b92915050565b600060208284031215613eeb57613eea6139d4565b5b600082013567ffffffffffffffff811115613f0957613f086139d9565b5b613f1584828501613af6565b91505092915050565b613f2781613b24565b82525050565b6000602082019050613f426000830184613f1e565b92915050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000613f7382613f48565b9050919050565b613f8381613f68565b8114613f8e57600080fd5b50565b600081359050613fa081613f7a565b92915050565b600060208284031215613fbc57613fbb6139d4565b5b6000613fca84828501613f91565b91505092915050565b60008060408385031215613fea57613fe96139d4565b5b6000613ff885828601613f91565b925050602083013567ffffffffffffffff811115614019576140186139d9565b5b61402585828601613d86565b9150509250929050565b60007fffffffffffffffffffffffffffffffff0000000000000000000000000000000082169050919050565b60006140668261402f565b9050919050565b6140768161405b565b82525050565b6000602082019050614091600083018461406d565b92915050565b6140a08161402f565b81146140ab57600080fd5b50565b6000813590506140bd81614097565b92915050565b600080604083850312156140da576140d96139d4565b5b60006140e8858286016140ae565b92505060206140f985828601613f91565b9150509250929050565b61410c81613f68565b82525050565b60006020820190506141276000830184614103565b92915050565b600080600060608486031215614146576141456139d4565b5b600084013567ffffffffffffffff811115614164576141636139d9565b5b61417086828701613af6565b935050602061418186828701613b45565b925050604084013567ffffffffffffffff8111156141a2576141a16139d9565b5b6141ae86828701613d86565b9150509250925092565b600060608201905081810360008301526141d28186613e19565b90506141e16020830185613f1e565b81810360408301526141f38184613cb8565b9050949350505050565b600081905092915050565b7f7b226a736f6e727063223a22322e30222c226d6574686f64223a226574685f7360008201527f656e645261775472616e73616374696f6e222c22706172616d73223a5b220000602082015250565b6000614264603e836141fd565b915061426f82614208565b603e82019050919050565b600061428582613dfd565b61428f81856141fd565b935061429f818560208601613c85565b80840191505092915050565b7f225d2c226964223a317d00000000000000000000000000000000000000000000600082015250565b60006142e1600a836141fd565b91506142ec826142ab565b600a82019050919050565b600061430282614257565b915061430e828461427a565b9150614319826142d4565b915081905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b7f416c726561647920726567697374657265640000000000000000000000000000600082015250565b6000614389601283613e08565b915061439482614353565b602082019050919050565b600060208201905081810360008301526143b88161437c565b9050919050565b60006040820190506143d46000830185614103565b81810360208301526143e68184613cb8565b90509392505050565b6000604082019050614404600083018561406d565b6144116020830184614103565b9392505050565b600060408201905081810360008301526144328185613e19565b90506144416020830184613f1e565b9392505050565b600081905092915050565b50565b6000614463600083614448565b915061446e82614453565b600082019050919050565b600061448482614456565b9150819050919050565b600082825260208201905092915050565b60006144aa82613dfd565b6144b4818561448e565b93506144c4818560208601613c85565b6144cd816139e8565b840191505092915050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b6000614510838361449f565b905092915050565b6000602082019050919050565b6000614530826144d8565b61453a81856144e3565b93508360208202850161454c856144f4565b8060005b8581101561458857848403895281516145698582614504565b945061457483614518565b925060208a01995050600181019050614550565b50829750879550505050505092915050565b600082825260208201905092915050565b60006145b682613c69565b6145c0818561459a565b93506145d0818560208601613c85565b6145d9816139e8565b840191505092915050565b6145ed81613b9a565b82525050565b6145fc81613b5a565b82525050565b600060c083016000830151848203600086015261461f828261449f565b91505060208301518482036020860152614639828261449f565b915050604083015184820360408601526146538282614525565b9150506060830151848203606086015261466d82826145ab565b915050608083015161468260808601826145e4565b5060a083015161469560a08601826145f3565b508091505092915050565b600060208201905081810360008301526146ba8184614602565b905092915050565b60006146cd82613c69565b6146d78185614448565b93506146e7818560208601613c85565b80840191505092915050565b60006146ff82846146c2565b915081905092915050565b600061471d61471884613d13565b613a59565b905082815260208101848484011115614739576147386139e3565b5b614744848285613c85565b509392505050565b600082601f830112614761576147606139de565b5b815161477184826020860161470a565b91505092915050565b6000602082840312156147905761478f6139d4565b5b600082015167ffffffffffffffff8111156147ae576147ad6139d9565b5b6147ba8482850161474c565b91505092915050565b60006147cf828561427a565b91506147db828461427a565b91508190509392505050565b7f496e70757420746f6f2073686f72740000000000000000000000000000000000600082015250565b600061481d600f83613e08565b9150614828826147e7565b602082019050919050565b6000602082019050818103600083015261484c81614810565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600061488d82613b24565b915061489883613b24565b9250828210156148ab576148aa614853565b5b828203905092915050565b60006148c182613b24565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82036148f3576148f2614853565b5b600182019050919050565b600061490982613e74565b915061491483613e74565b92508282101561492757614926614853565b5b828203905092915050565b600061493d82613b24565b915061494883613b24565b9250817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff048311821515161561498157614980614853565b5b828202905092915050565b600061499782613b24565b91506149a283613b24565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff038211156149d7576149d6614853565b5b828201905092915050565b60006149ed82613b24565b915060008203614a00576149ff614853565b5b600182039050919050565b60008160011c9050919050565b6000808291508390505b6001851115614a6257808604811115614a3e57614a3d614853565b5b6001851615614a4d5780820291505b8081029050614a5b85614a0b565b9450614a22565b94509492505050565b600082614a7b5760019050614b37565b81614a895760009050614b37565b8160018114614a9f5760028114614aa957614ad8565b6001915050614b37565b60ff841115614abb57614aba614853565b5b8360020a915084821115614ad257614ad1614853565b5b50614b37565b5060208310610133831016604e8410600b8410161715614b0d5782820a905083811115614b0857614b07614853565b5b614b37565b614b1a8484846001614a18565b92509050818404811115614b3157614b30614853565b5b81810290505b9392505050565b6000614b4982613b24565b9150614b5483613e74565b9250614b817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8484614a6b565b905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b60028110614bc957614bc8614b89565b5b50565b6000819050614bda82614bb8565b919050565b6000614bea82614bcc565b9050919050565b614bfa81614bdf565b82525050565b6000602082019050614c156000830184614bf1565b92915050565b6000614c2e614c2984613a74565b613a59565b905082815260208101848484011115614c4a57614c496139e3565b5b614c55848285613c85565b509392505050565b600082601f830112614c7257614c716139de565b5b8151614c82848260208601614c1b565b91505092915050565b600060208284031215614ca157614ca06139d4565b5b600082015167ffffffffffffffff811115614cbf57614cbe6139d9565b5b614ccb84828501614c5d565b91505092915050565b7f796f000000000000000000000000000000000000000000000000000000000000600082015250565b6000614d0a600283613e08565b9150614d1582614cd4565b602082019050919050565b60006020820190508181036000830152614d3981614cfd565b9050919050565b6000819050919050565b6000819050919050565b614d65614d6082614d40565b614d4a565b82525050565b6000614d778284614d54565b60208201915081905092915050565b60006060820190508181036000830152614da08186613cb8565b90508181036020830152614db48185613e19565b90508181036040830152614dc88184613e19565b9050949350505050565b60006060820190508181036000830152614dec8186613cb8565b9050614dfb6020830185614bf1565b8181036040830152614e0d8184613e19565b9050949350505050565b614e2081614d40565b82525050565b6000608082019050614e3b6000830187614e17565b614e486020830186613e81565b614e556040830185614e17565b614e626060830184614e17565b95945050505050565b614e7481613b5a565b82525050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b614eaf81613f68565b82525050565b6000614ec18383614ea6565b60208301905092915050565b6000602082019050919050565b6000614ee582614e7a565b614eef8185614e85565b9350614efa83614e96565b8060005b83811015614f2b578151614f128882614eb5565b9750614f1d83614ecd565b925050600181019050614efe565b5085935050505092915050565b6000608082019050614f4d6000830187614e6b565b8181036020830152614f5f8186614eda565b90508181036040830152614f738185614eda565b90508181036060830152614f878184613e19565b905095945050505050565b600080fd5b600080fd5b600081519050614fab81614097565b92915050565b600081519050614fc081613b6e565b92915050565b600067ffffffffffffffff821115614fe157614fe06139f9565b5b602082029050602081019050919050565b600080fd5b60008151905061500681613f7a565b92915050565b600061501f61501a84614fc6565b613a59565b9050808382526020820190506020840283018581111561504257615041614ff2565b5b835b8181101561506b57806150578882614ff7565b845260208401935050602081019050615044565b5050509392505050565b600082601f83011261508a576150896139de565b5b815161509a84826020860161500c565b91505092915050565b600060c082840312156150b9576150b8614f92565b5b6150c360c0613a59565b905060006150d384828501614f9c565b60008301525060206150e784828501614f9c565b60208301525060406150fb84828501614fb1565b604083015250606082015167ffffffffffffffff81111561511f5761511e614f97565b5b61512b84828501615075565b606083015250608082015167ffffffffffffffff81111561514f5761514e614f97565b5b61515b84828501615075565b60808301525060a082015167ffffffffffffffff81111561517f5761517e614f97565b5b61518b84828501614c5d565b60a08301525092915050565b6000602082840312156151ad576151ac6139d4565b5b600082015167ffffffffffffffff8111156151cb576151ca6139d9565b5b6151d7848285016150a3565b91505092915050565b60006060820190506151f5600083018661406d565b81810360208301526152078185613e19565b9050818103604083015261521b8184613cb8565b9050949350505050565b7f7b22747873223a205b2200000000000000000000000000000000000000000000600082015250565b600061525b600a836141fd565b915061526682615225565b600a82019050919050565b7f225d7d0000000000000000000000000000000000000000000000000000000000600082015250565b60006152a76003836141fd565b91506152b282615271565b600382019050919050565b60006152c88261524e565b91506152d4828461427a565b91506152df8261529a565b915081905092915050565b7f42756e646c6553696d756c6174696f6e4661696c65643a200000000000000000600082015250565b60006153206018836141fd565b915061532b826152ea565b601882019050919050565b600061534182615313565b915061534d828461427a565b915081905092915050565b7f6574685f73656e6442756e646c65000000000000000000000000000000000000600082015250565b600061538e600e83613e08565b915061539982615358565b602082019050919050565b600060608201905081810360008301526153be8185613e19565b905081810360208301526153d181615381565b905081810360408301526153e58184613cb8565b90509392505050565b7f42756e646c655375626d697373696f6e4661696c65643a200000000000000000600082015250565b60006154246018836141fd565b915061542f826153ee565b601882019050919050565b600061544582615417565b9150615451828461427a565b915081905092915050565b600061546882856146c2565b915061547482846146c2565b91508190509392505050565b60008160601b9050919050565b600061549882615480565b9050919050565b60006154aa8261548d565b9050919050565b6154c26154bd82613f68565b61549f565b82525050565b60006154d482846154b1565b60148201915081905092915050565b60006040820190506154f8600083018561406d565b818103602083015261550a8184613e19565b90509392505050565b7f696e76616c6964207369676e6174757265206c656e6774680000000000000000600082015250565b6000615549601883613e08565b915061555482615513565b602082019050919050565b600060208201905081810360008301526155788161553c565b9050919050565b600061558a82613e74565b915061559583613e74565b92508260ff038211156155ab576155aa614853565b5b828201905092915050565b7f7b22626c6f636b4e756d626572223a2022000000000000000000000000000000600082015250565b60006155ec6011836141fd565b91506155f7826155b6565b601182019050919050565b7f222c2022747873223a205b000000000000000000000000000000000000000000600082015250565b6000615638600b836141fd565b915061564382615602565b600b82019050919050565b6000615659826155df565b9150615665828461427a565b91506156708261562b565b915081905092915050565b7f2200000000000000000000000000000000000000000000000000000000000000600082015250565b60006156b16001836141fd565b91506156bc8261567b565b600182019050919050565b60006156d382856146c2565b91506156de826156a4565b91506156ea828461427a565b91506156f5826156a4565b91508190509392505050565b7f2c00000000000000000000000000000000000000000000000000000000000000600082015250565b60006157376001836141fd565b915061574282615701565b600182019050919050565b600061575982846146c2565b91506157648261572a565b915081905092915050565b7f5d00000000000000000000000000000000000000000000000000000000000000600082015250565b60006157a56001836141fd565b91506157b08261576f565b600182019050919050565b60006157c782846146c2565b91506157d282615798565b915081905092915050565b7f7d00000000000000000000000000000000000000000000000000000000000000600082015250565b60006158136001836141fd565b915061581e826157dd565b600182019050919050565b600061583582846146c2565b915061584082615806565b915081905092915050565b6000819050919050565b61586661586182613b24565b61584b565b82525050565b60006158788284615855565b60208201915081905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b60006158c182613b24565b91506158cc83613b24565b9250826158dc576158db615887565b5b828204905092915050565b60006158f282613b24565b91506158fd83613b24565b925061592a7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8484614a6b565b905092915050565b600061593d82613b24565b915061594883613b24565b92508261595857615957615887565b5b82820690509291505056fe68747470733a2f2f646174612d6170692e62696e616e63652e766973696f6e2f6170692f76332f7469636b65722f70726963653f73796d626f6c3d68747470733a2f2f72656c61792d686f6c65736b792e666c617368626f74732e6e6574a2646970667358221220e2c46906cce60f1d6bcb29686bcf9b4d93a98474e54cf7ad972468efca1e108e64736f6c634300080d0033",
  "deployedBytecode": "0x6080604052600436106101185760003560e01c80639829ba42116100a0578063e0a388fb11610064578063e0a388fb146103bb578063e2411625146103e6578063ea42418b1461040f578063f77c47911461043a578063fdd13fe71461046557610119565b80639829ba42146102e65780639893306514610311578063b72a65401461033a578063d3596e7f14610365578063d86cd69a1461039057610119565b80632e0f2625116100e75780632e0f2625146101eb578063392e53cd14610216578063507235531461024157806357e3c1b51461027e5780637e48532c146102bb57610119565b80630de8cb931461011b5780631d148b8d1461015857806323b17abc146101955780632bc361db146101c057610119565b5b005b34801561012757600080fd5b50610142600480360381019061013d9190613bd2565b61048e565b60405161014f9190613cf1565b60405180910390f35b34801561016457600080fd5b5061017f600480360381019061017a9190613db4565b61057c565b60405161018c9190613cf1565b60405180910390f35b3480156101a157600080fd5b506101aa61072c565b6040516101b79190613e52565b60405180910390f35b3480156101cc57600080fd5b506101d5610748565b6040516101e29190613e52565b60405180910390f35b3480156101f757600080fd5b50610200610781565b60405161020d9190613e90565b60405180910390f35b34801561022257600080fd5b5061022b610786565b6040516102389190613eba565b60405180910390f35b34801561024d57600080fd5b5061026860048036038101906102639190613ed5565b610797565b6040516102759190613f2d565b60405180910390f35b34801561028a57600080fd5b506102a560048036038101906102a09190613fa6565b610823565b6040516102b29190613cf1565b60405180910390f35b3480156102c757600080fd5b506102d06109ef565b6040516102dd9190613cf1565b60405180910390f35b3480156102f257600080fd5b506102fb610b2c565b6040516103089190613e52565b60405180910390f35b34801561031d57600080fd5b5061033860048036038101906103339190613fd3565b610b65565b005b34801561034657600080fd5b5061034f610c72565b60405161035c9190613e52565b60405180910390f35b34801561037157600080fd5b5061037a610c8e565b604051610387919061407c565b60405180910390f35b34801561039c57600080fd5b506103a5610ca1565b6040516103b29190613e52565b60405180910390f35b3480156103c757600080fd5b506103d0610cda565b6040516103dd9190613f2d565b60405180910390f35b3480156103f257600080fd5b5061040d600480360381019061040891906140c3565b610ce0565b005b34801561041b57600080fd5b50610424610db6565b6040516104319190614112565b60405180910390f35b34801561044657600080fd5b5061044f610ddc565b60405161045c9190614112565b60405180910390f35b34801561047157600080fd5b5061048c6004803603810190610487919061412d565b610e02565b005b60606104d661049b610e77565b6040518060400160405280601081526020017f4e6f7420636f6e666964656e7469616c00000000000000000000000000000000815250610f41565b60006104e187610797565b905060006104f3888389898989610f87565b905063fdd13fe760e01b888383604051602401610512939291906141b8565b604051602081830303815290604052907bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff83818316178352505050509250505095945050505050565b6060600061058983610fc5565b60405160200161059991906142f7565b60405160208183030381529060405290506105b261390f565b6040518060400160405280600481526020017f504f5354000000000000000000000000000000000000000000000000000000008152508160200181905250818160600181905250600167ffffffffffffffff811115610614576106136139f9565b5b60405190808252806020026020018201604052801561064757816020015b60608152602001906001900390816106325790505b5081604001819052506040518060400160405280601e81526020017f436f6e74656e742d547970653a206170706c69636174696f6e2f6a736f6e0000815250816040015160008151811061069e5761069d614324565b5b602002602001018190525060008160800190151590811515815250506040518060400160405280600781526020017f686f6c65736b790000000000000000000000000000000000000000000000000081525081600001819052506127108160a0019067ffffffffffffffff16908167ffffffffffffffff168152505061072381610feb565b92505050919050565b60405180606001604052806023815260200161599f6023913981565b6040518060400160405280600781526020017f686f6c65736b790000000000000000000000000000000000000000000000000081525081565b600481565b60008054906101000a900460ff1681565b6000806107a3836110a4565b905060006107b08261125b565b905060006108046107ff6040518060400160405280600781526020017f22707269636522000000000000000000000000000000000000000000000000008152508461128790919063ffffffff16565b61130a565b90506108196108128261132c565b60046113f9565b9350505050919050565b606061086b610830610e77565b6040518060400160405280601081526020017f4e6f7420636f6e666964656e7469616c00000000000000000000000000000000815250610f41565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff1614806109155750600073ffffffffffffffffffffffffffffffffffffffff16600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16145b610954576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161094b9061439f565b60405180910390fd5b600061095f836115c0565b9050600061096c8261057c565b9050639893306560e01b84826040516024016109899291906143bf565b604051602081830303815290604052907bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff838183161783525050505092505050919050565b6060610a376109fc610e77565b6040518060400160405280601081526020017f4e6f7420636f6e666964656e7469616c00000000000000000000000000000000815250610f41565b610a8460008054906101000a900460ff16156040518060400160405280601381526020017f416c726561647920696e697469616c697a656400000000000000000000000000815250610f41565b6000610a906000611700565b90506000610a9d826117f9565b90506000610aaa83611865565b905063e241162560e01b8183604051602401610ac79291906143ef565b604051602081830303815290604052907bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff8381831617835250505050935050505090565b6040518060400160405280601281526020017f6f7261636c653a76303a706b736563726574000000000000000000000000000081525081565b600073ffffffffffffffffffffffffffffffffffffffff16600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1614610bf6576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610bed9061439f565b60405180910390fd5b81600260006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055507fa93bc9ff6ba5c181f59d418898928cae5d5f4c5ecc1003043191481dd769d4cc81604051610c669190613cf1565b60405180910390a15050565b6040518060600160405280603b8152602001615964603b913981565b600060019054906101000a900460801b81565b6040518060400160405280600681526020017f307834323638000000000000000000000000000000000000000000000000000081525081565b61426881565b610d2d60008054906101000a900460ff16156040518060400160405280601381526020017f416c726561647920696e697469616c697a656400000000000000000000000000815250610f41565b81600060016101000a8154816fffffffffffffffffffffffffffffffff021916908360801c021790555080600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060016000806101000a81548160ff0219169083151502179055505050565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b7ff61f2fd6ab65716facd3516c91d806d98dffa9670f127beac522f8cacfd1d8df8383604051610e33929190614418565b60405180910390a17fa93bc9ff6ba5c181f59d418898928cae5d5f4c5ecc1003043191481dd769d4cc81604051610e6a9190613cf1565b60405180910390a1505050565b6000806000634201000073ffffffffffffffffffffffffffffffffffffffff16604051610ea390614479565b6000604051808303816000865af19150503d8060008114610ee0576040519150601f19603f3d011682016040523d82523d6000602084013e610ee5565b606091505b509150915081610f32576342010000816040517f75fff467000000000000000000000000000000000000000000000000000000008152600401610f299291906143bf565b60405180910390fd5b80516020820151935050505090565b81610f8357806040517f0c25cd98000000000000000000000000000000000000000000000000000000008152600401610f7a9190613e52565b60405180910390fd5b5050565b60606000610f9788888888611a41565b90508215610fae57610fa98185611bad565b610fba565b610fb78161057c565b91505b509695505050505050565b6060610fd082611bc4565b90506002815101613078825260028203915080825250919050565b6060600080634320000273ffffffffffffffffffffffffffffffffffffffff168460405160200161101c91906146a0565b60405160208183030381529060405260405161103891906146f3565b600060405180830381855afa9150503d8060008114611073576040519150601f19603f3d011682016040523d82523d6000602084013e611078565b606091505b50915091506110878282610f41565b8080602001905181019061109b919061477a565b92505050919050565b60606000600167ffffffffffffffff8111156110c3576110c26139f9565b5b6040519080825280602002602001820160405280156110f657816020015b60608152602001906001900390816110e15790505b5090506040518060400160405280601e81526020017f436f6e74656e742d547970653a206170706c69636174696f6e2f6a736f6e00008152508160008151811061114357611142614324565b5b602002602001018190525060006040518060c001604052806040518060600160405280603b8152602001615964603b9139866040516020016111869291906147c3565b60405160208183030381529060405281526020016040518060400160405280600381526020017f47455400000000000000000000000000000000000000000000000000000000008152508152602001838152602001600067ffffffffffffffff8111156111f6576111f56139f9565b5b6040519080825280601f01601f1916602001820160405280156112285781602001600182028036833780820191505090505b50815260200160001515815260200161271067ffffffffffffffff16815250905061125281610feb565b92505050919050565b611263613951565b80604052600061127c61127584611c32565b60ff611c3c565b905080915050919050565b61128f613951565b80604052606090506112a083612500565b156113045760008280519060200120905060006112bc85612517565b9050600060058251901b90505b6000811461130057808201519550602081039050826112e787612539565b80519060200120036112fb57859350611300565b6112c9565b5050505b92915050565b6060600061132161131a8461256b565b6000611c3c565b905080915050919050565b606060008290506002815111611377576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161136e90614833565b60405180910390fd5b6000600282516113879190614882565b905060008167ffffffffffffffff8111156113a5576113a46139f9565b5b6040519080825280601f01601f1916602001820160405280156113d75781602001600182028036833780820191505090505b5090506021830160208201845182518252848452505050809350505050919050565b600080839050600080600090505b825181101561147557602e60f81b83828151811061142857611427614324565b5b602001015160f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff19160361146257809150611475565b808061146d906148b6565b915050611407565b5060008060006001905060008490505b6000811115611504578160308760018461149f9190614882565b815181106114b0576114af614324565b5b602001015160f81c60f81b60f81c6114c891906148fe565b60ff166114d59190614932565b846114e0919061498c565b9350600a826114ef9190614932565b915080806114fc906149e2565b915050611485565b506001905060008760ff168561151a919061498c565b90505b8481111561158f5781603087838151811061153b5761153a614324565b5b602001015160f81c60f81b60f81c61155391906148fe565b60ff166115609190614932565b8361156b919061498c565b9250600a8261157a9190614932565b91508080611587906149e2565b91505061151d565b508187600a61159e9190614b3e565b846115a99190614932565b6115b3919061498c565b9550505050505092915050565b606060006040518060e001604052808473ffffffffffffffffffffffffffffffffffffffff168152602001620186a0815260200164174876e800815260200160008152602001600081526020016040516024016040516020818303038152906040527f1aa3a008000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff83818316178352505050508152602001614268815250905060006116a882612575565b905060006116b46127f2565b90506116f6826040518060400160405280600681526020017f30783432363800000000000000000000000000000000000000000000000000008152508361284d565b9350505050919050565b6060600080635320000373ffffffffffffffffffffffffffffffffffffffff16846040516020016117319190614c00565b60405160208183030381529060405260405161174d91906146f3565b6000604051808303816000865af19150503d806000811461178a576040519150601f19603f3d011682016040523d82523d6000602084013e61178f565b606091505b5091509150816117dc576353200003816040517f75fff4670000000000000000000000000000000000000000000000000000000081526004016117d39291906143bf565b60405180910390fd5b808060200190518101906117f09190614c8b565b92505050919050565b60008060405160200161180b90614d20565b6040516020818303038152906040528051906020012090506000611850826040516020016118399190614d6b565b60405160208183030381529060405260008661294c565b905061185c8282612a5c565b92505050919050565b600080600367ffffffffffffffff811115611883576118826139f9565b5b6040519080825280602002602001820160405280156118b15781602001602082028036833780820191505090505b50905030816000815181106118c9576118c8614324565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff168152505063420300018160018151811061191c5761191b614324565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff168152505063420200018160028151811061196f5761196e614324565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff168152505060006119ed600083846040518060400160405280601281526020017f6f7261636c653a76303a706b7365637265740000000000000000000000000000815250612acb565b9050611a3381600001516040518060400160405280601281526020017f6f7261636c653a76303a706b736563726574000000000000000000000000000081525086612bd3565b806000015192505050919050565b606060006040518060e00160405280600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001620186a08152602001848152602001600081526020018581526020018787604051602401611abd929190614418565b6040516020818303038152906040527f4a432a46000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff8381831617835250505050815260200161426881525090506000611b5282612575565b90506000611b5e6127f2565b9050611ba0826040518060400160405280600681526020017f30783432363800000000000000000000000000000000000000000000000000008152508361284d565b9350505050949350505050565b611bb682612cb8565b611bc08282612da3565b5050565b60608151600260405101915080810182526f30313233343536373839616263646566600f52602082018184015b808514611c1f57600185019450600f855116516001830153600f855160041c16518253600282019150611bf1565b6000825260208201604052505050919050565b6000819050919050565b6000612448565b63101827966000526004601cfd5b6000815160001a9050919050565b60008190505b600115611c8f576001640100002600611c7d83611c51565b1c1615611c9057600181019050611c65565b5b92915050565b600063ffffffff84113d3d3e83831b8263ffffffff851b19161790509392505050565b600081831c63ffffffff16905092915050565b60006040519050611cf18486036078611cec602086018803605888611c96565b611c96565b925085831781526020810160405295945050505050565b600080611d19846018600051611c96565b611d238787611c5f565b9150868210611d325750611e85565b611d3b82611c51565b600115611e765760228103611d6f5782611d57898585896120c7565b9350611d6760048583868a611ccc565b945050611e76565b605b8103611d8c57611d8388848488611e8e565b93509350611e76565b607b8103611da957611da088848488611f66565b93509350611e76565b6001611ff9602d1b821c1615611dce57611dc5888484886121d6565b93509350611e76565b876004840111611e315782835160e01c63747275658103611e0657600485019450611dfd60058684878b611ccc565b95505050611e76565b636e756c6c8103611e2e57600485019450611e2560068684878b611ccc565b95505050611e76565b50505b876005840111611e6d5782835160d81c6466616c73658103611e6a57600585019450611e6160058684878b611ccc565b95505050611e76565b50505b611e75611c43565b5b50611e818783611c5f565b9150505b94509492505050565b60008060006001860191505b600115611f3857868210611eb157611eb0611c43565b5b82611ed457611ec08783611c5f565b9150605d611ecd83611c51565b0315611f38575b611ee087838587611d08565b925092508215611f2957611efa8160988551604017611c96565b8352600181019050611f0b82611c51565b605d8103611f195750611f38565b602c8103611f275750611f2d565b505b8691505b600182019150611e9a565b600182019150611f4a83603887611c96565b9450611f5a600183888888611ccc565b92505094509492505050565b6000806001850190505b60011561205957858110611f8757611f86611c43565b5b81611faa57611f968682611c5f565b9050607d611fa382611c51565b0315612059575b611fb48682611c5f565b905080611fc3878385876120c7565b611fcd8882611c5f565b9250603a611fda84611c51565b0361204857611fee88600185018688611d08565b9350935083156120475761201a602086018303609861201585850360b88951608017611c96565b611c96565b845261202583611c51565b607d810361203557505050612059565b602c81036120455750505061204e565b505b5b87925050505b600181019050611f70565b60018101905061206b82603886611c96565b935061207b600282878787611ccc565b915094509492505050565b6001667e0000007e03ff603061209d858501611c51565b031c166120ad576120ac611c43565b5b600582146120c3576120c26001830182612086565b5b5050565b60008484106120d9576120d8611c43565b5b6001840190505b600115612172576120f081611c51565b602281036120fe5750612172565b605c8114612112576001820191505061216d565b61211e60018301611c51565b905060016a0510110400000000002001602283031c1615612145576002820191505061216d565b6075810361216457612158600283612086565b6006820191505061216d565b85915050612172565b6120e0565b84811061218257612181611c43565b5b600181019050949350505050565b60008190505b6001156121bc57600a60306121aa83611c51565b0310156121bc57600181019050612196565b8082148416156121cf576121ce611c43565b5b9392505050565b600080849050602d6121e782611c51565b036121f3576001810190505b600a603061220083611c51565b031061220f5761220e611c43565b5b61221881611c51565b600182019150603081146122355761223260008884612190565b91505b602e61224083611c51565b036122575761225460018860018501612190565b91505b815160658160001a60201703612286576122836001896001860162010001600e8660011a031a01612190565b92505b612294600384898989611ccc565b9350505094509492505050565b600060405190508282019150601f1980601f8601165b6001156122d15780840151818401528181019050806122b7575b50848252600085602084010152846040830101604052509392505050565b6000606090508151600281600716116123db5782158115176123db5760208116156123265761231f603882611cb9565b91506123db565b60405191506020820161233a603883611cb9565b5b801561236f578082528051612351601882611cb9565b61235d87601884611c96565b8352809250602084019350505061233b565b50601f1983820381018060051c85528260405261238e85603886611c96565b9350836020178652604081106123d757602085018186015b6001156123d45781518151835280825284820191506020830192508183106123ce57506123d4565b506123a6565b50505b5050505b50919050565b60006060905081518015831517156123f95750612440565b6124038482611cb9565b915080861661243e5761241760d882611cb9565b61242b6124248784611cb9565b84836122a1565b9250612438838684611c96565b87178452505b505b949350505050565b81600081146124c157600181146124d757600381146124ed5760208401845181018082146124a65761247981611c51565b6022825361248d8760d8602260f81b611c96565b60005261249d828460008a611d08565b93509450808253505b831581831017156124ba576124b9611c43565b5b50506124f9565b6124d0601060786058876123e1565b91506124f9565b6124e6600860b86098876123e1565b91506124f9565b6124f6846122ef565b91505b5092915050565b6000600260ff166007836000015116149050919050565b6060600061252e6125278461256b565b6003611c3c565b905080915050919050565b6060600060808360000151161461256657600061255f6125588461256b565b6001611c3c565b9050809150505b919050565b6000819050919050565b60606000600967ffffffffffffffff811115612594576125936139f9565b5b6040519080825280602002602001820160405280156125c757816020015b60608152602001906001900390816125b25790505b5090506125d78360800151612f09565b816000815181106125eb576125ea614324565b5b60200260200101819052506126038360400151612f09565b8160018151811061261757612616614324565b5b602002602001018190525061262f8360200151612f09565b8160028151811061264357612642614324565b5b6020026020010181905250600073ffffffffffffffffffffffffffffffffffffffff16836000015173ffffffffffffffffffffffffffffffffffffffff16036126c25761269e60405180602001604052806000815250612f23565b816003815181106126b2576126b1614324565b5b60200260200101819052506126ef565b6126cf8360000151612fa1565b816003815181106126e3576126e2614324565b5b60200260200101819052505b6126fc8360600151612f09565b816004815181106127105761270f614324565b5b60200260200101819052506127288360a00151612f23565b8160058151811061273c5761273b614324565b5b60200260200101819052506127548360c00151612f09565b8160068151811061276857612767614324565b5b602002602001018190525061278b60405180602001604052806000815250612f23565b8160078151811061279f5761279e614324565b5b60200260200101819052506127c260405180602001604052806000815250612f23565b816008815181106127d6576127d5614324565b5b60200260200101819052506127ea81612fd2565b915050919050565b60606000612844600060019054906101000a900460801b6040518060400160405280601281526020017f6f7261636c653a76303a706b7365637265740000000000000000000000000000815250613016565b90508091505090565b6060600080634010000173ffffffffffffffffffffffffffffffffffffffff1686868660405160200161288293929190614d86565b60405160208183030381529060405260405161289e91906146f3565b6000604051808303816000865af19150503d80600081146128db576040519150601f19603f3d011682016040523d82523d6000602084013e6128e0565b606091505b50915091508161292d576340100001816040517f75fff4670000000000000000000000000000000000000000000000000000000081526004016129249291906143bf565b60405180910390fd5b80806020019051810190612941919061477a565b925050509392505050565b6060612956610e77565b61295f57600080fd5b600080634010000373ffffffffffffffffffffffffffffffffffffffff1686868660405160200161299293929190614dd2565b6040516020818303038152906040526040516129ae91906146f3565b6000604051808303816000865af19150503d80600081146129eb576040519150601f19603f3d011682016040523d82523d6000602084013e6129f0565b606091505b509150915081612a3d576340100003816040517f75fff467000000000000000000000000000000000000000000000000000000008152600401612a349291906143bf565b60405180910390fd5b80806020019051810190612a51919061477a565b925050509392505050565b600080600080612a6b856130ff565b92509250925060018682858560405160008152602001604052604051612a949493929190614e26565b6020604051602081039080840390855afa158015612ab6573d6000803e3d6000fd5b50505060206040510351935050505092915050565b612ad3613964565b600080634203000073ffffffffffffffffffffffffffffffffffffffff1687878787604051602001612b089493929190614f38565b604051602081830303815290604052604051612b2491906146f3565b6000604051808303816000865af19150503d8060008114612b61576040519150601f19603f3d011682016040523d82523d6000602084013e612b66565b606091505b509150915081612bb3576342030000816040517f75fff467000000000000000000000000000000000000000000000000000000008152600401612baa9291906143bf565b60405180910390fd5b80806020019051810190612bc79190615197565b92505050949350505050565b600080634202000073ffffffffffffffffffffffffffffffffffffffff16858585604051602001612c06939291906151e0565b604051602081830303815290604052604051612c2291906146f3565b6000604051808303816000865af19150503d8060008114612c5f576040519150601f19603f3d011682016040523d82523d6000602084013e612c64565b606091505b509150915081612cb1576342020000816040517f75fff467000000000000000000000000000000000000000000000000000000008152600401612ca89291906143bf565b60405180910390fd5b5050505050565b6000612cc382610fc5565b604051602001612cd391906152bd565b6040516020818303038152906040529050600080634210000073ffffffffffffffffffffffffffffffffffffffff1683604051602001612d139190613cf1565b604051602081830303815290604052604051612d2f91906146f3565b600060405180830381855afa9150503d8060008114612d6a576040519150601f19603f3d011682016040523d82523d6000602084013e612d6f565b606091505b5091509150612d9d8282604051602001612d899190615336565b604051602081830303815290604052610f41565b50505050565b6000600167ffffffffffffffff811115612dc057612dbf6139f9565b5b604051908082528060200260200182016040528015612df357816020015b6060815260200190600190039081612dde5790505b5090508281600081518110612e0b57612e0a614324565b5b60200260200101819052506000612e2c828467ffffffffffffffff16613183565b9050600080634300000173ffffffffffffffffffffffffffffffffffffffff1660405180606001604052806023815260200161599f6023913984604051602001612e779291906153a4565b604051602081830303815290604052604051612e9391906146f3565b600060405180830381855afa9150503d8060008114612ece576040519150601f19603f3d011682016040523d82523d6000602084013e612ed3565b606091505b5091509150612f018282604051602001612eed919061543a565b604051602081830303815290604052610f41565b505050505050565b6060612f1c612f17836132a2565b612f23565b9050919050565b60608060018351148015612f5b5750608083600081518110612f4857612f47614324565b5b602001015160f81c60f81b60f81c60ff16105b15612f6857829050612f98565b612f7483516080613425565b83604051602001612f8692919061545c565b60405160208183030381529060405290505b80915050919050565b6060612fcb82604051602001612fb791906154c8565b604051602081830303815290604052612f23565b9050919050565b60606000612fdf83613671565b9050612fed815160c0613425565b81604051602001612fff92919061545c565b604051602081830303815290604052915050919050565b6060600080634202000173ffffffffffffffffffffffffffffffffffffffff1685856040516020016130499291906154e3565b60405160208183030381529060405260405161306591906146f3565b6000604051808303816000865af19150503d80600081146130a2576040519150601f19603f3d011682016040523d82523d6000602084013e6130a7565b606091505b5091509150816130f4576342020001816040517f75fff4670000000000000000000000000000000000000000000000000000000081526004016130eb9291906143bf565b60405180910390fd5b809250505092915050565b60008060006041845114613148576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161313f9061555f565b60405180910390fd5b6020840151925060408401519150606084015160001a9050601b8160ff16101561317c57601b81613179919061557f565b90505b9193909250565b6060600061319083613803565b6040516020016131a0919061564e565b604051602081830303815290604052905060005b845181101561327557816131e18683815181106131d4576131d3614324565b5b6020026020010151610fc5565b6040516020016131f29291906156c7565b6040516020818303038152906040529150600185516132119190614882565b81101561323f5781604051602001613229919061574d565b6040516020818303038152906040529150613262565b8160405160200161325091906157bb565b60405160208183030381529060405291505b808061326d906148b6565b9150506131b4565b50806040516020016132879190615829565b60405160208183030381529060405290508091505092915050565b60606000826040516020016132b7919061586c565b604051602081830303815290604052905060005b602081101561333157600060f81b8282815181106132ec576132eb614324565b5b602001015160f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191603613331578080613329906148b6565b9150506132cb565b60008160206133409190614882565b67ffffffffffffffff811115613359576133586139f9565b5b6040519080825280601f01601f19166020018201604052801561338b5781602001600182028036833780820191505090505b50905060005b8151811015613419578383806133a6906148b6565b9450815181106133b9576133b8614324565b5b602001015160f81c60f81b8282815181106133d7576133d6614324565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a9053508080613411906148b6565b915050613391565b50809350505050919050565b60608060388410156134d857600167ffffffffffffffff81111561344c5761344b6139f9565b5b6040519080825280601f01601f19166020018201604052801561347e5781602001600182028036833780820191505090505b509050828461348d919061557f565b60f81b816000815181106134a4576134a3614324565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a905350613667565b600080600190505b600081876134ee91906158b6565b146135165781806134fe906148b6565b9250506101008161350f9190614932565b90506134e0565b600182613523919061498c565b67ffffffffffffffff81111561353c5761353b6139f9565b5b6040519080825280601f01601f19166020018201604052801561356e5781602001600182028036833780820191505090505b5092506037858361357f919061557f565b613589919061557f565b60f81b836000815181106135a05761359f614324565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a905350600190505b8181116136645761010081836135ea9190614882565b6101006135f791906158e7565b8761360291906158b6565b61360c9190615932565b60f81b83828151811061362257613621614324565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a905350808061365c906148b6565b9150506135d4565b50505b8091505092915050565b606060008251036136d157600067ffffffffffffffff811115613697576136966139f9565b5b6040519080825280601f01601f1916602001820160405280156136c95781602001600182028036833780820191505090505b5090506137fe565b600080600090505b835181101561371e578381815181106136f5576136f4614324565b5b60200260200101515182613709919061498c565b91508080613716906148b6565b9150506136d9565b60008267ffffffffffffffff81111561373a576137396139f9565b5b6040519080825280601f01601f19166020018201604052801561376c5781602001600182028036833780820191505090505b5090506000602082019050600092505b85518310156137f657600086848151811061379a57613799614324565b5b6020026020010151905060006020820190506137b883828451613829565b8785815181106137cb576137ca614324565b5b602002602001015151836137df919061498c565b9250505082806137ee906148b6565b93505061377c565b819450505050505b919050565b606061380e8261389f565b90506002815101613078825260028203915080825250919050565b6000839050600083905060008390505b602081106138775781518352602083613852919061498c565b9250602082613861919061498c565b91506020816138709190614882565b9050613839565b60006001826020036101000a0390508019835116818551168181178652505050505050505050565b606060806040510190506020810160405260008152806f30313233343536373839616263646566600f52600119835b6001156138fa578184019350600f8116516001850153600f8160041c165184538060081c9050806138ce575b50828203602084039350808452505050919050565b6040518060c0016040528060608152602001606081526020016060815260200160608152602001600015158152602001600067ffffffffffffffff1681525090565b6040518060200160405280600081525090565b6040518060c0016040528060006fffffffffffffffffffffffffffffffff1916815260200160006fffffffffffffffffffffffffffffffff19168152602001600067ffffffffffffffff1681526020016060815260200160608152602001606081525090565b6000604051905090565b600080fd5b600080fd5b600080fd5b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b613a31826139e8565b810181811067ffffffffffffffff82111715613a5057613a4f6139f9565b5b80604052505050565b6000613a636139ca565b9050613a6f8282613a28565b919050565b600067ffffffffffffffff821115613a8f57613a8e6139f9565b5b613a98826139e8565b9050602081019050919050565b82818337600083830152505050565b6000613ac7613ac284613a74565b613a59565b905082815260208101848484011115613ae357613ae26139e3565b5b613aee848285613aa5565b509392505050565b600082601f830112613b0b57613b0a6139de565b5b8135613b1b848260208601613ab4565b91505092915050565b6000819050919050565b613b3781613b24565b8114613b4257600080fd5b50565b600081359050613b5481613b2e565b92915050565b600067ffffffffffffffff82169050919050565b613b7781613b5a565b8114613b8257600080fd5b50565b600081359050613b9481613b6e565b92915050565b60008115159050919050565b613baf81613b9a565b8114613bba57600080fd5b50565b600081359050613bcc81613ba6565b92915050565b600080600080600060a08688031215613bee57613bed6139d4565b5b600086013567ffffffffffffffff811115613c0c57613c0b6139d9565b5b613c1888828901613af6565b9550506020613c2988828901613b45565b9450506040613c3a88828901613b45565b9350506060613c4b88828901613b85565b9250506080613c5c88828901613bbd565b9150509295509295909350565b600081519050919050565b600082825260208201905092915050565b60005b83811015613ca3578082015181840152602081019050613c88565b83811115613cb2576000848401525b50505050565b6000613cc382613c69565b613ccd8185613c74565b9350613cdd818560208601613c85565b613ce6816139e8565b840191505092915050565b60006020820190508181036000830152613d0b8184613cb8565b905092915050565b600067ffffffffffffffff821115613d2e57613d2d6139f9565b5b613d37826139e8565b9050602081019050919050565b6000613d57613d5284613d13565b613a59565b905082815260208101848484011115613d7357613d726139e3565b5b613d7e848285613aa5565b509392505050565b600082601f830112613d9b57613d9a6139de565b5b8135613dab848260208601613d44565b91505092915050565b600060208284031215613dca57613dc96139d4565b5b600082013567ffffffffffffffff811115613de857613de76139d9565b5b613df484828501613d86565b91505092915050565b600081519050919050565b600082825260208201905092915050565b6000613e2482613dfd565b613e2e8185613e08565b9350613e3e818560208601613c85565b613e47816139e8565b840191505092915050565b60006020820190508181036000830152613e6c8184613e19565b905092915050565b600060ff82169050919050565b613e8a81613e74565b82525050565b6000602082019050613ea56000830184613e81565b92915050565b613eb481613b9a565b82525050565b6000602082019050613ecf6000830184613eab565b92915050565b600060208284031215613eeb57613eea6139d4565b5b600082013567ffffffffffffffff811115613f0957613f086139d9565b5b613f1584828501613af6565b91505092915050565b613f2781613b24565b82525050565b6000602082019050613f426000830184613f1e565b92915050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000613f7382613f48565b9050919050565b613f8381613f68565b8114613f8e57600080fd5b50565b600081359050613fa081613f7a565b92915050565b600060208284031215613fbc57613fbb6139d4565b5b6000613fca84828501613f91565b91505092915050565b60008060408385031215613fea57613fe96139d4565b5b6000613ff885828601613f91565b925050602083013567ffffffffffffffff811115614019576140186139d9565b5b61402585828601613d86565b9150509250929050565b60007fffffffffffffffffffffffffffffffff0000000000000000000000000000000082169050919050565b60006140668261402f565b9050919050565b6140768161405b565b82525050565b6000602082019050614091600083018461406d565b92915050565b6140a08161402f565b81146140ab57600080fd5b50565b6000813590506140bd81614097565b92915050565b600080604083850312156140da576140d96139d4565b5b60006140e8858286016140ae565b92505060206140f985828601613f91565b9150509250929050565b61410c81613f68565b82525050565b60006020820190506141276000830184614103565b92915050565b600080600060608486031215614146576141456139d4565b5b600084013567ffffffffffffffff811115614164576141636139d9565b5b61417086828701613af6565b935050602061418186828701613b45565b925050604084013567ffffffffffffffff8111156141a2576141a16139d9565b5b6141ae86828701613d86565b9150509250925092565b600060608201905081810360008301526141d28186613e19565b90506141e16020830185613f1e565b81810360408301526141f38184613cb8565b9050949350505050565b600081905092915050565b7f7b226a736f6e727063223a22322e30222c226d6574686f64223a226574685f7360008201527f656e645261775472616e73616374696f6e222c22706172616d73223a5b220000602082015250565b6000614264603e836141fd565b915061426f82614208565b603e82019050919050565b600061428582613dfd565b61428f81856141fd565b935061429f818560208601613c85565b80840191505092915050565b7f225d2c226964223a317d00000000000000000000000000000000000000000000600082015250565b60006142e1600a836141fd565b91506142ec826142ab565b600a82019050919050565b600061430282614257565b915061430e828461427a565b9150614319826142d4565b915081905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b7f416c726561647920726567697374657265640000000000000000000000000000600082015250565b6000614389601283613e08565b915061439482614353565b602082019050919050565b600060208201905081810360008301526143b88161437c565b9050919050565b60006040820190506143d46000830185614103565b81810360208301526143e68184613cb8565b90509392505050565b6000604082019050614404600083018561406d565b6144116020830184614103565b9392505050565b600060408201905081810360008301526144328185613e19565b90506144416020830184613f1e565b9392505050565b600081905092915050565b50565b6000614463600083614448565b915061446e82614453565b600082019050919050565b600061448482614456565b9150819050919050565b600082825260208201905092915050565b60006144aa82613dfd565b6144b4818561448e565b93506144c4818560208601613c85565b6144cd816139e8565b840191505092915050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b6000614510838361449f565b905092915050565b6000602082019050919050565b6000614530826144d8565b61453a81856144e3565b93508360208202850161454c856144f4565b8060005b8581101561458857848403895281516145698582614504565b945061457483614518565b925060208a01995050600181019050614550565b50829750879550505050505092915050565b600082825260208201905092915050565b60006145b682613c69565b6145c0818561459a565b93506145d0818560208601613c85565b6145d9816139e8565b840191505092915050565b6145ed81613b9a565b82525050565b6145fc81613b5a565b82525050565b600060c083016000830151848203600086015261461f828261449f565b91505060208301518482036020860152614639828261449f565b915050604083015184820360408601526146538282614525565b9150506060830151848203606086015261466d82826145ab565b915050608083015161468260808601826145e4565b5060a083015161469560a08601826145f3565b508091505092915050565b600060208201905081810360008301526146ba8184614602565b905092915050565b60006146cd82613c69565b6146d78185614448565b93506146e7818560208601613c85565b80840191505092915050565b60006146ff82846146c2565b915081905092915050565b600061471d61471884613d13565b613a59565b905082815260208101848484011115614739576147386139e3565b5b614744848285613c85565b509392505050565b600082601f830112614761576147606139de565b5b815161477184826020860161470a565b91505092915050565b6000602082840312156147905761478f6139d4565b5b600082015167ffffffffffffffff8111156147ae576147ad6139d9565b5b6147ba8482850161474c565b91505092915050565b60006147cf828561427a565b91506147db828461427a565b91508190509392505050565b7f496e70757420746f6f2073686f72740000000000000000000000000000000000600082015250565b600061481d600f83613e08565b9150614828826147e7565b602082019050919050565b6000602082019050818103600083015261484c81614810565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600061488d82613b24565b915061489883613b24565b9250828210156148ab576148aa614853565b5b828203905092915050565b60006148c182613b24565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82036148f3576148f2614853565b5b600182019050919050565b600061490982613e74565b915061491483613e74565b92508282101561492757614926614853565b5b828203905092915050565b600061493d82613b24565b915061494883613b24565b9250817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff048311821515161561498157614980614853565b5b828202905092915050565b600061499782613b24565b91506149a283613b24565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff038211156149d7576149d6614853565b5b828201905092915050565b60006149ed82613b24565b915060008203614a00576149ff614853565b5b600182039050919050565b60008160011c9050919050565b6000808291508390505b6001851115614a6257808604811115614a3e57614a3d614853565b5b6001851615614a4d5780820291505b8081029050614a5b85614a0b565b9450614a22565b94509492505050565b600082614a7b5760019050614b37565b81614a895760009050614b37565b8160018114614a9f5760028114614aa957614ad8565b6001915050614b37565b60ff841115614abb57614aba614853565b5b8360020a915084821115614ad257614ad1614853565b5b50614b37565b5060208310610133831016604e8410600b8410161715614b0d5782820a905083811115614b0857614b07614853565b5b614b37565b614b1a8484846001614a18565b92509050818404811115614b3157614b30614853565b5b81810290505b9392505050565b6000614b4982613b24565b9150614b5483613e74565b9250614b817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8484614a6b565b905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b60028110614bc957614bc8614b89565b5b50565b6000819050614bda82614bb8565b919050565b6000614bea82614bcc565b9050919050565b614bfa81614bdf565b82525050565b6000602082019050614c156000830184614bf1565b92915050565b6000614c2e614c2984613a74565b613a59565b905082815260208101848484011115614c4a57614c496139e3565b5b614c55848285613c85565b509392505050565b600082601f830112614c7257614c716139de565b5b8151614c82848260208601614c1b565b91505092915050565b600060208284031215614ca157614ca06139d4565b5b600082015167ffffffffffffffff811115614cbf57614cbe6139d9565b5b614ccb84828501614c5d565b91505092915050565b7f796f000000000000000000000000000000000000000000000000000000000000600082015250565b6000614d0a600283613e08565b9150614d1582614cd4565b602082019050919050565b60006020820190508181036000830152614d3981614cfd565b9050919050565b6000819050919050565b6000819050919050565b614d65614d6082614d40565b614d4a565b82525050565b6000614d778284614d54565b60208201915081905092915050565b60006060820190508181036000830152614da08186613cb8565b90508181036020830152614db48185613e19565b90508181036040830152614dc88184613e19565b9050949350505050565b60006060820190508181036000830152614dec8186613cb8565b9050614dfb6020830185614bf1565b8181036040830152614e0d8184613e19565b9050949350505050565b614e2081614d40565b82525050565b6000608082019050614e3b6000830187614e17565b614e486020830186613e81565b614e556040830185614e17565b614e626060830184614e17565b95945050505050565b614e7481613b5a565b82525050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b614eaf81613f68565b82525050565b6000614ec18383614ea6565b60208301905092915050565b6000602082019050919050565b6000614ee582614e7a565b614eef8185614e85565b9350614efa83614e96565b8060005b83811015614f2b578151614f128882614eb5565b9750614f1d83614ecd565b925050600181019050614efe565b5085935050505092915050565b6000608082019050614f4d6000830187614e6b565b8181036020830152614f5f8186614eda565b90508181036040830152614f738185614eda565b90508181036060830152614f878184613e19565b905095945050505050565b600080fd5b600080fd5b600081519050614fab81614097565b92915050565b600081519050614fc081613b6e565b92915050565b600067ffffffffffffffff821115614fe157614fe06139f9565b5b602082029050602081019050919050565b600080fd5b60008151905061500681613f7a565b92915050565b600061501f61501a84614fc6565b613a59565b9050808382526020820190506020840283018581111561504257615041614ff2565b5b835b8181101561506b57806150578882614ff7565b845260208401935050602081019050615044565b5050509392505050565b600082601f83011261508a576150896139de565b5b815161509a84826020860161500c565b91505092915050565b600060c082840312156150b9576150b8614f92565b5b6150c360c0613a59565b905060006150d384828501614f9c565b60008301525060206150e784828501614f9c565b60208301525060406150fb84828501614fb1565b604083015250606082015167ffffffffffffffff81111561511f5761511e614f97565b5b61512b84828501615075565b606083015250608082015167ffffffffffffffff81111561514f5761514e614f97565b5b61515b84828501615075565b60808301525060a082015167ffffffffffffffff81111561517f5761517e614f97565b5b61518b84828501614c5d565b60a08301525092915050565b6000602082840312156151ad576151ac6139d4565b5b600082015167ffffffffffffffff8111156151cb576151ca6139d9565b5b6151d7848285016150a3565b91505092915050565b60006060820190506151f5600083018661406d565b81810360208301526152078185613e19565b9050818103604083015261521b8184613cb8565b9050949350505050565b7f7b22747873223a205b2200000000000000000000000000000000000000000000600082015250565b600061525b600a836141fd565b915061526682615225565b600a82019050919050565b7f225d7d0000000000000000000000000000000000000000000000000000000000600082015250565b60006152a76003836141fd565b91506152b282615271565b600382019050919050565b60006152c88261524e565b91506152d4828461427a565b91506152df8261529a565b915081905092915050565b7f42756e646c6553696d756c6174696f6e4661696c65643a200000000000000000600082015250565b60006153206018836141fd565b915061532b826152ea565b601882019050919050565b600061534182615313565b915061534d828461427a565b915081905092915050565b7f6574685f73656e6442756e646c65000000000000000000000000000000000000600082015250565b600061538e600e83613e08565b915061539982615358565b602082019050919050565b600060608201905081810360008301526153be8185613e19565b905081810360208301526153d181615381565b905081810360408301526153e58184613cb8565b90509392505050565b7f42756e646c655375626d697373696f6e4661696c65643a200000000000000000600082015250565b60006154246018836141fd565b915061542f826153ee565b601882019050919050565b600061544582615417565b9150615451828461427a565b915081905092915050565b600061546882856146c2565b915061547482846146c2565b91508190509392505050565b60008160601b9050919050565b600061549882615480565b9050919050565b60006154aa8261548d565b9050919050565b6154c26154bd82613f68565b61549f565b82525050565b60006154d482846154b1565b60148201915081905092915050565b60006040820190506154f8600083018561406d565b818103602083015261550a8184613e19565b90509392505050565b7f696e76616c6964207369676e6174757265206c656e6774680000000000000000600082015250565b6000615549601883613e08565b915061555482615513565b602082019050919050565b600060208201905081810360008301526155788161553c565b9050919050565b600061558a82613e74565b915061559583613e74565b92508260ff038211156155ab576155aa614853565b5b828201905092915050565b7f7b22626c6f636b4e756d626572223a2022000000000000000000000000000000600082015250565b60006155ec6011836141fd565b91506155f7826155b6565b601182019050919050565b7f222c2022747873223a205b000000000000000000000000000000000000000000600082015250565b6000615638600b836141fd565b915061564382615602565b600b82019050919050565b6000615659826155df565b9150615665828461427a565b91506156708261562b565b915081905092915050565b7f2200000000000000000000000000000000000000000000000000000000000000600082015250565b60006156b16001836141fd565b91506156bc8261567b565b600182019050919050565b60006156d382856146c2565b91506156de826156a4565b91506156ea828461427a565b91506156f5826156a4565b91508190509392505050565b7f2c00000000000000000000000000000000000000000000000000000000000000600082015250565b60006157376001836141fd565b915061574282615701565b600182019050919050565b600061575982846146c2565b91506157648261572a565b915081905092915050565b7f5d00000000000000000000000000000000000000000000000000000000000000600082015250565b60006157a56001836141fd565b91506157b08261576f565b600182019050919050565b60006157c782846146c2565b91506157d282615798565b915081905092915050565b7f7d00000000000000000000000000000000000000000000000000000000000000600082015250565b60006158136001836141fd565b915061581e826157dd565b600182019050919050565b600061583582846146c2565b915061584082615806565b915081905092915050565b6000819050919050565b61586661586182613b24565b61584b565b82525050565b60006158788284615855565b60208201915081905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b60006158c182613b24565b91506158cc83613b24565b9250826158dc576158db615887565b5b828204905092915050565b60006158f282613b24565b91506158fd83613b24565b925061592a7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8484614a6b565b905092915050565b600061593d82613b24565b915061594883613b24565b92508261595857615957615887565b5b82820690509291505056fe68747470733a2f2f646174612d6170692e62696e616e63652e766973696f6e2f6170692f76332f7469636b65722f70726963653f73796d626f6c3d68747470733a2f2f72656c61792d686f6c65736b792e666c617368626f74732e6e6574a2646970667358221220e2c46906cce60f1d6bcb29686bcf9b4d93a98474e54cf7ad972468efca1e108e64736f6c634300080d0033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 3756,
        "contract": "contracts/oracle/BinanceOracle.sol:BinanceOracle",
        "label": "isInitialized",
        "offset": 0,
        "slot": "0",
        "type": "t_bool"
      },
      {
        "astId": 3759,
        "contract": "contracts/oracle/BinanceOracle.sol:BinanceOracle",
        "label": "pkBidId",
        "offset": 1,
        "slot": "0",
        "type": "t_userDefinedValueType(DataId)859"
      },
      {
        "astId": 3761,
        "contract": "contracts/oracle/BinanceOracle.sol:BinanceOracle",
        "label": "controller",
        "offset": 0,
        "slot": "1",
        "type": "t_address"
      },
      {
        "astId": 3763,
        "contract": "contracts/oracle/BinanceOracle.sol:BinanceOracle",
        "label": "settlementContract",
        "offset": 0,
        "slot": "2",
        "type": "t_address"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_userDefinedValueType(DataId)859": {
        "encoding": "inplace",
        "label": "Suave.DataId",
        "numberOfBytes": "16"
      }
    }
  }
}