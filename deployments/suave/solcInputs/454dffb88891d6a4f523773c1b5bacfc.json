{
  "language": "Solidity",
  "sources": {
    "contracts/libraries/Suave.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.8;\n\nlibrary Suave {\n    error PeekerReverted(address, bytes);\n\n    type BidId is bytes16;\n\n    struct Bid {\n        BidId id;\n        uint64 decryptionCondition;\n        address[] allowedPeekers;\n        string version;\n    }\n\n    struct BuildBlockArgs {\n        uint64 slot;\n        bytes proposerPubkey;\n        bytes32 parent;\n        uint64 timestamp;\n        address feeRecipient;\n        uint64 gasLimit;\n        bytes32 random;\n        Withdrawal[] withdrawals;\n    }\n\n    struct Withdrawal {\n        uint64 index;\n        uint64 validator;\n        address Address;\n        uint64 amount;\n    }\n\n    address public constant IS_CONFIDENTIAL_ADDR = 0x0000000000000000000000000000000042010000;\n\n    address public constant BUILD_ETH_BLOCK = 0x0000000000000000000000000000000042100001;\n\n    address public constant CONFIDENTIAL_INPUTS = 0x0000000000000000000000000000000042010001;\n\n    address public constant CONFIDENTIAL_STORE_RETRIEVE = 0x0000000000000000000000000000000042020001;\n\n    address public constant CONFIDENTIAL_STORE_STORE = 0x0000000000000000000000000000000042020000;\n\n    address public constant EXTRACT_HINT = 0x0000000000000000000000000000000042100037;\n\n    address public constant FETCH_BIDS = 0x0000000000000000000000000000000042030001;\n\n    address public constant NEW_BID = 0x0000000000000000000000000000000042030000;\n\n    address public constant SIMULATE_BUNDLE = 0x0000000000000000000000000000000042100000;\n\n    address public constant SUBMIT_ETH_BLOCK_BID_TO_RELAY = 0x0000000000000000000000000000000042100002;\n\n    // Returns whether execution is off- or on-chain\n    function isConfidential() internal view returns (bool b) {\n        (bool success, bytes memory isConfidentialBytes) = IS_CONFIDENTIAL_ADDR.staticcall(\"\");\n        if (!success) {\n            revert PeekerReverted(IS_CONFIDENTIAL_ADDR, isConfidentialBytes);\n        }\n        assembly {\n            // Load the length of data (first 32 bytes)\n            let len := mload(isConfidentialBytes)\n            // Load the data after 32 bytes, so add 0x20\n            b := mload(add(isConfidentialBytes, 0x20))\n        }\n    }\n\n    function buildEthBlock(BuildBlockArgs memory blockArgs, BidId bidId, string memory namespace)\n        internal\n        view\n        returns (bytes memory, bytes memory)\n    {\n        (bool success, bytes memory data) = BUILD_ETH_BLOCK.staticcall(abi.encode(blockArgs, bidId, namespace));\n        if (!success) {\n            revert PeekerReverted(BUILD_ETH_BLOCK, data);\n        }\n\n        return abi.decode(data, (bytes, bytes));\n    }\n\n    function confidentialInputs() internal view returns (bytes memory) {\n        (bool success, bytes memory data) = CONFIDENTIAL_INPUTS.staticcall(abi.encode());\n        if (!success) {\n            revert PeekerReverted(CONFIDENTIAL_INPUTS, data);\n        }\n\n        return data;\n    }\n\n    function confidentialStoreRetrieve(BidId bidId, string memory key) internal view returns (bytes memory) {\n        (bool success, bytes memory data) = CONFIDENTIAL_STORE_RETRIEVE.staticcall(abi.encode(bidId, key));\n        if (!success) {\n            revert PeekerReverted(CONFIDENTIAL_STORE_RETRIEVE, data);\n        }\n\n        return data;\n    }\n\n    function confidentialStoreStore(BidId bidId, string memory key, bytes memory data1) internal view {\n        (bool success, bytes memory data) = CONFIDENTIAL_STORE_STORE.staticcall(abi.encode(bidId, key, data1));\n        if (!success) {\n            revert PeekerReverted(CONFIDENTIAL_STORE_STORE, data);\n        }\n    }\n\n    function extractHint(bytes memory bundleData) internal view returns (bytes memory) {\n        require(isConfidential());\n        (bool success, bytes memory data) = EXTRACT_HINT.staticcall(abi.encode(bundleData));\n        if (!success) {\n            revert PeekerReverted(EXTRACT_HINT, data);\n        }\n\n        return data;\n    }\n\n    function fetchBids(uint64 cond, string memory namespace) internal view returns (Bid[] memory) {\n        (bool success, bytes memory data) = FETCH_BIDS.staticcall(abi.encode(cond, namespace));\n        if (!success) {\n            revert PeekerReverted(FETCH_BIDS, data);\n        }\n\n        return abi.decode(data, (Bid[]));\n    }\n\n    function newBid(uint64 decryptionCondition, address[] memory allowedPeekers, string memory bidType)\n        internal\n        view\n        returns (Bid memory)\n    {\n        (bool success, bytes memory data) = NEW_BID.staticcall(abi.encode(decryptionCondition, allowedPeekers, bidType));\n        if (!success) {\n            revert PeekerReverted(NEW_BID, data);\n        }\n\n        return abi.decode(data, (Bid));\n    }\n\n    function simulateBundle(bytes memory bundleData) internal view returns (uint64) {\n        (bool success, bytes memory data) = SIMULATE_BUNDLE.staticcall(abi.encode(bundleData));\n        if (!success) {\n            revert PeekerReverted(SIMULATE_BUNDLE, data);\n        }\n\n        return abi.decode(data, (uint64));\n    }\n\n    function submitEthBlockBidToRelay(string memory relayUrl, bytes memory builderBid)\n        internal\n        view\n        returns (bytes memory)\n    {\n        require(isConfidential());\n        (bool success, bytes memory data) = SUBMIT_ETH_BLOCK_BID_TO_RELAY.staticcall(abi.encode(relayUrl, builderBid));\n        if (!success) {\n            revert PeekerReverted(SUBMIT_ETH_BLOCK_BID_TO_RELAY, data);\n        }\n\n        return data;\n    }\n}\n"
    },
    "contracts/libraries/SuaveAbi.sol": {
      "content": "pragma solidity ^0.8.8;\n\nimport {Suave} from \"./Suave.sol\";\n\ncontract SuaveAbi {\n    error PeekerReverted(address, bytes);\n\n    function newBid(uint64 decryptionCondition, address[] memory allowedPeekers, string memory BidType) external view returns (Suave.Bid memory) {}\n\tfunction fetchBids(uint64 cond, string memory namespace) external view returns (Suave.Bid[] memory) {}\n    function confidentialStoreStore(Suave.BidId bidId, string memory key, bytes memory data) external view {}\n    function confidentialStoreRetrieve(Suave.BidId bidId, string memory key) external view returns (bytes memory) {}\n    function simulateBundle(bytes memory bundleData) external view returns (uint64) {}\n    function extractHint(bytes memory bundleData) external view returns (bytes memory) {}\n\tfunction buildEthBlock(Suave.BuildBlockArgs memory blockArgs, Suave.BidId bid, string memory namespace) external view returns (bytes memory, bytes memory) {}\n    function submitEthBlockBidToRelay(string memory relayUrl, bytes memory builderBid) external view returns (bytes memory) {}\n}\n"
    },
    "contracts/standard_peekers/bids.sol": {
      "content": "pragma solidity ^0.8.8;\n\nimport \"../libraries/Suave.sol\";\n\ncontract AnyBidContract {\n\n\tevent BidEvent(\n\t\tSuave.BidId bidId,\n\t\tuint64 decryptionCondition,\n\t\taddress[] allowedPeekers\n\t);\n\n\tfunction fetchBidConfidentialBundleData() public returns (bytes memory) {\n\t\trequire(Suave.isConfidential());\n\t\t\n\t\tbytes memory confidentialInputs = Suave.confidentialInputs();\n\t\treturn abi.decode(confidentialInputs, (bytes));\n\t}\n\n\t// Bids to this contract should not be trusted!\n\tfunction emitBid(Suave.Bid calldata bid) public {\n\t\temit BidEvent(bid.id, bid.decryptionCondition, bid.allowedPeekers);\n\t}\n}\n\ncontract BundleBidContract is AnyBidContract {\n\n\tfunction newBid(uint64 decryptionCondition, address[] memory bidAllowedPeekers) external payable returns (bytes memory) {\n\t\trequire(Suave.isConfidential());\n\n\t\tbytes memory bundleData = this.fetchBidConfidentialBundleData();\n\n\t\tuint64 egp = Suave.simulateBundle(bundleData);\n\n\t\tSuave.Bid memory bid = Suave.newBid(decryptionCondition, bidAllowedPeekers, \"default:v0:ethBundles\");\n\n\t\tSuave.confidentialStoreStore(bid.id, \"default:v0:ethBundles\", bundleData);\n\t\tSuave.confidentialStoreStore(bid.id, \"default:v0:ethBundleSimResults\", abi.encode(egp));\n\n\t\temit BidEvent(bid.id, bid.decryptionCondition, bid.allowedPeekers);\n\t\treturn bytes.concat(this.emitBid.selector, abi.encode(bid));\n\t}\n}\n\ncontract MevShareBidContract is AnyBidContract {\n\n\tevent HintEvent(\n\t\tSuave.BidId bidId,\n\t\tbytes hint\n\t);\n\n\tevent MatchEvent(\n\t\tSuave.BidId matchBidId,\n\t\tbytes bidhint,\n\t\tbytes matchHint\n\t);\n\n\tfunction newBid(uint64 decryptionCondition, address[] memory bidAllowedPeekers) external payable returns (bytes memory) {\n\t\t// 0. check confidential execution\n\t\trequire(Suave.isConfidential());\n\n\t\t// 1. fetch bundle data\n\t\tbytes memory bundleData = this.fetchBidConfidentialBundleData();\n\n\t\t// 2. sim bundle\n\t\tuint64 egp = Suave.simulateBundle(bundleData);\n\t\t\n\t\t// 3. extract hint\n\t\tbytes memory hint = Suave.extractHint(bundleData);\n\t\t\n\t\t// // 4. store bundle and sim results\n\t\tSuave.Bid memory bid = Suave.newBid(decryptionCondition, bidAllowedPeekers, \"mevshare:v0:unmatchedBundles\");\n\t\tSuave.confidentialStoreStore(bid.id, \"mevshare:v0:ethBundles\", bundleData);\n\t\tSuave.confidentialStoreStore(bid.id, \"mevshare:v0:ethBundleSimResults\", abi.encode(egp));\n\t\temit BidEvent(bid.id, bid.decryptionCondition, bid.allowedPeekers);\n\t\temit HintEvent(bid.id, hint);\n\n\t\t// // 5. return \"callback\" to emit hint onchain\n\t\treturn bytes.concat(this.emitBidAndHint.selector, abi.encode(bid, hint));\n\t}\n\n\tfunction emitBidAndHint(Suave.Bid calldata bid, bytes memory hint) public {\n\t\temit BidEvent(bid.id, bid.decryptionCondition, bid.allowedPeekers);\n\t\temit HintEvent(bid.id, hint);\n\t}\n\n\tfunction newMatch(uint64 decryptionCondition, address[] memory bidAllowedPeekers, Suave.BidId shareBidId) external payable returns (bytes memory) {\n\t\t// WARNING : this function will copy the original mev share bid\n\t\t// into a new key with potentially different permsissions\n\t\t\n\t\trequire(Suave.isConfidential());\n\t\t// 1. fetch confidential data\n\t\tbytes memory matchBundleData = this.fetchBidConfidentialBundleData();\n\n\t\t// 2. sim match alone for validity\n\t\tuint64 egp = Suave.simulateBundle(matchBundleData);\n\n\t\t// 3. extract hint\n\t\tbytes memory matchHint = Suave.extractHint(matchBundleData);\n\t\t\n\t\tSuave.Bid memory bid = Suave.newBid(decryptionCondition, bidAllowedPeekers, \"mevshare:v0:matchBids\");\n\t\tSuave.confidentialStoreStore(bid.id, \"mevshare:v0:ethBundles\", matchBundleData);\n\t\tSuave.confidentialStoreStore(bid.id, \"mevshare:v0:ethBundleSimResults\", abi.encode(0));\n\n\t\t//4. merge bids\n\t\tSuave.BidId[] memory bids = new Suave.BidId[](2);\n\t\tbids[0] = shareBidId;\n\t\tbids[1] = bid.id;\n\t\tSuave.confidentialStoreStore(bid.id, \"mevshare:v0:mergedBids\", abi.encode(bids));\n\n\t\treturn bytes.concat(this.emitBid.selector, abi.encode(bid));\n\t}\n\n\tfunction emitMatchBidAndHint(Suave.Bid calldata bid, bytes memory bidHint, bytes memory matchHint) public {\n\t\temit BidEvent(bid.id, bid.decryptionCondition, bid.allowedPeekers);\n\t\temit MatchEvent(bid.id, bidHint, matchHint);\n\t}\n}\n\n/* Not tested or implemented on the precompile side */\nstruct EgpBidPair {\n\tuint64 egp; // in wei, beware overflow\n\tSuave.BidId bidId;\n}\n\ncontract EthBlockBidContract is AnyBidContract {\n\n\tevent BuilderBoostBidEvent(\n\t\tSuave.BidId bidId,\n\t\tbytes builderBid\n\t);\n\t\n\tfunction idsEqual(Suave.BidId _l, Suave.BidId _r) public pure returns (bool) {\n\t\tbytes memory l = abi.encodePacked(_l);\n\t\tbytes memory r = abi.encodePacked(_r);\n\t\tfor (uint i = 0; i < l.length; i++) {\n\t\t\tif (bytes(l)[i] != r[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tfunction buildMevShare(Suave.BuildBlockArgs memory blockArgs, uint64 blockHeight) public returns (bytes memory) {\n\t\trequire(Suave.isConfidential());\n\n\t\tSuave.Bid[] memory allShareMatchBids = Suave.fetchBids(blockHeight, \"mevshare:v0:matchBids\");\n\t\tSuave.Bid[] memory allShareUserBids = Suave.fetchBids(blockHeight, \"mevshare:v0:unmatchedBundles\");\n\n\t\tif (allShareUserBids.length == 0) {\n\t\t\trevert Suave.PeekerReverted(address(this), \"no bids\");\n\t\t}\n\n\t\tSuave.Bid[] memory allBids = new Suave.Bid[](allShareUserBids.length);\n\t\tfor (uint i = 0; i < allShareUserBids.length; i++) {\n\t\t\t// TODO: sort matches by egp first!\n\t\t\tSuave.Bid memory bidToInsert = allShareUserBids[i]; // will be updated with the best match if any\n\t\t\tfor (uint j = 0; j < allShareMatchBids.length; j++) {\n\t\t\t\t// TODO: should be done once at the start and sorted\n\t\t\t\tSuave.BidId[] memory mergedBidIds = abi.decode(Suave.confidentialStoreRetrieve(allShareMatchBids[j].id, \"mevshare:v0:mergedBids\"), (Suave.BidId[]));\n\t\t\t\tif (idsEqual(mergedBidIds[0], allShareUserBids[i].id)) {\n\t\t\t\t\tbidToInsert = allShareMatchBids[j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tallBids[i] = bidToInsert;\n\t\t}\n\n\t\tEgpBidPair[] memory bidsByEGP = new EgpBidPair[](allBids.length);\n\t\tfor (uint i = 0; i < allBids.length; i++) {\n\t\t\tbytes memory simResults = Suave.confidentialStoreRetrieve(allBids[i].id, \"mevshare:v0:ethBundleSimResults\");\n\t\t\tuint64 egp = abi.decode(simResults, (uint64));\n\t\t\tbidsByEGP[i] = EgpBidPair(egp, allBids[i].id);\n\t\t}\n\n\t\t// Bubble sort, cause why not\n\t\tuint n = bidsByEGP.length;\n\t\tfor (uint i = 0; i < n - 1; i++) {\n\t\t\tfor (uint j = i + 1; j < n; j++) {\n\t\t\t\tif (bidsByEGP[i].egp < bidsByEGP[j].egp) {\n\t\t\t\t\tEgpBidPair memory temp = bidsByEGP[i];\n\t\t\t\t\tbidsByEGP[i] = bidsByEGP[j];\n\t\t\t\t\tbidsByEGP[j] = temp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSuave.BidId[] memory allBidIds = new Suave.BidId[](allBids.length);\n\t\tfor (uint i = 0; i < bidsByEGP.length; i++) {\n\t\t\tallBidIds[i] = bidsByEGP[i].bidId;\n\t\t}\n\n\t\treturn buildAndEmit(blockArgs, blockHeight, allBidIds, \"mevshare:v0\");\n\t}\n\n\tfunction buildFromPool(Suave.BuildBlockArgs memory blockArgs, uint64 blockHeight) public returns (bytes memory) {\n\t\trequire(Suave.isConfidential());\n\n\t\tSuave.Bid[] memory allBids = Suave.fetchBids(blockHeight, \"default:v0:ethBundles\");\n\t\tif (allBids.length == 0) {\n\t\t\trevert Suave.PeekerReverted(address(this), \"no bids\");\n\t\t}\n\n\t\tEgpBidPair[] memory bidsByEGP = new EgpBidPair[](allBids.length);\n\t\tfor (uint i = 0; i < allBids.length; i++) {\n\t\t\tbytes memory simResults = Suave.confidentialStoreRetrieve(allBids[i].id, \"default:v0:ethBundleSimResults\");\n\t\t\tuint64 egp = abi.decode(simResults, (uint64));\n\t\t\tbidsByEGP[i] = EgpBidPair(egp, allBids[i].id);\n\t\t}\n\n\t\t// Bubble sort, cause why not\n\t\tuint n = bidsByEGP.length;\n\t\tfor (uint i = 0; i < n - 1; i++) {\n\t\t\tfor (uint j = i + 1; j < n; j++) {\n\t\t\t\tif (bidsByEGP[i].egp < bidsByEGP[j].egp) {\n\t\t\t\t\tEgpBidPair memory temp = bidsByEGP[i];\n\t\t\t\t\tbidsByEGP[i] = bidsByEGP[j];\n\t\t\t\t\tbidsByEGP[j] = temp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSuave.BidId[] memory allBidIds = new Suave.BidId[](allBids.length);\n\t\tfor (uint i = 0; i < bidsByEGP.length; i++) {\n\t\t\tallBidIds[i] = bidsByEGP[i].bidId;\n\t\t}\n\n\t\treturn buildAndEmit(blockArgs, blockHeight, allBidIds, \"\");\n\t}\n\n\tfunction buildAndEmit(Suave.BuildBlockArgs memory blockArgs, uint64 blockHeight, Suave.BidId[] memory bids, string memory namespace) public virtual returns (bytes memory) {\n\t\trequire(Suave.isConfidential());\n\n\t\t(Suave.Bid memory blockBid, bytes memory builderBid) = this.doBuild(blockArgs, blockHeight, bids, namespace);\n\n\t\temit BuilderBoostBidEvent(blockBid.id, builderBid);\n\t\temit BidEvent(blockBid.id, blockBid.decryptionCondition, blockBid.allowedPeekers);\n\t\treturn bytes.concat(this.emitBuilderBidAndBid.selector, abi.encode(blockBid, builderBid));\n\t}\n\n\tfunction doBuild(Suave.BuildBlockArgs memory blockArgs, uint64 blockHeight, Suave.BidId[] memory bids, string memory namespace) public view returns (Suave.Bid memory, bytes memory) {\n\t\taddress[] memory allowedPeekers = new address[](2);\n\t\tallowedPeekers[0] = address(this);\n\t\tallowedPeekers[1] = Suave.BUILD_ETH_BLOCK;\n\n\t\tSuave.Bid memory blockBid = Suave.newBid(blockHeight, allowedPeekers, \"default:v0:mergedBids\");\n\t\tSuave.confidentialStoreStore(blockBid.id, \"default:v0:mergedBids\", abi.encode(bids));\n\t\t \n\t\t(bytes memory builderBid, bytes memory payload) = Suave.buildEthBlock(blockArgs, blockBid.id, namespace);\n\t\tSuave.confidentialStoreStore(blockBid.id, \"default:v0:builderPayload\", payload); // only through this.unlock\n\n\t\treturn (blockBid, builderBid);\n\t}\n\n\tfunction emitBuilderBidAndBid(Suave.Bid memory bid, bytes memory builderBid) public returns (Suave.Bid memory, bytes memory) {\n\t\temit BuilderBoostBidEvent(bid.id, builderBid);\n\t\temit BidEvent(bid.id, bid.decryptionCondition, bid.allowedPeekers);\n\t\treturn (bid, builderBid);\n\t}\n\n\tfunction unlock(Suave.BidId bidId, bytes memory signedBlindedHeader) public view returns (bytes memory) {\n\t\trequire(Suave.isConfidential());\n\n\t\t// TODO: verify the header is correct\n\t\t// TODO: incorporate protocol name\n\t\tbytes memory payload = Suave.confidentialStoreRetrieve(bidId, \"default:v0:builderPayload\");\n\t\treturn payload;\n\t}\n}\n\ncontract EthBlockBidSenderContract is EthBlockBidContract {\n\tstring boostRelayUrl;\n\n\tconstructor(string memory boostRelayUrl_) {\n\t\tboostRelayUrl = boostRelayUrl_;\n\t}\n\n\tfunction buildAndEmit(Suave.BuildBlockArgs memory blockArgs, uint64 blockHeight, Suave.BidId[] memory bids, string memory namespace) public virtual override returns (bytes memory) {\n\t\trequire(Suave.isConfidential());\n\n\t\t(Suave.Bid memory blockBid, bytes memory builderBid) = this.doBuild(blockArgs, blockHeight, bids, namespace);\n\t\tSuave.submitEthBlockBidToRelay(boostRelayUrl, builderBid);\n\n\t\temit BidEvent(blockBid.id, blockBid.decryptionCondition, blockBid.allowedPeekers);\n\t\treturn bytes.concat(this.emitBid.selector, abi.encode(blockBid));\n\t}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}